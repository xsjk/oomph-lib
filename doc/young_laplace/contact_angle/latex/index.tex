\chapter{Example problem\+: The Young Laplace equation with contact angle boundary conditions}
\hypertarget{index}{}\label{index}\index{Example problem: The Young Laplace equation with contact angle boundary conditions@{Example problem: The Young Laplace equation with contact angle boundary conditions}}
In this document we demonstrate the adaptive solution of the Young Laplace equation with contact angle boundary conditions. We start by reviewing the physical background in the context of a representative model problem, and then discuss the spine-\/based representation of free contact lines and the implementation of the contact angle boundary condition along such lines.

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{Acknowledgement\+:}} \end{center}  This tutorial and the associated driver codes were developed jointly with Cedric Ody (Ecole Polytechnique, Paris; now Rennes). ~\newline
~\newline
  \\\cline{1-1}
\end{longtabu}
\end{center} 

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_model}{}\doxysection{\texorpdfstring{A model problem}{A model problem}}\label{index_model}
The figure below shows a sketch of a T-\/junction in a microchannel with a rectangular cross-\/section. (The front wall has been removed for clarity). Fluid is being pushed quasi-\/steadily along the (vertical) main channel and is in the process of entering the T-\/junction. We assume that the air-\/liquid interface (shown in red) remains pinned at the two sharp edges (at $ y=const.$) where the channels meet, while the meniscus forms a quasi-\/static contact angle, $ \gamma $, with the smooth front and back walls.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{t_junction_contact_angle_sketch}
\doxyfigcaption{A typical problem\+: Fluid propagates quasi-\/steadily through a T-\/junction that connects two channels of rectangular cross-\/section. }
\end{DoxyImage}


It is of interest to determine the maximum pressure that the meniscus can withstand\+: if the driving pressure is less than that value, the fluid will not be able to propagate past the T-\/junction.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_theory}{}\doxysection{\texorpdfstring{Theory and implementation}{Theory and implementation}}\label{index_theory}
\hypertarget{index_spine}{}\doxysubsection{\texorpdfstring{Spine-\/based representation of the meniscus}{Spine-based representation of the meniscus}}\label{index_spine}
\href{../../young_laplace/html/index.html}{\texttt{ Recall}} that we parametrised the meniscus by two intrinsic coordinates as $ {\bf R}(\zeta_1,\zeta_2) \in {R}^3 $, where $(\zeta_1,\zeta_2) \in D \in {R}^2$. Furthermore, we parametrised the domain boundary, $\partial D$, by a scalar coordinate $\xi$ so that,  \[
{\partial D} =  \bigg\{ (\zeta_1,\zeta_2) \ \bigg| \ (\zeta_1,\zeta_2) =
\left( \zeta_1^{[\partial D]}(\xi), \ 
\zeta_2^{[\partial D]}(\xi) \right) \bigg\}.
\] The normal to the meniscus is then given by  \[
{\bf N} = \frac{{\bf R}_{,1} \times {\bf R}_{,2} }
{|{\bf R}_{,1} \times {\bf R}_{,2}|},
\] where a comma denotes partial differentiation with respect to one of the intrinsic coordinates, $ (\zeta_1, \zeta_2). $

Along the contact line we define two unit vectors, ${\bf T}_t$ and ${\bf T}_n$, that are tangential to the meniscus. ${\bf T}_t$ is tangent to the contact line while ${\bf T}_n$ is normal to it and points away from the meniscus, as shown in the sketch below.

We split the domain boundary $ \partial D $ so that $ \partial D = 
\partial D_{\rm pinned} \cup \partial D_{\rm angle} $ and assume that along $\partial D_{\rm pinned}$ the meniscus is pinned,  \[
\left. {\bf R} \right|_{\partial D_{\rm pinned}} = {\bf R}_{\rm pinned}(\xi),
\] where ${\bf R}_{\rm pinned}(\xi) $ is given. On $\partial D_{\rm  angle}$ the meniscus meets the wall at a prescribed contact angle $\gamma$ so that  \[
\left. \left( ({\bf T}_t \times {\bf N}_{\rm wall}) \cdot {\bf T}_n\right) 
\right|_{\partial D_{angle}} = \cos \gamma,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (1)
\] where ${\bf N}_{\rm wall}$ is the outer unit normal to the wall as shown in this sketch\+:

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{contact_angle_sketch}
\doxyfigcaption{Sketch of the meniscus, the contact line along which it meets the wall, and the spine-\/based representation of the meniscus. }
\end{DoxyImage}


The figure also illustrates the spine-\/based representation of the meniscus in the form  \[
{\bf R}(\zeta_1,\zeta_2) = 
{\bf B}(\zeta_1,\zeta_2) +
u(\zeta_1,\zeta_2) \ {\bf S}(\zeta_1,\zeta_2)
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2)
\] where the spine basis ${\bf R}(\zeta_1,\zeta_2)$ and spines ${\bf S}(\zeta_1,\zeta_2)$ are pre-\/determined vector fields, chosen such that ~\newline

\begin{DoxyItemize}
\item The mapping from $(\zeta_1,\zeta_2)$ to ${\bf R}(\zeta_1,\zeta_2)$ ~\newline
 is one-\/to-\/one, at least for the meniscus shapes of interest. ~\newline
~\newline

\item Along the parts of the boundary where the contact line is pinned we have  \[
  \left. {\bf B}\right|_{\partial D_{\rm pinned}} = {\bf R}_{\rm pinned}
  \] so that the pinned boundary condition may be enforced by setting $ u|_{\partial D_{\rm pinned}} = 0.$ ~\newline
~\newline

\end{DoxyItemize}\hypertarget{index_contact_angle_term}{}\doxysubsection{\texorpdfstring{Computation of the contact-\/angle term in the variational principle}{Computation of the contact-angle term in the variational principle}}\label{index_contact_angle_term}
\href{../../young_laplace/html/index.html}{\texttt{ Recall}} that the variational principle that determines the shape of the meniscus contained the line term  \[
\delta \Pi_{\rm contact \ line} = 
\oint_{\partial D } {\bf T}_n \cdot \delta {\bf R} 
\left| \frac{\partial {\bf R}} {\partial \xi}\right| \ d\xi.
\] Along $ \partial D_{pinned} $ the line integral vanishes because $ \delta {\bf R}\big|_{ \partial D_{pinned} } ={\bf 0} $. The line integral can therefore be written as  \[
\delta \Pi_{\rm contact \ line} = 
\int_{\partial D_{\rm angle}} {\bf T}_n \cdot \delta {\bf R} 
\left| \frac{\partial {\bf R}}{\partial \xi}\right| \ d\xi,
\] or, using the spine-\/based representation of the meniscus, (2),  \[
\delta \Pi_{\rm contact\ line} = 
\int_{\partial D_{\rm angle}} {\bf T}_n \cdot  {\bf S} \ \delta u 
\left| \frac{\partial {\bf R}}{\partial \xi}\right| \ d\xi.
\]

We shall now demonstrate that the integrand in this expression can be expressed in terms of the contact angle boundary condition (1). We start with several observations\+:
\begin{DoxyEnumerate}
\item ${\bf T}_t$ is tangential to the wall. ~\newline
~\newline

\item Since ${\bf N}_{\rm wall}$ is normal to the wall, ${\bf T}_t \times {\bf N}_{\rm wall}$ is tangential to the wall and orthogonal to ${\bf T}_t$. ~\newline
~\newline

\item ${\bf S}$ is tangential to the wall and can therefore be decomposed into its components parallel to $ {\bf T}_t $ and ${\bf T}_t \times {\bf N}_{\rm wall} $ as  \[
   {\bf S} = \alpha {\bf T}_t + \beta ( {\bf T}_t \times {\bf N}_{\rm
   wall} )
   \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \   (3)
   \] for some values of $\alpha$ and $\beta$. In fact,  \[
   \beta = {\bf S}
   \cdot ( {\bf T}_t \times {\bf N}_{\rm wall} )
   \]
\item During the computation it is most convenient to perform all calculations in terms of quantities that are easily obtained from the parametrisation of the meniscus as this avoids having to specify ${\bf N}_{\rm wall}$ explicitly. For this purpose we exploit that ${\bf T}_t$ and ${\bf S}$ are tangential to the wall and not parallel to each other (unless the parametrisation of the meniscus by (2) is no longer one-\/to-\/one). Therefore ${\bf N}_{\rm wall}$ can be obtained from quantities that are intrinsic to the meniscus representation via ~\newline
~\newline
 \[
   {\bf N}_{\rm wall} = \frac{ {\bf S} \times {\bf T}_t } 
   {|{\bf S} \times {\bf T}_t|}
   \] and thus  \[
   \beta = {\bf S}
   \cdot \left( {\bf T}_t \times  
   \frac{ {\bf S} \times {\bf T}_t } 
   {|{\bf S} \times {\bf T}_t|} \right)
   \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4)
   \]
\item Given (3) and the fact that ${\bf T}_t \cdot {\bf
   T}_n =0$, we have ~\newline
~\newline
 \[
   {\bf S} \cdot {\bf T}_n =  \beta ( {\bf T}_t \times {\bf N}_{\rm wall}
   ) \cdot {\bf T}_n
   \] and with (1)\+:  \[
   {\bf S} \cdot {\bf T}_n =  \beta \cos \gamma.
   \] Hence, the line integral may be written as  \[
   \delta \Pi_{\rm contact\ line} = 
   \int_{\partial D_{\rm angle}} \beta \cos \gamma \ \delta u 
   \left| \frac{\partial {\bf R}}{\partial \xi}\right| \ d\xi,
   \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5)
   \] where $ \beta $ is given by (4).
\end{DoxyEnumerate}Equation (5) is easily discretised by finite elements. Within {\ttfamily oomph-\/lib}, the line integral is decomposed into {\ttfamily Face\+Elements} that are attached to the "{}bulk"{} Young-\/\+Laplace elements that are adjacent to the contact line. The imposition of the contact angle boundary condition for the Young Laplace equation is therefore as easy as the application of Neumann boundary conditions for a Poisson equation, say.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_results}{}\doxysection{\texorpdfstring{Results}{Results}}\label{index_results}
The animation below illustrates the variation in the quasi-\/steady meniscus shape as the fluid enters the T-\/junction.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{t_junction_meniscus}
\doxyfigcaption{Animation of the meniscus shapes. }
\end{DoxyImage}


The computation was performed with full spatial adaptivity. The plot below illustrates how the automatic mesh adaptation has strongly refined the mesh towards the corners of the domain where the meniscus shape has a singularity. (The singularity develops because in the corners of the domain the contact angle boundary condition along the side walls is inconsistent with the $ 90^o $ contact angle enforced by the pinned boundary condition along the sharp edges.)

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{t_junction_meniscus_adapt}
\doxyfigcaption{Illustration of the adaptive mesh refinement. }
\end{DoxyImage}


Finally, here is a plot of the "{}load-\/displacement diagram"{}, i.\+e. a plot of the meniscus deflection as a function of its curvature (i.\+e. the applied pressure drop). The limit point indicates the maximum pressure that can be withstood by the static meniscus.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{t_junction_trace}
\doxyfigcaption{The load-\/displacement diagram for the meniscus. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_code}{}\doxysection{\texorpdfstring{The driver code}{The driver code}}\label{index_code}
The modifications to the driver code required to impose the contact angle boundary conditions are very similar to those used in other driver codes for problems with Neumann-\/type boundary conditions. We attach {\ttfamily Face\+Elements} to the appropriate faces of the "{}bulk"{} Young-\/\+Laplace elements detach/re-\/attach them before and after any spatial adaptation of the "{}bulk"{} mesh.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_namespace}{}\doxysubsection{\texorpdfstring{The global namespace}{The global namespace}}\label{index_namespace}
The namespace that defines the problem parameters is very similar to that used in the \href{../../young_laplace/html/index.html}{\texttt{ previous example}} without contact angle boundary conditions. We provide storage for the cosine of the contact angle, and the prescribed meniscus height that is used by the displacement control method.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//======start\_of\_namespace========================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Namespace\ for\ "{}global"{}\ problem\ parameters}}
\DoxyCodeLine{\textcolor{comment}{//================================================================}}
\DoxyCodeLine{\textcolor{keyword}{namespace\ }\mbox{\hyperlink{namespaceGlobalParameters}{GlobalParameters}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Cos\ of\ contact\ angle\ }}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{double}\ \mbox{\hyperlink{namespaceGlobalParameters_ae982fcb894e82c683d07d3c2fbbead3d}{Cos\_gamma}}=cos(MathematicalConstants::Pi/6.0);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Height\ control\ value\ for\ displacement\ control}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{double}\ \mbox{\hyperlink{namespaceGlobalParameters_a3731f24a02ce4f306d65a9a488f85c96}{Controlled\_height}}\ =\ 0.0;}

\end{DoxyCodeInclude}
 \href{../../young_laplace/html/index.html}{\texttt{ As before}}, we use the spine basis $ {\bf B}(\zeta_1,\zeta_2)=(\zeta_1,\zeta_2,0)^T, $ to establish a reference configuration in which the flat meniscus is located in the plane $ z=0 $ and occupies the domain $ (x,y) \in [0,L_x] \times [0,L_y]. $


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Length\ of\ domain}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{double}\ \mbox{\hyperlink{namespaceGlobalParameters_a36ebf514fdd1e78fff69907b39e25af6}{L\_x}}\ =\ 1.0;\ }
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Width\ of\ domain}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{double}\ \mbox{\hyperlink{namespaceGlobalParameters_ac8774b3418c4551091d64ec72c169b2e}{L\_y}}\ =\ 5.0;\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Spine\ basis}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Spine\ basis:\ The\ position\ vector\ to\ the\ basis\ of\ the\ spine}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ as\ a\ function\ of\ the\ two\ coordinates\ x\_1\ and\ x\_2,\ and\ its}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ derivatives\ w.r.t.\ to\ these\ coordinates.\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ dspine\_B[i][j]\ =\ d\ spine\_B[j]\ /\ dx\_i}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Spines\ start\ in\ the\ (x\_1,x\_2)\ plane\ at\ (x\_1,x\_2).}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{namespaceGlobalParameters_ac81daf87f8d3f075d9fd108427e70c4f}{spine\_base\_function}}(\textcolor{keyword}{const}\ Vector<double>\&\ x,\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Vector<double>\&\ spine\_B,\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Vector<\ Vector<double>\ >\&\ dspine\_B)}
\DoxyCodeLine{\ \{}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Bspines\ and\ derivatives\ }}
\DoxyCodeLine{\ \ spine\_B[0]\ \ \ \ \ =\ x[0];}
\DoxyCodeLine{\ \ spine\_B[1]\ \ \ \ \ =\ x[1];}
\DoxyCodeLine{\ \ spine\_B[2]\ \ \ \ \ =\ 0.0\ ;}
\DoxyCodeLine{\ \ dspine\_B[0][0]\ =\ 1.0\ ;}
\DoxyCodeLine{\ \ dspine\_B[1][0]\ =\ 0.0\ ;}
\DoxyCodeLine{\ \ dspine\_B[0][1]\ =\ 0.0\ ;\ }
\DoxyCodeLine{\ \ dspine\_B[1][1]\ =\ 1.0\ ;}
\DoxyCodeLine{\ \ dspine\_B[0][2]\ =\ 0.0\ ;}
\DoxyCodeLine{\ \ dspine\_B[1][2]\ =\ 0.0\ ;}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \}\ \textcolor{comment}{//\ End\ of\ bspine\ functions}}

\end{DoxyCodeInclude}


As in the \href{../../young_laplace/html/index.html}{\texttt{ previous example}}, we rotate the spines in the $ y $ -\/direction to allow the representation of meniscus shapes that cannot be projected onto the $ (x,y) $ -\/plane.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Spines\ rotate\ in\ the\ y-\/direction}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Min.\ spine\ angle\ against\ horizontal\ plane}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{double}\ \mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}}\ =\ MathematicalConstants::Pi/2.0*1.5;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Max.\ spine\ angle\ against\ horizontal\ plane}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{double}\ \mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}\ =\ MathematicalConstants::Pi/2.0*0.5;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Spine:\ The\ spine\ vector\ field\ as\ a\ function\ of\ the\ two\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ coordinates\ x\_1\ and\ x\_2,\ and\ its\ derivatives\ w.r.t.\ to\ these\ coordinates:}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ dspine[i][j]\ =\ d\ spine[j]\ /\ dx\_i}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{namespaceGlobalParameters_a82df8c67f58e78a236fb6a0cc8bf8284}{spine\_function}}(\textcolor{keyword}{const}\ Vector<double>\&\ x,\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Vector<double>\&\ spine,\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Vector<\ Vector<double>\ >\&\ dspine)}
\DoxyCodeLine{\ \{}
\DoxyCodeLine{\ \ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ \ ///\ Spines\ (and\ derivatives)\ \ are\ independent\ of\ x[0]\ and\ rotate\ }}
\DoxyCodeLine{\textcolor{comment}{\ \ ///\ in\ the\ x[1]-\/direction}}
\DoxyCodeLine{\textcolor{comment}{}\ \ spine[0]=0.0;}
\DoxyCodeLine{\ \ dspine[0][0]=0.0;\ }
\DoxyCodeLine{\ \ dspine[1][0]=0.0;\ }
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ spine[1]=cos(Alpha\_min+(Alpha\_max-\/Alpha\_min)*x[1]/L\_y);\ }
\DoxyCodeLine{\ \ dspine[0][1]=0.0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ dspine[1][1]=-\/sin(Alpha\_min+(Alpha\_max-\/Alpha\_min)*x[1]/L\_y)}
\DoxyCodeLine{\ \ \ *(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}})/L\_y;\ \ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ spine[2]=sin(Alpha\_min+(Alpha\_max-\/Alpha\_min)*x[1]/L\_y);}
\DoxyCodeLine{\ \ dspine[0][2]=0.0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ dspine[1][2]=cos(Alpha\_min+(Alpha\_max-\/Alpha\_min)*x[1]/L\_y)\ }
\DoxyCodeLine{\ \ \ *(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}})/L\_y;\ \ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \}\ \textcolor{comment}{//\ End\ spine\ function}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ namespace}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysubsection{\texorpdfstring{The driver code}{The driver code}}\label{index_main}
We start by defining the output directory and open a trace file to record the load-\/displacement curve.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===============start\_of\_main============================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Drive\ code}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{barrel_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ label\ for\ output}}
\DoxyCodeLine{\ DocInfo\ doc\_info;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Trace\ file}}
\DoxyCodeLine{\ ofstream\ trace\_file;}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ output\ directory}}
\DoxyCodeLine{\ doc\_info.set\_directory(\textcolor{stringliteral}{"{}RESLT"{}});}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Open\ a\ trace\ file}}
\DoxyCodeLine{\ \textcolor{keywordtype}{char}\ filename[100];}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/trace.dat"{}},doc\_info.directory().c\_str());}
\DoxyCodeLine{\ trace\_file.open(filename);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Tecplot\ header\ for\ trace\ file:\ kappa\ and\ height\ value}}
\DoxyCodeLine{\ trace\_file\ <<\ \textcolor{stringliteral}{"{}VARIABLES=\(\backslash\)"{}<GREEK>k</GREEK>\(\backslash\)"{},\(\backslash\)"{}h\(\backslash\)"{}"{}}\ <<\ std::endl;}
\DoxyCodeLine{\ trace\_file\ <<\ \textcolor{stringliteral}{"{}ZONE"{}}\ <<\ std::endl;}

\end{DoxyCodeInclude}


Next, we create the problem object, refine the mesh uniformly and output the initial guess for the solution\+: a flat interface which, unlike the \href{../../young_laplace/html/index.html}{\texttt{ previous case}}, is not a solution of the problem because it does not satisfy the contact-\/angle boundary condition; see the section \doxysectlink{index_comm_ex}{Comments and Exercises}{1} for a more detailed discussion of this issue.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Set\ up\ the\ problem}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ the\ problem\ with\ 2D\ nine-\/node\ elements\ from\ the}}
\DoxyCodeLine{\ \textcolor{comment}{//\ RefineableQYoungLaplaceElement\ family.\ }}
\DoxyCodeLine{\ \mbox{\hyperlink{classRefineableYoungLaplaceProblem}{RefineableYoungLaplaceProblem<RefineableQYoungLaplaceElement<3>}}\ >\ problem;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Perform\ one\ uniform\ refinement}}
\DoxyCodeLine{\ problem.refine\_uniformly();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Output\ the\ solution}}
\DoxyCodeLine{\ problem.\mbox{\hyperlink{classRefineableYoungLaplaceProblem_a4ec7313c8e4015b0c2af0bbef789e70f}{doc\_solution}}(doc\_info,trace\_file);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Increment\ counter\ for\ solutions\ }}
\DoxyCodeLine{\ doc\_info.number()++;}

\end{DoxyCodeInclude}
 Finally, we perform a parameter study by slowly incrementing the control displacement and recomputing the meniscus shape.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Parameter\ incrementation}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/\ }}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ increment=0.1;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Loop\ over\ steps}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ nstep=2;\ \textcolor{comment}{//\ 10;}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ istep=0;istep<nstep;istep++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{namespaceGlobalParameters_a3731f24a02ce4f306d65a9a488f85c96}{GlobalParameters::Controlled\_height}}+=increment;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Solve\ the\ problem\ \ }}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{unsigned}\ max\_adapt=1;}
\DoxyCodeLine{\ \ \ problem.newton\_solve(max\_adapt);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Output\ the\ solution}}
\DoxyCodeLine{\ \ \ problem.\mbox{\hyperlink{classRefineableYoungLaplaceProblem_a4ec7313c8e4015b0c2af0bbef789e70f}{doc\_solution}}(doc\_info,trace\_file);}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Increment\ counter\ for\ solutions\ }}
\DoxyCodeLine{\ \ \ doc\_info.number()++;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Close\ output\ file}}
\DoxyCodeLine{\ trace\_file.close();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\}\ \textcolor{comment}{//end\ of\ main}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_class}{}\doxysubsection{\texorpdfstring{The problem class}{The problem class}}\label{index_class}
The problem class contains the usual member functions. The functions {\ttfamily actions\+\_\+before\+\_\+adapt()} and {\ttfamily actions\+\_\+after\+\_\+adapt()} are used to detach and re-\/attach (and rebuild) the contact angle elements on the appropriate boundaries of the "{}bulk"{} mesh.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//======\ start\_of\_problem\_class=======================================}}
\DoxyCodeLine{\textcolor{comment}{///\ 2D\ RefineableYoungLaplace\ problem\ on\ rectangular\ domain,\ discretised\ with}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ 2D\ QRefineableYoungLaplace\ elements.\ The\ specific\ type\ of\ element\ is}}
\DoxyCodeLine{\textcolor{comment}{///\ specified\ via\ the\ template\ parameter.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>\ }
\DoxyCodeLine{\textcolor{keyword}{class\ }\mbox{\hyperlink{classRefineableYoungLaplaceProblem}{RefineableYoungLaplaceProblem}}\ :\ \textcolor{keyword}{public}\ Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Constructor:\ }}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a78f77a299f2770a82378fcccf86a0b71}{RefineableYoungLaplaceProblem}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Destructor\ (empty)}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a24b45d5ecdd1d7dbb678e7f74777bf41}{\string~RefineableYoungLaplaceProblem}}()\{\};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ the\ problem\ specs\ before\ solve:\ Empty}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a2807bb8cddbfa553df9f5dd170c8645d}{actions\_before\_newton\_solve}}()\{\};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ the\ problem\ after\ solve:\ Empty}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a0791c90a16016372e09faf3f5721ecbe}{actions\_after\_newton\_solve}}()\{\};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Actions\ before\ adapt:\ Wipe\ the\ mesh\ of\ contact\ angle\ elements}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_ab64eb0b58beb3bb096ecc81b1a3f8a4f}{actions\_before\_adapt}}()}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Kill\ the\ contact\ angle\ elements\ and\ wipe\ contact\ angle\ mesh}}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{if}\ (\mbox{\hyperlink{classRefineableYoungLaplaceProblem_a36f5dc0f7071ac15fd63c7c477f77fb0}{Contact\_angle\_mesh\_pt}}!=0)\ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_aaa270ba8da395897a5a99d052f076e0c}{delete\_contact\_angle\_elements}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Rebuild\ the\ Problem's\ global\ mesh\ from\ its\ various\ sub-\/meshes}}
\DoxyCodeLine{\ \ \ rebuild\_global\_mesh();}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ \ Actions\ after\ adapt:\ Rebuild\ the\ mesh\ of\ contact\ angle\ elements}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_aa2eab8da1b83091df804ede7c60fac87}{actions\_after\_adapt}}()}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a00d1304e030120e76d9f316dd4053116}{create\_contact\_angle\_elements}}(1);}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a00d1304e030120e76d9f316dd4053116}{create\_contact\_angle\_elements}}(3);}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Set\ function\ pointers\ for\ contact-\/angle\ elements}}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{unsigned}\ nel=\mbox{\hyperlink{classRefineableYoungLaplaceProblem_a36f5dc0f7071ac15fd63c7c477f77fb0}{Contact\_angle\_mesh\_pt}}-\/>nelement();}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ e=0;e<nel;e++)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ Upcast\ from\ GeneralisedElement\ to\ YoungLaplace\ contact\ angle}}
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ element}}
\DoxyCodeLine{\ \ \ \ \ YoungLaplaceContactAngleElement<ELEMENT>\ *el\_pt\ =\ }
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{dynamic\_cast<}YoungLaplaceContactAngleElement<ELEMENT>*\textcolor{keyword}{>}(}
\DoxyCodeLine{\ \ \ \ \ \ \ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a36f5dc0f7071ac15fd63c7c477f77fb0}{Contact\_angle\_mesh\_pt}}-\/>element\_pt(e));}
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ Set\ the\ pointer\ to\ the\ prescribed\ contact\ angle}}
\DoxyCodeLine{\ \ \ \ \ el\_pt-\/>prescribed\_cos\_gamma\_pt()\ =\ \&\mbox{\hyperlink{namespaceGlobalParameters_ae982fcb894e82c683d07d3c2fbbead3d}{GlobalParameters::Cos\_gamma}};}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Rebuild\ the\ Problem's\ global\ mesh\ from\ its\ various\ sub-\/meshes}}
\DoxyCodeLine{\ \ \ rebuild\_global\_mesh();}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Doc\ the\ solution.\ DocInfo\ object\ stores\ flags/labels\ for\ where\ the}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ output\ gets\ written\ to\ and\ the\ trace\ file}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a4ec7313c8e4015b0c2af0bbef789e70f}{doc\_solution}}(DocInfo\&\ doc\_info,\ ofstream\&\ trace\_file);}

\end{DoxyCodeInclude}


Two private helper functions are provided to create and delete the contact angle elements. The class also provides storage for the pointers to the various meshes, to the node at which the meniscus displacement is prescribed by the displacement control method, and to the {\ttfamily Data} object whose one-\/and-\/only value stores the (unknown) meniscus curvature.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Create\ YoungLaplace\ contact\ angle\ elements\ on\ the\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ b-\/th\ boundary\ of\ the\ bulk\ mesh\ and\ add\ them\ to\ contact\ angle\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ create\_contact\_angle\_elements(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ b);}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Delete\ contact\ angle\ elements\ }}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ delete\_contact\_angle\_elements();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ the\ "{}bulk"{}\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ RefineableRectangularQuadMesh<ELEMENT>*\ Bulk\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ the\ contact\ angle\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ Mesh*\ Contact\_angle\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ mesh\ containing\ the\ height\ control\ element}}
\DoxyCodeLine{\textcolor{comment}{}\ Mesh*\ Height\_control\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Node\ at\ which\ the\ height\ (displacement\ along\ spine)\ is\ controlled/doced}}
\DoxyCodeLine{\textcolor{comment}{}\ Node*\ Control\_node\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ Data\ object\ that\ stores\ the\ prescribed\ curvature}}
\DoxyCodeLine{\textcolor{comment}{}\ Data*\ \mbox{\hyperlink{namespaceGlobalParameters_ac6234184cce40ab2c6bec92b37e4ae41}{Kappa\_pt}};}
\DoxyCodeLine{}
\DoxyCodeLine{\};\ \textcolor{comment}{//\ end\ of\ problem\ class}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constr}{}\doxysubsection{\texorpdfstring{The problem constructor}{The problem constructor}}\label{index_constr}
We start by creating the "{}bulk"{} mesh of refineable Young Laplace elements and specify the error estimator.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====start\_of\_constructor===============================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Constructor\ for\ RefineableYoungLaplace\ problem}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classRefineableYoungLaplaceProblem_a78f77a299f2770a82378fcccf86a0b71}{RefineableYoungLaplaceProblem<ELEMENT>::RefineableYoungLaplaceProblem}}()}
\DoxyCodeLine{\{\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Setup\ bulk\ mesh}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ \#\ of\ elements\ in\ x-\/direction}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_x=8;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ \#\ of\ elements\ in\ y-\/direction}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_y=8;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Domain\ length\ in\ x-\/direction}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ l\_x=\mbox{\hyperlink{namespaceGlobalParameters_a36ebf514fdd1e78fff69907b39e25af6}{GlobalParameters::L\_x}};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Domain\ length\ in\ y-\/direction}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ l\_y=\mbox{\hyperlink{namespaceGlobalParameters_ac8774b3418c4551091d64ec72c169b2e}{GlobalParameters::L\_y}};}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Build\ and\ assign\ mesh}}
\DoxyCodeLine{\ Bulk\_mesh\_pt=\textcolor{keyword}{new}\ RefineableRectangularQuadMesh<ELEMENT>(n\_x,n\_y,l\_x,l\_y);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create/set\ error\ estimator}}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>spatial\_error\_estimator\_pt()=\textcolor{keyword}{new}\ Z2ErrorEstimator;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ targets\ for\ spatial\ adaptivity}}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>max\_permitted\_error()=1.0e-\/4;}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>min\_permitted\_error()=1.0e-\/6;}

\end{DoxyCodeInclude}
 We identify the node (in the centre of the mesh) at which we apply displacement control. We pass a pointer to this node to the constructor of the displacement control element and store that element in its own mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Check\ that\ we've\ got\ an\ even\ number\ of\ elements\ otherwise}}
\DoxyCodeLine{\ \textcolor{comment}{//\ out\ counting\ doesn't\ work...}}
\DoxyCodeLine{\ \textcolor{keywordflow}{if}\ ((n\_x\%2!=0)||(n\_y\%2!=0))}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ cout\ <<\ \textcolor{stringliteral}{"{}n\_x\ n\_y\ should\ be\ even"{}}\ <<\ endl;}
\DoxyCodeLine{\ \ \ abort();}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \textcolor{comment}{//\ \ This\ is\ the\ element\ that\ contains\ the\ central\ node:}}
\DoxyCodeLine{\ ELEMENT*\ prescribed\_height\_element\_pt=\ \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{\ \ Bulk\_mesh\_pt-\/>element\_pt(n\_y*n\_x/2+n\_x/2));}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ The\ central\ node\ is\ node\ 0\ in\ that\ element}}
\DoxyCodeLine{\ Control\_node\_pt=\ \textcolor{keyword}{static\_cast<}Node*\textcolor{keyword}{>}(prescribed\_height\_element\_pt-\/>node\_pt(0));}
\DoxyCodeLine{}
\DoxyCodeLine{\ std::cout\ <<\ \textcolor{stringliteral}{"{}Controlling\ height\ at\ (x,y)\ :\ ("{}}\ <<\ Control\_node\_pt-\/>x(0)\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{},"{}}\ <<\ Control\_node\_pt-\/>x(1)\ \ <<\ \textcolor{stringliteral}{"{})"{}}\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n"{}}\ <<\ endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ a\ height\ control\ element\ and\ store\ the}}
\DoxyCodeLine{\ \textcolor{comment}{//\ pointer\ to\ the\ Kappa\ Data\ created\ by\ this\ object}}
\DoxyCodeLine{\ HeightControlElement*\ height\_control\_element\_pt=\textcolor{keyword}{new}\ HeightControlElement(}
\DoxyCodeLine{\ \ Control\_node\_pt,\&\mbox{\hyperlink{namespaceGlobalParameters_a3731f24a02ce4f306d65a9a488f85c96}{GlobalParameters::Controlled\_height}});}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Add\ to\ mesh}}
\DoxyCodeLine{\ Height\_control\_mesh\_pt\ =\ \textcolor{keyword}{new}\ Mesh;}
\DoxyCodeLine{\ Height\_control\_mesh\_pt-\/>add\_element\_pt(height\_control\_element\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Store\ curvature\ data}}
\DoxyCodeLine{\ \mbox{\hyperlink{namespaceGlobalParameters_ac6234184cce40ab2c6bec92b37e4ae41}{Kappa\_pt}}=height\_control\_element\_pt-\/>kappa\_pt();}

\end{DoxyCodeInclude}
 Next we create the mesh that stores the contact-\/angle elements. We attach these elements to boundaries 1 and 3 of the "{}bulk"{} mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Contact\ angle\ elements}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ prescribed-\/contact-\/angle\ elements\ from\ all\ elements\ that\ are\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ adjacent\ to\ boundary\ 1\ and\ 3\ and\ add\ them\ to\ their\ own\ mesh}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ set\ up\ new\ mesh}}
\DoxyCodeLine{\ Contact\_angle\_mesh\_pt=\textcolor{keyword}{new}\ Mesh;}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ creation\ of\ contact\ angle\ elements}}
\DoxyCodeLine{\ create\_contact\_angle\_elements(1);}
\DoxyCodeLine{\ create\_contact\_angle\_elements(3);}

\end{DoxyCodeInclude}
 The various sub-\/meshes are now added to the problem and the global mesh is built.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Add\ various\ meshes\ and\ build\ the\ global\ mesh}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ add\_sub\_mesh(Bulk\_mesh\_pt);}
\DoxyCodeLine{\ add\_sub\_mesh(Height\_control\_mesh\_pt);}
\DoxyCodeLine{\ add\_sub\_mesh(Contact\_angle\_mesh\_pt);}
\DoxyCodeLine{\ build\_global\_mesh();}

\end{DoxyCodeInclude}
 As usual, we enforce only the essential boundary conditions directly by pinning the meniscus displacement along mesh boundaries 0 and 2\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Boundary\ conditions}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ the\ boundary\ conditions\ for\ this\ problem:\ All\ nodes\ are}}
\DoxyCodeLine{\ \textcolor{comment}{//\ free\ by\ default\ -\/-\/\ only\ need\ to\ pin\ the\ ones\ that\ have\ Dirichlet\ conditions}}
\DoxyCodeLine{\ \textcolor{comment}{//\ here.\ }}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_bound\ =\ Bulk\_mesh\_pt-\/>nboundary();\ }
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ b=0;b<n\_bound;b++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Pin\ all\ boundaries\ for\ three\ cases\ and\ only\ boundaries}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ 0\ and\ 2\ in\ all\ others:}}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{if}\ ((b==0)||(b==2))}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \textcolor{keywordtype}{unsigned}\ n\_node\ =\ Bulk\_mesh\_pt-\/>nboundary\_node(b);}
\DoxyCodeLine{\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ n=0;n<n\_node;n++)}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ Bulk\_mesh\_pt-\/>boundary\_node\_pt(b,n)-\/>pin(0);\ }
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}\ \textcolor{comment}{//\ end\ bcs}}

\end{DoxyCodeInclude}
 The build of the "{}bulk"{} Young Laplace elements is completed by specifying the function pointers to the spine functions and the pointer to the {\ttfamily Data} object that stores the curvature.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Complete\ build\ of\ elements}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Complete\ the\ build\ of\ all\ elements\ so\ they\ are\ fully\ functional\ }}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_bulk=Bulk\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ i=0;i<n\_bulk;i++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Upcast\ from\ GeneralsedElement\ to\ the\ present\ element}}
\DoxyCodeLine{\ \ \ ELEMENT\ *el\_pt\ =\ \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt-\/>element\_pt(i));}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Set\ the\ spine\ function\ pointers}}
\DoxyCodeLine{\ \ \ el\_pt-\/>spine\_base\_fct\_pt()\ =\ \mbox{\hyperlink{namespaceGlobalParameters_ac81daf87f8d3f075d9fd108427e70c4f}{GlobalParameters::spine\_base\_function}};}
\DoxyCodeLine{\ \ \ el\_pt-\/>spine\_fct\_pt()\ =\ \ \mbox{\hyperlink{namespaceGlobalParameters_a82df8c67f58e78a236fb6a0cc8bf8284}{GlobalParameters::spine\_function}};}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Set\ the\ curvature\ data\ for\ the\ element}}
\DoxyCodeLine{\ \ \ el\_pt-\/>set\_kappa(Kappa\_pt);\ }
\DoxyCodeLine{\ \ \}}

\end{DoxyCodeInclude}
 Finally, we complete the build of the contact line elements by passing the pointer to the double that stores the cosine of the contact angle.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ function\ pointers\ for\ contact-\/angle\ elements}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ nel=Contact\_angle\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ e=0;e<nel;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Upcast\ from\ GeneralisedElement\ to\ YoungLaplace\ contact\ angle\ }}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ element}}
\DoxyCodeLine{\ \ \ YoungLaplaceContactAngleElement<ELEMENT>\ *el\_pt\ =\ }
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{dynamic\_cast<}YoungLaplaceContactAngleElement<ELEMENT>*\textcolor{keyword}{>}(}
\DoxyCodeLine{\ \ \ \ \ Contact\_angle\_mesh\_pt-\/>element\_pt(e));}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Set\ the\ pointer\ to\ the\ prescribed\ contact\ angle}}
\DoxyCodeLine{\ \ \ el\_pt-\/>prescribed\_cos\_gamma\_pt()\ =\ \&\mbox{\hyperlink{namespaceGlobalParameters_ae982fcb894e82c683d07d3c2fbbead3d}{GlobalParameters::Cos\_gamma}};}
\DoxyCodeLine{\ \ \}}

\end{DoxyCodeInclude}
 All that\textquotesingle{}s now left to do is to assign the equation numbers\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Setup\ equation\ numbering\ scheme}}
\DoxyCodeLine{\ cout\ <<\textcolor{stringliteral}{"{}\(\backslash\)nNumber\ of\ equations:\ "{}}\ <<\ assign\_eqn\_numbers()\ <<\ endl;\ }
\DoxyCodeLine{\ cout\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n********************************************\(\backslash\)n"{}}\ <<\ \ endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ constructor}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_create}{}\doxysubsection{\texorpdfstring{Creating the contact angle elements}{Creating the contact angle elements}}\label{index_create}
The function {\ttfamily create\+\_\+contact\+\_\+angle\+\_\+elements()} attaches the {\ttfamily Face\+Elements} that apply the contact angle boundary condition to the specified boundary of the "{}bulk"{} mesh. Pointers to the newly-\/created {\ttfamily Face\+Elements} are stored in a separate mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_create\_contact\_angle\_elements=====================}}
\DoxyCodeLine{\textcolor{comment}{///\ Create\ YoungLaplace\ contact\ angle\ elements\ on\ the\ b-\/th\ boundary\ of\ the\ }\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ bulk\ mesh\ and\ add\ them\ to\ the\ contact\ angle\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//=======================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a00d1304e030120e76d9f316dd4053116}{RefineableYoungLaplaceProblem<ELEMENT>::create\_contact\_angle\_elements}}(}
\DoxyCodeLine{\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \&b)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ How\ many\ bulk\ elements\ are\ adjacent\ to\ boundary\ b?}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_element\ =\ Bulk\_mesh\_pt-\/>nboundary\_element(b);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Loop\ over\ the\ bulk\ elements\ adjacent\ to\ boundary\ b?}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ e=0;e<n\_element;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Get\ pointer\ to\ the\ bulk\ element\ that\ is\ adjacent\ to\ boundary\ b}}
\DoxyCodeLine{\ \ \ ELEMENT*\ bulk\_elem\_pt\ =\ \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{\ \ \ \ Bulk\_mesh\_pt-\/>boundary\_element\_pt(b,e));}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ What\ is\ the\ index\ of\ the\ face\ of\ the\ bulk\ element\ at\ the\ boundary}}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{int}\ face\_index\ =\ Bulk\_mesh\_pt-\/>face\_index\_at\_boundary(b,e);}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Build\ the\ corresponding\ contact\ angle\ element}}
\DoxyCodeLine{\ \ \ YoungLaplaceContactAngleElement<ELEMENT>*\ contact\_angle\_element\_pt\ =\ \textcolor{keyword}{new}\ }
\DoxyCodeLine{\ \ \ YoungLaplaceContactAngleElement<ELEMENT>(bulk\_elem\_pt,face\_index);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Add\ the\ contact\ angle\ element\ to\ the\ contact\ angle\ mesh}}
\DoxyCodeLine{\ \ \ Contact\_angle\_mesh\_pt-\/>add\_element\_pt(contact\_angle\_element\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \}\ \textcolor{comment}{//end\ of\ loop\ over\ bulk\ elements\ adjacent\ to\ boundary\ b}}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ create\_contact\_angle\_elements}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_delete}{}\doxysubsection{\texorpdfstring{Deleting the contact angle elements}{Deleting the contact angle elements}}\label{index_delete}
The function {\ttfamily delete\+\_\+contact\+\_\+angle\+\_\+elements()} deletes the contact angle elements and flushes the associated mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_delete\_contact\_angle\_elements=====================}}
\DoxyCodeLine{\textcolor{comment}{///\ Delete\ YoungLaplace\ contact\ angle\ elements}}
\DoxyCodeLine{\textcolor{comment}{//=======================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_aaa270ba8da395897a5a99d052f076e0c}{RefineableYoungLaplaceProblem<ELEMENT>::delete\_contact\_angle\_elements}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ How\ many\ contact\ angle\ elements\ are\ there?}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_element\ =\ Contact\_angle\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Loop\ over\ the\ surface\ elements}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ e=0;e<n\_element;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Kill\ surface\ element}}
\DoxyCodeLine{\ \ \ \textcolor{keyword}{delete}\ Contact\_angle\_mesh\_pt-\/>element\_pt(e);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Wipe\ the\ mesh}}
\DoxyCodeLine{\ Contact\_angle\_mesh\_pt-\/>flush\_element\_and\_node\_storage();}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ delete\_contact\_angle\_elements}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_doc}{}\doxysubsection{\texorpdfstring{Post-\/processing}{Post-processing}}\label{index_doc}
We output the load-\/displacement data, the meniscus shape, and various contact line quantities.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===============start\_of\_doc=============================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Doc\ the\ solution:\ doc\_info\ contains\ labels/output\ directory\ etc.}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a4ec7313c8e4015b0c2af0bbef789e70f}{RefineableYoungLaplaceProblem<ELEMENT>::doc\_solution}}(DocInfo\&\ doc\_info,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ofstream\&\ trace\_file)}
\DoxyCodeLine{\{\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Output\ kappa\ vs\ height}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ trace\_file\ <<\ -\/1.0*\mbox{\hyperlink{namespaceGlobalParameters_ac6234184cce40ab2c6bec92b37e4ae41}{Kappa\_pt}}-\/>value(0)\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{\ trace\_file\ <<\ Control\_node\_pt-\/>value(0)\ ;}
\DoxyCodeLine{\ trace\_file\ <<\ endl;}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Number\ of\ plot\ points:\ npts\ x\ npts}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ npts=5;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Output\ full\ solution\ }}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ ofstream\ some\_file;}
\DoxyCodeLine{\ \textcolor{keywordtype}{char}\ filename[100];}
\DoxyCodeLine{\ \textcolor{comment}{//YoungLaplaceEquations::Output\_meniscus\_and\_spines=false;}}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/soln\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.number());}
\DoxyCodeLine{\ some\_file.open(filename);}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>output(some\_file,npts);}
\DoxyCodeLine{\ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Output\ contact\ angle\ }}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ ofstream\ tangent\_file;}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/tangent\_to\_contact\_line\%i.dat"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.number());}
\DoxyCodeLine{\ tangent\_file.open(filename);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ ofstream\ normal\_file;}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/normal\_to\_contact\_line\%i.dat"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.number());}
\DoxyCodeLine{\ normal\_file.open(filename);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ }
\DoxyCodeLine{\ ofstream\ contact\_angle\_file;}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/contact\_angle\%i.dat"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.number());}
\DoxyCodeLine{\ contact\_angle\_file.open(filename);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Tangent\ and\ normal\ vectors\ to\ contact\ line}}
\DoxyCodeLine{\ Vector<double>\ tangent(3);}
\DoxyCodeLine{\ Vector<double>\ normal(3);}
\DoxyCodeLine{\ Vector<double>\ r\_contact(3);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ How\ many\ contact\ angle\ elements\ are\ there?}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_element\ =\ Contact\_angle\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Loop\ over\ the\ surface\ elements}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ e=0;e<n\_element;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ tangent\_file\ <<\ \textcolor{stringliteral}{"{}ZONE"{}}\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ normal\_file\ <<\ \textcolor{stringliteral}{"{}ZONE"{}}\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ contact\_angle\_file\ <<\ \textcolor{stringliteral}{"{}ZONE"{}}\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Upcast\ from\ GeneralisedElement\ to\ YoungLaplace\ contact\ angle\ element}}
\DoxyCodeLine{\ \ \ YoungLaplaceContactAngleElement<ELEMENT>*\ el\_pt\ =\ }
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{dynamic\_cast<}YoungLaplaceContactAngleElement<ELEMENT>*\textcolor{keyword}{>}(}
\DoxyCodeLine{\ \ \ \ \ Contact\_angle\_mesh\_pt-\/>element\_pt(e));}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Loop\ over\ a\ few\ points\ in\ the\ contact\ angle\ element}}
\DoxyCodeLine{\ \ \ Vector<double>\ s(1);}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ i=0;i<npts;i++)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ s[0]=-\/1.0+2.0*double(i)/double(npts-\/1);}
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(el\_pt-\/>bulk\_element\_pt())-\/>}
\DoxyCodeLine{\ \ \ \ \ \ position(el\_pt-\/>local\_coordinate\_in\_bulk(s),r\_contact);}
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ el\_pt-\/>contact\_line\_vectors(s,tangent,normal);}
\DoxyCodeLine{\ \ \ \ \ tangent\_file\ <<\ r\_contact[0]\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ r\_contact[1]\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ r\_contact[2]\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ tangent[0]\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ tangent[1]\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ tangent[2]\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ \ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ normal\_file\ <<\ r\_contact[0]\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ r\_contact[1]\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ r\_contact[2]\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ normal[0]\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ normal[1]\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ normal[2]\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ \ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ contact\_angle\_file\ <<\ r\_contact[1]\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ el\_pt-\/>actual\_cos\_contact\_angle(s)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \}\ \textcolor{comment}{//\ end\ of\ loop\ over\ both\ boundaries}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ tangent\_file.close();}
\DoxyCodeLine{\ normal\_file.close();}
\DoxyCodeLine{\ contact\_angle\_file.close();}
\DoxyCodeLine{\ }
\DoxyCodeLine{}
\DoxyCodeLine{cout\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n********************************************"{}}\ <<\ endl\ <<\ \ endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ doc}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comm_ex}{}\doxysection{\texorpdfstring{Comments and Exercises}{Comments and Exercises}}\label{index_comm_ex}
\hypertarget{index_ic}{}\doxysubsection{\texorpdfstring{How to generate a good initial guess for the solution}{How to generate a good initial guess for the solution}}\label{index_ic}
We already commented on the need to provide a "{}good"{} initial guess for the solution in order to ensure the convergence of the Newton iteration. In the \href{../../young_laplace/html/index.html}{\texttt{ previous example}} this was easy because the flat meniscus (clearly a solution of the Young-\/\+Laplace equations for zero curvature) also satisfied the boundary conditions. In the present example, and in many others, this is not the case. In such problems it may be difficult to generate initial guesses for the meniscus shape that are sufficiently close to actual solution.

In such cases it may be necessary to compute the initial solution to the problem whose behaviour we wish to investigate during the actual parameter study via a preliminary auxiliary continuation procedure that transforms an easier-\/solve-\/problem (for which a good initial guess can be found) into the actual problem.

Explore this approach in the present problem by implementing the following steps\+:
\begin{DoxyEnumerate}
\item Set the contact angle to $ 90^o $ and solve the problem, using the "{}flat"{} meniscus as the initial guess. The "{}flat"{} meniscus is, of course, the exact solution for zero control displacement and/or zero curvature. ~\newline
~\newline

\item Now start a preliminary continuation procedure in which the contact angle is adjusted in small steps until it reaches the desired value. Keep the prescribed control displacement (or the meniscus curvature) constant during this procedure. ~\newline
~\newline

\item The solution for the desired contact angle may now be used as the initial guess for the actual parameter study in which the control displacement (or the meniscus curvature) are increased while the contact angle is kept fixed.
\end{DoxyEnumerate}\hypertarget{index_lim}{}\doxysubsection{\texorpdfstring{Limitations of the current approach – suggestions for improvement}{Limitations of the current approach – suggestions for improvement}}\label{index_lim}
One of the main disadvantages of the approach adopted here is that the spine vector fields $ {\bf B} $ and $ {\bf S} $ must be specified {\itshape a priori}. For sufficiently complicated meniscus shapes (or for menisci that undergo large changes in shape as their curvature is varied) the choice of suitable spines may be very difficult. ~\newline
~\newline
One (possible) solution to this problem could be (we haven\textquotesingle{}t tried it!) to occasionally update the spine representation. For instance, assume that we have computed a meniscus shape in the form ~\newline
~\newline
 \[
\widehat{\bf R} = {\bf R}(\zeta_1,\zeta_2) = 
{\bf B}(\zeta_1,\zeta_2) +
u(\zeta_1,\zeta_2) \ {\bf S}(\zeta_1,\zeta_2)
\] with an associated normal vector $ \widehat{\bf N} $. We can reparametrise this shape by setting  \[
{\bf B} :=  \widehat{\bf R},
\]  \[
{\bf S} :=  \widehat{\bf N},
\] and ~\newline
  \[
u := 0
\] before continuing the computation. Provided this is done sufficiently frequently, i.\+e. long before the displacement along the spines has become so large that the mapping from $ (\zeta_1,\zeta_2) $ to $ {\bf R}(\zeta_1,\zeta_2)$ is about to become non-\/one-\/to-\/one, this should allow the computation of arbitrarily large meniscus deflections. Try it out and let us know how it works! ~\newline
~\newline
 \hypertarget{index_zero}{}\doxysubsection{\texorpdfstring{Zero contact angles}{Zero contact angles}}\label{index_zero}
Our problem formulation suffers from an additional, more fundamental problem\+: it cannot be used to solve problems with zero contact angle. This is because for zero contact angles the equilibrium solution is no longer a minimiser of the variational principle\+: given a solution at which the meniscus meets the wall at zero contact angle, it is always possible to extend the meniscus with an arbitrary-\/length "{}collar"{} along the wall without changing the overall energy of the system. As a result, the position of the contact line becomes increasingly ill-\/defined as the contact angle $ \gamma $ is reduced, causing the Newton method to converge very slowly (and ultimately not at all) as $ \gamma \to 0. $

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{\texorpdfstring{Source files for this tutorial}{Source files for this tutorial}}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/young_laplace/}{\texttt{ demo\+\_\+drivers/young\+\_\+laplace/ }} \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/young_laplace/refineable_t_junction.cc}{\texttt{ demo\+\_\+drivers/young\+\_\+laplace/refineable\+\_\+t\+\_\+junction.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{\texorpdfstring{PDF file}{PDF file}}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
