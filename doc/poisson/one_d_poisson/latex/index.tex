\chapter{Demo problem\+: A one-\/dimensional Poisson problem}
\hypertarget{index}{}\label{index}\index{Demo problem: A one-\/dimensional Poisson problem@{Demo problem: A one-\/dimensional Poisson problem}}
In this document, we demonstrate how a solve the 1D Poisson problem using existing objects from the {\ttfamily oomph-\/lib} library\+:

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{One-\/dimensional model Poisson problem}} \end{center}  Solve  \[
\frac{\mbox{d}^2u}{\mbox{d}x^2} = f(x),
 \ \ \ \ \ \ \ \ \ \ (1)
\] in a one-\/dimensional domain $ x\in[0,1] $, with boundary conditions  \[
u(0)=u_0 \ \mbox{\ \ \ and \ \ \ } \ \ u(1)=u_1, 
\ \ \ \ \ \ \ \ \ \ (2)
\] where $ u_0 $ and $ u_1 $ are given.   \\\cline{1-1}
\end{longtabu}
\end{center} 

We provide a detailed discussion of the driver code \href{../../../../demo_drivers/poisson/one_d_poisson/one_d_poisson.cc}{\texttt{ one\+\_\+d\+\_\+poisson.\+cc}} which solves the problem for the specific source function  \[
f(x) = \pm 30 \sin(\sqrt{30} x),  \ \ \ \  (3)
\] and boundary conditions  \[
u_0= 0; \ \ \  u_1 = \mp 1.
\] In this case, the problem has the (fish-\/shaped) exact solution  \[
u(x) = \pm \left[ \left(\sin(\sqrt{30})-1\right) x - \sin(\sqrt{30} x)\right].
\ \ \ \ \  (4)\]

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{one_d_fish}
\doxyfigcaption{The fish-\/shaped solution u(x). }
\end{DoxyImage}


\DoxyHorRuler{0}
 ~\newline
 \DoxyHorRuler{0}
\hypertarget{index_global}{}\doxysection{\texorpdfstring{Global parameters and functions}{Global parameters and functions}}\label{index_global}
Source functions and problem parameters generally need to be accessible to a variety of {\ttfamily oomph-\/lib} objects and we tend to define such functions/quantities in C++ namespaces. Here we use the namespace {\ttfamily \doxylink{namespaceFishSolnOneDPoisson}{Fish\+Soln\+One\+DPoisson}} to define the source function (3) and the exact solution (4). Both functions use the integer value \doxylink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{Fish\+Soln\+One\+DPoisson\+::\+Sign}, which can be set by the "{}user"{} in the driver code.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_namespace================================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Namespace\ for\ fish-\/shaped\ solution\ of\ 1D\ Poisson\ equation}}
\DoxyCodeLine{\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{namespace\ }\mbox{\hyperlink{namespaceFishSolnOneDPoisson}{FishSolnOneDPoisson}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Sign\ of\ the\ source\ function\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ (-\/\ gives\ the\ upper\ half\ of\ the\ fish,\ +\ the\ lower\ half)}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{int}\ \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{Sign}}=-\/1;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Exact,\ fish-\/shaped\ solution\ as\ a\ 1D\ vector}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a52c9346f567cb68fe20268a592deb4bc}{get\_exact\_u}}(\textcolor{keyword}{const}\ Vector<double>\&\ x,\ Vector<double>\&\ u)}
\DoxyCodeLine{\ \{}
\DoxyCodeLine{\ \ u[0]\ =\ double(\mbox{\hyperlink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{Sign}})*((sin(sqrt(30.0))-\/1.0)*x[0]-\/sin(sqrt(30.0)*x[0]));}
\DoxyCodeLine{\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Source\ function\ required\ to\ make\ the\ fish\ shape\ an\ exact\ solution\ }}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{namespaceFishSolnOneDPoisson_afd2f5aef6b8868526dbf8e74d379697f}{source\_function}}(\textcolor{keyword}{const}\ Vector<double>\&\ x,\ \textcolor{keywordtype}{double}\&\ source)}
\DoxyCodeLine{\ \{}
\DoxyCodeLine{\ \ source\ =\ double(\mbox{\hyperlink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{Sign}})*30.0*sin(sqrt(30.0)*x[0]);}
\DoxyCodeLine{\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ namespace}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysection{\texorpdfstring{The driver code}{The driver code}}\label{index_main}
In order to solve the Poisson problem with {\ttfamily oomph-\/lib}, we represent the mathematical problem defined by equations (1) and (2) in a specific {\ttfamily Problem} object, {\ttfamily \doxylink{classOneDPoissonProblem}{One\+DPoisson\+Problem}}. {\ttfamily oomph-\/lib} provides a variety of 1D Poisson elements (1D elements with linear, quadratic and cubic representations for the unknown function) and we pass the specific element type as a template parameter to the {\ttfamily Problem}. In the driver code, listed below, we use the {\ttfamily QPoisson\+Element$<$1,4$>$}, a four-\/node (cubic) 1D Poisson element. We pass the number of elements in the mesh as the first argument to the {\ttfamily Problem} constructor and the pointer to the source function, defined in the namespace {\ttfamily \doxylink{namespaceFishSolnOneDPoisson}{Fish\+Soln\+One\+DPoisson}}, as the second.

Once the problem has been created, we execute {\ttfamily Problem\+::self\+\_\+test()}, which checks that the {\ttfamily Problem} has been properly set up. If this test is passed, we proceed to solve the problem\+: Initially, we set the sign of the source function (defined in the variable {\ttfamily \doxylink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{Fish\+Soln\+One\+DPoisson\+::\+Sign}}) to -\/1 and solve, using {\ttfamily oomph-\/lib\textquotesingle{}s} Newton solver. We write the solution to output files, using the {\ttfamily \doxylink{classOneDPoissonProblem}{One\+DPoisson\+Problem}\textquotesingle{}s} member function {\ttfamily doc\+\_\+solution()}, discussed below. We then repeat the process, using a positive sign for the source function.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//======start\_of\_main==================================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Driver\ for\ 1D\ Poisson\ problem}}
\DoxyCodeLine{\textcolor{comment}{//=====================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{one__d__poisson_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ up\ the\ problem:\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ Solve\ a\ 1D\ Poisson\ problem\ using\ a\ source\ function\ that\ generates}}
\DoxyCodeLine{\ \textcolor{comment}{//\ a\ fish\ shaped\ exact\ solution}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_element=40;\ \textcolor{comment}{//Number\ of\ elements}}
\DoxyCodeLine{\ \mbox{\hyperlink{classOneDPoissonProblem}{OneDPoissonProblem<QPoissonElement<1,4>}}\ >\ \textcolor{comment}{//Element\ type\ as\ template\ parameter}}
\DoxyCodeLine{\ \ problem(n\_element,\mbox{\hyperlink{namespaceFishSolnOneDPoisson_afd2f5aef6b8868526dbf8e74d379697f}{FishSolnOneDPoisson::source\_function}});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Check\ whether\ the\ problem\ can\ be\ solved}}
\DoxyCodeLine{\ cout\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n\(\backslash\)nProblem\ self-\/test\ "{}};}
\DoxyCodeLine{\ \textcolor{keywordflow}{if}\ (problem.self\_test()==0)\ \ }
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ cout\ <<\ \textcolor{stringliteral}{"{}passed:\ Problem\ can\ be\ solved."{}}\ <<\ std::endl;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \textcolor{keywordflow}{else}\ }
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{throw}\ OomphLibError(\textcolor{stringliteral}{"{}failed!"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ OOMPH\_CURRENT\_FUNCTION,OOMPH\_EXCEPTION\_LOCATION);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ the\ sign\ of\ the\ source\ function:}}
\DoxyCodeLine{\ cout\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n\(\backslash\)nSolving\ with\ negative\ sign:\(\backslash\)n"{}}\ <<\ std::endl;}
\DoxyCodeLine{\ \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{FishSolnOneDPoisson::Sign}}=-\/1;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Solve\ the\ problem\ with\ this\ Sign}}
\DoxyCodeLine{\ problem.newton\_solve();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Output\ solution\ for\ this\ case\ (label\ output\ files\ with\ "{}0"{})}}
\DoxyCodeLine{\ problem.doc\_solution(0);}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Change\ the\ sign\ of\ the\ source\ function:}}
\DoxyCodeLine{\ cout\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n\(\backslash\)nSolving\ with\ positive\ sign:\(\backslash\)n"{}}\ <<\ std::endl;}
\DoxyCodeLine{\ \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{FishSolnOneDPoisson::Sign}}=1;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Re-\/solve\ the\ problem\ with\ this\ Sign\ (boundary\ conditions\ get}}
\DoxyCodeLine{\ \textcolor{comment}{//\ updated\ automatically\ when\ Problem::actions\_before\_newton\_solve()\ is}}
\DoxyCodeLine{\ \textcolor{comment}{//\ called.}}
\DoxyCodeLine{\ problem.newton\_solve();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Output\ solution\ for\ this\ case\ (label\ output\ files\ with\ "{}1"{})}}
\DoxyCodeLine{\ problem.doc\_solution(1);}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ main}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_problem}{}\doxysection{\texorpdfstring{The problem class}{The problem class}}\label{index_problem}
{\ttfamily oomph-\/lib} driver codes tend to be very compact and "{}high-\/level"{} because all the "{}hard work"{} is done in the {\ttfamily Problem} specification. For our simple Poisson problem, this step is completely straightforward\+:

The {\ttfamily \doxylink{classOneDPoissonProblem}{One\+DPoisson\+Problem}} is derived from {\ttfamily oomph-\/lib\textquotesingle{}s} generic {\ttfamily Problem} class and, as discussed above, the specific element type is specified as a template parameter to make it easy for the "{}user"{} to change the element type in the driver code.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_problem\_class============================================}}
\DoxyCodeLine{\textcolor{comment}{///\ 1D\ Poisson\ problem\ in\ unit\ interval.}}
\DoxyCodeLine{\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>\ }
\DoxyCodeLine{\textcolor{keyword}{class\ }\mbox{\hyperlink{classOneDPoissonProblem}{OneDPoissonProblem}}\ :\ \textcolor{keyword}{public}\ Problem}

\end{DoxyCodeInclude}
 The {\ttfamily One\+DPoisson\+Problemclass} has five member functions, only three of which are non-\/trivial\+:
\begin{DoxyItemize}
\item the constructor {\ttfamily \doxylink{classOneDPoissonProblem}{One\+DPoisson\+Problem(...)}} 
\item the function {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+solve()} 
\item the function {\ttfamily doc\+\_\+solution(...)} 
\end{DoxyItemize}The function {\ttfamily Problem\+::actions\+\_\+after\+\_\+newton\+\_\+solve()} is a pure virtual member function of the {\ttfamily Problem} base class and must be provided. However, it is not required in the present problem so we leave it empty. Similarly, the problem destructor can remain empty as all memory de-\/allocation is handled in the destructor of the {\ttfamily Problem} base class. The Problem only stores one private data member, the pointer to the source function.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Constructor:\ Pass\ number\ of\ elements\ and\ pointer\ to\ source\ function}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classOneDPoissonProblem}{OneDPoissonProblem}}(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ n\_element,\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ PoissonEquations<1>::PoissonSourceFctPt\ source\_fct\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Destructor\ (empty)}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classOneDPoissonProblem_a940fa32d7939788e27b708818fb046ec}{\string~OneDPoissonProblem}}()}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{keyword}{delete}\ mesh\_pt();}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ the\ problem\ specs\ before\ solve:\ (Re)set\ boundary\ conditions}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classOneDPoissonProblem_a6e42423869771fbd216326cba516a76b}{actions\_before\_newton\_solve}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ the\ problem\ specs\ after\ solve\ (empty)}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classOneDPoissonProblem_ab023d367cc68b77a7828536333c924ed}{actions\_after\_newton\_solve}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Doc\ the\ solution,\ pass\ the\ number\ of\ the\ case\ considered,}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ so\ that\ output\ files\ can\ be\ distinguished.}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classOneDPoissonProblem_aaf42d034e42e7615acfa262a9c56b638}{doc\_solution}}(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ label);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ source\ function}}
\DoxyCodeLine{\textcolor{comment}{}\ PoissonEquations<1>::PoissonSourceFctPt\ \mbox{\hyperlink{classOneDPoissonProblem_a5fdff4b9218f56dec7fbc282f2428eef}{Source\_fct\_pt}};}
\DoxyCodeLine{}
\DoxyCodeLine{\};\ \textcolor{comment}{//\ end\ of\ problem\ class}}

\end{DoxyCodeInclude}


\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center}{\bfseries{\label{index_gen_conv}%
\Hypertarget{index_gen_conv}%
A general convention}}\end{center}  The type {\ttfamily Poisson\+Equations$<$1$>$\+::\+Poisson\+Source\+Fct\+Pt}, used to define the type of the source function pointer, is a public typedef, defined in {\ttfamily oomph-\/lib\textquotesingle{}s} Poisson equation class, as follows\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[...]}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ \(\backslash\)short\ Function\ pointer\ to\ source\ function\ has\ the\ form\ fct(x,f(x)).\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Note\ that\ x\ is\ a\ Vector!\ }}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keyword}{typedef}\ void\ (*PoissonSourceFctPt)(\textcolor{keyword}{const}\ Vector<double>\&\ x,\ \textcolor{keywordtype}{double}\&\ f);}
\DoxyCodeLine{}
\DoxyCodeLine{[...]}

\end{DoxyCode}


This reflects a {\bfseries{general}} {\bfseries{convention}} in {\ttfamily oomph-\/lib}\+: The function types of source functions etc. that are required by specific elements, are always declared as public types in the element classes. The logic behind this is that only the element writer/maintainer knows what type of function (i.\+e. the type of its arguments and its return value) a specific element requires. For instance, the source function for the Poisson equation requires the spatial coordinate {\ttfamily x} as input and computes the (scalar) value of the source function. Since the syntax for C++ function pointers is somewhat "{}non-\/obvious"{} (that\textquotesingle{}s according to Bjarne Stroustrup, the designer of C++, himself!), we use typedefs to give the function pointers more intuitive names. Since the typedefs are public, they can be used anywhere in the "{}user\textquotesingle{}s"{} code.

While we\textquotesingle{}re at it, here\textquotesingle{}s {\bfseries{another}} {\bfseries{convention\+:}} If an {\ttfamily oomph-\/lib} function has input and output arguments in its argument list, the input arguments appear first (and are usually passed as constant references), while the output arguments appear last (and are passed as references).   \\\cline{1-1}
\end{longtabu}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysection{\texorpdfstring{The Problem constructor}{The Problem constructor}}\label{index_constructor}
In the {\ttfamily Problem} constructor, we define the domain length and build a {\ttfamily Mesh}, using {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily One\+DMesh} object which is templated by the element type. The required number of elements and the domain length are passed as arguments to the {\ttfamily One\+DMesh} constructors. The subsequent lines of code pin the nodal values at the two boundary nodes. Next we pass the source function pointer to the elements. Finally, we call the generic {\ttfamily Problem\+::assign\+\_\+eqn\+\_\+numbers()} routine which does precisely what it says...


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====start\_of\_constructor===============================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Constructor\ for\ 1D\ Poisson\ problem\ in\ unit\ interval.}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ Discretise\ the\ 1D\ domain\ with\ n\_element\ elements\ of\ type\ ELEMENT.}}
\DoxyCodeLine{\textcolor{comment}{///\ Specify\ function\ pointer\ to\ source\ function.\ }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classOneDPoissonProblem_ab814af5dfd3b7ae665cd20e27da5d9ae}{OneDPoissonProblem<ELEMENT>::OneDPoissonProblem}}(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ n\_element,}
\DoxyCodeLine{\ PoissonEquations<1>::PoissonSourceFctPt\ source\_fct\_pt)\ :\ }
\DoxyCodeLine{\ \mbox{\hyperlink{classOneDPoissonProblem_a5fdff4b9218f56dec7fbc282f2428eef}{Source\_fct\_pt}}(source\_fct\_pt)}
\DoxyCodeLine{\{\ }
\DoxyCodeLine{\ Problem::Sparse\_assembly\_method\ =\ Perform\_assembly\_using\_two\_arrays;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Problem::Problem\_is\_nonlinear\ =\ false;}}
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ domain\ length\ }}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ L=1.0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Build\ mesh\ and\ store\ pointer\ in\ Problem}}
\DoxyCodeLine{\ Problem::mesh\_pt()\ =\ \textcolor{keyword}{new}\ OneDMesh<ELEMENT>(n\_element,L);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ the\ boundary\ conditions\ for\ this\ problem:\ By\ default,\ all\ nodal}}
\DoxyCodeLine{\ \textcolor{comment}{//\ values\ are\ free\ -\/-\/\ we\ only\ need\ to\ pin\ the\ ones\ that\ have\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ Dirichlet\ conditions.\ }}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Pin\ the\ single\ nodal\ value\ at\ the\ single\ node\ on\ mesh\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ boundary\ 0\ (=\ the\ left\ domain\ boundary\ at\ x=0)}}
\DoxyCodeLine{\ mesh\_pt()-\/>boundary\_node\_pt(0,0)-\/>pin(0);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Pin\ the\ single\ nodal\ value\ at\ the\ single\ node\ on\ mesh\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ boundary\ 1\ (=\ the\ right\ domain\ boundary\ at\ x=1)}}
\DoxyCodeLine{\ mesh\_pt()-\/>boundary\_node\_pt(1,0)-\/>pin(0);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Complete\ the\ setup\ of\ the\ 1D\ Poisson\ problem:}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Loop\ over\ elements\ and\ set\ pointers\ to\ source\ function}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ i=0;i<n\_element;i++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Upcast\ from\ GeneralisedElement\ to\ the\ present\ element}}
\DoxyCodeLine{\ \ \ ELEMENT\ *elem\_pt\ =\ \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()-\/>element\_pt(i));}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Set\ the\ source\ function\ pointer}}
\DoxyCodeLine{\ \ \ elem\_pt-\/>source\_fct\_pt()\ =\ \mbox{\hyperlink{classOneDPoissonProblem_a5fdff4b9218f56dec7fbc282f2428eef}{Source\_fct\_pt}};}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Setup\ equation\ numbering\ scheme}}
\DoxyCodeLine{\ assign\_eqn\_numbers();}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ constructor}}

\end{DoxyCodeInclude}
 The cast in the loop over the elements is required because {\ttfamily Mesh\+::element\+\_\+pt(...)} returns a pointer to the element base class {\ttfamily Generalised\+Element}, which does not have an access function to the Poisson element\textquotesingle{}s source function pointer.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center}{\bfseries{\label{index_const_conv}%
\Hypertarget{index_const_conv}%
A general convention}}\end{center}  It might seem more natural to pass essential parameters (such as the Poisson element\textquotesingle{}s source function pointer) to an element when the element is created. If we made the source function pointer an argument of the element constructor, we would not have to execute this loop in the constructor.

However, {\ttfamily oomph-\/lib} employs a general {\bfseries{convention}} that element constructors should not have any arguments. This is because elements are usually created by the {\ttfamily Mesh} constructor. To allow {\ttfamily Meshes} that were originally developed for one particular element type (e.\+g. a quadrilateral Poisson element) to be used with other elements of same geometry (e.\+g. a quadrilateral Navier-\/\+Stokes element), {\ttfamily Mesh} objects are usually templated by the element type. The {\ttfamily Mesh} constructor creates elements by calling the element\textquotesingle{}s default (argument-\/free!) constructor. If we were to set any element-\/specific arguments via arguments to the element constructor it would be impossible to re-\/use the {\ttfamily Mesh} with other element types -- Navier-\/\+Stokes elements, for instance, do not have a source function pointer. The actions performed in this loop are therefore fairly typical as most non-\/trivial elements need to be passed some additional information to become fully functional.

\\\cline{1-1}
\end{longtabu}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_actions_before}{}\doxysection{\texorpdfstring{"{}\+Actions before solve"{}}{"Actions before solve"}}\label{index_actions_before}
The pure virtual function {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve()} must be implemented for all specific {\ttfamily Problems} and, as the name suggests, should perform any actions that need to be performed before the system of equations is solved. In the current problem, we use {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve()} to update the boundary conditions in response to possible changes in the sign of the source function. We use the exact solution (specified in the namespace {\ttfamily \doxylink{namespaceFishSolnOneDPoisson}{Fish\+Soln\+One\+DPoisson}}) to determine the boundary values that are appropriate for the sign specified in {\ttfamily \doxylink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{Fish\+Soln\+One\+DPoisson\+::\+Sign}}.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===start\_of\_actions\_before\_newton\_solve========================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Update\ the\ problem\ specs\ before\ solve:\ (Re)set\ boundary\ values}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ from\ the\ exact\ solution.\ }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classOneDPoissonProblem_a6e42423869771fbd216326cba516a76b}{OneDPoissonProblem<ELEMENT>::actions\_before\_newton\_solve}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Assign\ boundary\ values\ for\ this\ problem\ by\ reading\ them\ out}}
\DoxyCodeLine{\ \textcolor{comment}{//\ from\ the\ exact\ solution.}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Left\ boundary\ is\ node\ 0\ in\ the\ mesh:}}
\DoxyCodeLine{\ Node*\ left\_node\_pt=mesh\_pt()-\/>node\_pt(0);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Determine\ the\ position\ of\ the\ boundary\ node\ (the\ exact\ solution}}
\DoxyCodeLine{\ \textcolor{comment}{//\ requires\ the\ coordinate\ in\ a\ 1D\ vector!)}}
\DoxyCodeLine{\ Vector<double>\ x(1);}
\DoxyCodeLine{\ x[0]=left\_node\_pt-\/>x(0);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Boundary\ value\ (read\ in\ from\ exact\ solution\ which\ returns}}
\DoxyCodeLine{\ \textcolor{comment}{//\ the\ solution\ in\ a\ 1D\ vector)}}
\DoxyCodeLine{\ Vector<double>\ u(1);}
\DoxyCodeLine{\ \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a52c9346f567cb68fe20268a592deb4bc}{FishSolnOneDPoisson::get\_exact\_u}}(x,u);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Assign\ the\ boundary\ condition\ to\ one\ (and\ only)\ nodal\ value}}
\DoxyCodeLine{\ left\_node\_pt-\/>set\_value(0,u[0]);}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Right\ boundary\ is\ last\ node\ in\ the\ mesh:}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ last\_node=mesh\_pt()-\/>nnode()-\/1;}
\DoxyCodeLine{\ Node*\ right\_node\_pt=mesh\_pt()-\/>node\_pt(last\_node);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Determine\ the\ position\ of\ the\ boundary\ node}}
\DoxyCodeLine{\ x[0]=right\_node\_pt-\/>x(0);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Boundary\ value\ (read\ in\ from\ exact\ solution\ which\ returns}}
\DoxyCodeLine{\ \textcolor{comment}{//\ the\ solution\ in\ a\ 1D\ vector)}}
\DoxyCodeLine{\ \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a52c9346f567cb68fe20268a592deb4bc}{FishSolnOneDPoisson::get\_exact\_u}}(x,u);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Assign\ the\ boundary\ condition\ to\ one\ (and\ only)\ nodal\ value}}
\DoxyCodeLine{\ right\_node\_pt-\/>set\_value(0,u[0]);}
\DoxyCodeLine{}
\DoxyCodeLine{\ }
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ actions\ before\ solve}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_doc}{}\doxysection{\texorpdfstring{Post-\/processing}{Post-processing}}\label{index_doc}
The function {\ttfamily doc\+\_\+solution(...)} writes the FE solution and the corresponding exact solution, defined in {\ttfamily Fish\+Soln\+One\+DPoisson\+::get\+\_\+exact\+\_\+u(...)} to disk. The argument {\ttfamily label} is used to add identifiers to the output file names. Note that all output functions are implemented in the generic {\ttfamily Mesh} class\+:
\begin{DoxyItemize}
\item The function {\ttfamily Mesh\+::output(...)} executes the {\ttfamily Finite\+Element\+::output(...)} function for each element in a mesh. For 1D Poisson elements, this function writes the values of $ x $ and $ u(x) $ at {\ttfamily npts} uniformly spaced points in the element to the specified file.
\item The function {\ttfamily Mesh\+::output\+\_\+fct(...)} plots the function specified by the function pointer in its last argument at the specified number of points in each of the constituent elements. This allows point-\/by-\/point comparisons between exact and FE solutions. Here we plot the exact solution at a larger number of points to ensure that the exact solution looks smooth even if only a small number of elements are used for the discretisation of the ODE.
\end{DoxyItemize}Finally, we call the function {\ttfamily Mesh\+::compute\+\_\+error(...)} which determines the square of the L2 error, based on the difference between the exact solution (specified by a function pointer) and the FE solution. We also plot the pointwise error in the specified output file.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===start\_of\_doc=========================================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Doc\ the\ solution\ in\ tecplot\ format.\ Label\ files\ with\ label.}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classOneDPoissonProblem_aaf42d034e42e7615acfa262a9c56b638}{OneDPoissonProblem<ELEMENT>::doc\_solution}}(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ label)}
\DoxyCodeLine{\{\ }
\DoxyCodeLine{\ \textcolor{keyword}{using\ namespace\ }StringConversion;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Number\ of\ plot\ points}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ npts;}
\DoxyCodeLine{\ npts=5;\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Output\ solution\ with\ specified\ number\ of\ plot\ points\ per\ element}}
\DoxyCodeLine{\ ofstream\ solution\_file((\textcolor{stringliteral}{"{}soln"{}}\ +\ to\_string(label)\ +\ \textcolor{stringliteral}{"{}.dat"{}}).c\_str());}
\DoxyCodeLine{\ mesh\_pt()-\/>output(solution\_file,npts);}
\DoxyCodeLine{\ solution\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Output\ exact\ solution\ at\ much\ higher\ resolution\ (so\ we\ can}}
\DoxyCodeLine{\ \textcolor{comment}{//\ see\ how\ well\ the\ solutions\ agree\ between\ nodal\ points)}}
\DoxyCodeLine{\ ofstream\ exact\_file((\textcolor{stringliteral}{"{}exact\_soln"{}}\ +\ to\_string(label)\ +\ \textcolor{stringliteral}{"{}.dat"{}}).c\_str());}
\DoxyCodeLine{\ mesh\_pt()-\/>output\_fct(exact\_file,20*npts,\mbox{\hyperlink{namespaceFishSolnOneDPoisson_a52c9346f567cb68fe20268a592deb4bc}{FishSolnOneDPoisson::get\_exact\_u}});\ }
\DoxyCodeLine{\ exact\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Doc\ pointwise\ error\ and\ compute\ norm\ of\ error\ and\ of\ the\ solution}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ error,norm;}
\DoxyCodeLine{\ ofstream\ error\_file((\textcolor{stringliteral}{"{}error"{}}\ +\ to\_string(label)\ +\ \textcolor{stringliteral}{"{}.dat"{}}).c\_str());}
\DoxyCodeLine{\ mesh\_pt()-\/>compute\_error(error\_file,\mbox{\hyperlink{namespaceFishSolnOneDPoisson_a52c9346f567cb68fe20268a592deb4bc}{FishSolnOneDPoisson::get\_exact\_u}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ error,norm);\ }
\DoxyCodeLine{\ error\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Doc\ error\ norm:}}
\DoxyCodeLine{\ cout\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)nNorm\ of\ error\ \ \ \ :\ "{}}\ <<\ sqrt(error)\ <<\ std::endl;\ }
\DoxyCodeLine{\ cout\ <<\ \textcolor{stringliteral}{"{}Norm\ of\ solution\ :\ "{}}\ <<\ sqrt(norm)\ <<\ std::endl\ <<\ std::endl;}
\DoxyCodeLine{\ cout\ <<\ std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ doc}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_exercises}{}\doxysection{\texorpdfstring{Exercises}{Exercises}}\label{index_exercises}

\begin{DoxyEnumerate}
\item Run the code with different numbers of elements. How does the error between the exact and the analytical solution change?
\item Compare the error obtained with different element types -- replace the four-\/node Poisson element, {\ttfamily QPoisson\+Element$<$1,4$>$}, by its lower-\/order counterparts {\ttfamily QPoisson\+Element$<$1,3$>$} and {\ttfamily QPoisson\+Element$<$1,2$>$}.
\item The fish-\/shaped exact solution (4) is fairly smooth. Postulate a more rapidly varying "{}exact"{} solution, such as  \[
   u(x) = \tanh\left[\alpha \left(x-\frac{1}{2}\right)\right]
   \] which produces a "{}step"{} at $ x=1/2 $ when $ \alpha $ becomes sufficiently large. Calculate the source function required for this function to be an exact solution and implement both functions in another namespace, {\ttfamily Tanh\+Soln\+One\+DPoisson}, say. Replace the reference to {\ttfamily \doxylink{namespaceFishSolnOneDPoisson}{Fish\+Soln\+One\+DPoisson}} by {\ttfamily Tanh\+Soln\+One\+DPoisson} and repeat the above exercises.
\item Remove the Dirichlet boundary condition at the left end of the domain. What do you observe? \mbox{[}We shall return to this question in \href{../../../poisson/two_d_poisson_flux_bc/html/index.html}{\texttt{ another example}} where we discuss the \href{../../../poisson/two_d_poisson_flux_bc/html/index.html}{\texttt{ application of Neumann-\/type boundary conditions}}.\mbox{]}
\end{DoxyEnumerate}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{\texorpdfstring{Source files for this tutorial}{Source files for this tutorial}}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/poisson/one_d_poisson/}{\texttt{ demo\+\_\+drivers/poisson/one\+\_\+d\+\_\+poisson/ }} \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/poisson/one_d_poisson/one_d_poisson.cc}{\texttt{ demo\+\_\+drivers/poisson/one\+\_\+d\+\_\+poisson/one\+\_\+d\+\_\+poisson.\+cc }} \end{center} 
\end{DoxyItemize}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{\texorpdfstring{PDF file}{PDF file}}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
