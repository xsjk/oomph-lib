\chapter{Example problem\+: The Helmholtz equation -- scattering problems}
\hypertarget{index}{}\label{index}\index{Example problem: The Helmholtz equation -- scattering problems@{Example problem: The Helmholtz equation -- scattering problems}}
In this document we discuss the finite-\/element-\/based solution of the Helmholtz equation, an elliptic PDE that describes time-\/harmonic wave propagation problems. We start by reviewing the relevant theory and then present the solution of a simple model problem -- the scattering of a planar wave from a circular cylinder.

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{Acknowledgement\+:}} This tutorial and the associated driver codes were developed jointly with Tarak Kharrat (Ensta\+Paris\+Tech, Paris). \end{center}    \\\cline{1-1}
\end{longtabu}
\end{center} 

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_theory}{}\doxysection{\texorpdfstring{Theory\+: The Helmholtz equation for time-\/harmonic scattering problems}{Theory: The Helmholtz equation for time-harmonic scattering problems}}\label{index_theory}
The Helmholtz equation governs time-\/harmonic solutions of problems governed by the linear wave equation  \[
\nabla^2 U(x,y,t) = \frac{1}{c^2} \frac{\partial^2 U(x,y,t)}{\partial t^2},
 \ \ \ \ \ \ \ \ \ \ \ \ (1)
\] where $ c $ is the wavespeed. Assuming that $ U(x,y,t) $ is time-\/harmonic, with frequency $ \omega $, we write the real function $ U(x,y,t) $ as  \[
U(x,y,t) =Re (u(x,y) \ e^{-i \omega t})
\] where $ u(x,y) $ is complex-\/valued. This transforms (1) into the Helmholtz equation  \[
\nabla^2 u(x,y) + k^2 u(x,y) = 0
 \ \ \ \ \ \ \ \ \ \ \ \ (2)
\] where  \[
k = \frac{\omega}{c}
 \ \ \ \ \ \ \ \ \ \ \ \ (3)
\] is the wave number. Like other elliptic PDEs the Helmholtz equation admits Dirichlet, Neumann (flux) and Robin boundary conditions.

If the equation is solved in an infinite domain (e.\+g. in scattering problems) the solution must satisfy the so-\/called \href{http://en.wikipedia.org/wiki/Sommerfeld_radiation_condition}{\texttt{ Sommerfeld radiation condition}} which in 2D has the form  \[
\lim_{r\to \infty} \sqrt{r} \left(\frac{\partial u}{\partial r} - iku
\right) =0. 
\] Mathematically, this conditions is required to ensure the uniqueness of the solution (and hence the well-\/posedness of the problem). In a physical context, such as a scattering problem, the condition ensures that scattering of an incoming wave only produces outgoing not incoming waves from infinity.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_discr}{}\doxysection{\texorpdfstring{Discretisation by finite elements}{Discretisation by finite elements}}\label{index_discr}
The discretisation of the Helmholtz equation itself only requires a trivial modification of {\ttfamily oomph-\/lib\textquotesingle{}s} Poisson elements -- we simply add the term $ k^2 u $ to the residual. Since most practical applications of the Helmholtz equation involve complex-\/valued solutions, we provide separate storage for the real and imaginary parts of the solution -- each {\ttfamily Node} therefore stores two unknowns values. By default, the real and imaginary parts are stored as values 0 and 1, respectively; see the section \doxysectlink{index_numbering}{The enumeration of the unknowns}{2} for details.

The application of Dirichlet and Neumann boundary conditions is straightforward and follows the pattern employed for the solution of the Poisson equation\+:
\begin{DoxyItemize}
\item Dirichlet conditions are imposed by pinning the relevant nodal values and setting them to the appropriate prescribed values.
\item Neumann (flux) boundary conditions are imposed via {\ttfamily Face\+Elements} (here the {\ttfamily Helmholtz\+Flux\+Elements}). \href{../../../poisson/two_d_poisson_flux_bc/html/index.html}{\texttt{ As usual}} we attach these to the faces of the "{}bulk"{} elements that are subject to the Neumann boundary conditions.
\end{DoxyItemize}The imposition of the Sommerfeld radiation condition for problems in infinite domains is slightly more complicated. In the following discussion we will restrict ourselves to two dimensions and assume that the infinite domain is truncated at a circular artificial boundary $ \Gamma $ of radius $ R. $ \mbox{[}This assumption is also made in the implementation of {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Face\+Elements} that allow the (approximate) imposition of the Sommerfeld radiation condition. The methodology can easily be modified to deal with other geometries but this has not been done yet -- any volunteers?\mbox{]} All methods exploit the fact that the relevant solution of the Helmholtz equation can be written in polar coordinates as  \[
u(r,\varphi) = \sum_{n=-\infty}^{+\infty} A_n \ H_n^{(1)}(kr)  
\ e^{i n \varphi}, \ \ \ \ \ \ \ (4)
\] where the $A_n $ are suitable coefficients and $ H_n^{(1)}(r) $ is the $ n $-\/th-\/order Hankel function of the first kind.

\DoxyHorRuler{0}
\hypertarget{index_ABCs}{}\doxysubsection{\texorpdfstring{Approximate/absorbing boundary conditions (\+ABCs)}{Approximate/absorbing boundary conditions (ABCs)}}\label{index_ABCs}
It is possible to derive approximate versions of the Sommerfeld radiation condition in which the normal derivative of the solution on the artificial boundary is related to its value and possibly its tangential derivatives. Such boundary conditions (sometimes referred to as approximate or absorbing boundary conditions -- ABCs) are typically derived from asymptotic expansions of the solution at large distances from the origin and become more accurate the larger the radius $ R $ of the artificial boundary $ \Gamma $ is. Higher accuracy can therefore only be achieved by increasing the size of the computational domain, with an associated increase in computational cost.

{\ttfamily oomph-\/lib} provides an implementation of the following three boundary conditions (all taken from J. J. Shirron \& I. Babuska\textquotesingle{}s paper "{}\+A comparison of approximate boundary  conditions and infinite element methods for exterior Helmholtz problems"{}, Computer Methods in Applied Mechanics and Engineering {\bfseries{164}} 121-\/139 (1998), in which the authors compare the accuracy of these and many other approximate boundary conditions).


\begin{DoxyItemize}
\item {\bfseries{Feng\textquotesingle{}s first order ABC\+:}}  \[
 \frac {\partial u}{\partial n}-\bigg( ik - \frac{1}{2R}\bigg) u
 =0   \mbox{\ \ \  \ \  on\ }\Gamma  
\] (This is identical to the first-\/order Bayliss and Turkel boundary condition).
\item {\bfseries{Feng\textquotesingle{}s second order ABC\+:}}  \[
 \frac{\partial u}{\partial n}-\bigg[ik-\frac
 {1}{2R}+\frac{i}{8kR^{2}}\bigg(1+4 \frac {\partial^{2}}{\partial
 \varphi^{2}}\bigg)\bigg]u
=0  \mbox{\ \ \  \ \  on\ }\Gamma  
\]
\item {\bfseries{Feng\textquotesingle{}s third order ABC\+:}}  \[
 \frac {\partial u}{\partial n}-\bigg[ik-\frac
 {1}{2R}+\frac{1}{8k^{2}R^{2}}\bigg(ik+ \frac {1}{R}\bigg)
 \bigg(1+4 \frac {\partial^{2}}{\partial \varphi^{2}}\bigg)\bigg]u
=0   \mbox{\ \ \  \ \  on\ }\Gamma  
\]
\end{DoxyItemize}All three boundary conditions are implemented in the class {\ttfamily Helmholtz\+Absorbing\+BCElement}. The order of the approximation can be set via the member function {\ttfamily Helmholtz\+Absorbing\+BCElement\+::abc\+\_\+order()}. All three boundary conditions are local (relating the function to its normal derivative) and do therefore not change the sparsity of the resulting finite element equations.

\DoxyHorRuler{0}
\hypertarget{index_DtN}{}\doxysubsection{\texorpdfstring{The Dirichlet-\/to-\/\+Neumann mapping (\+Dt\+N)}{The Dirichlet-to-Neumann mapping (DtN)}}\label{index_DtN}
Using (4), it is easy to show (see, e.\+g., J. Jin "{}\+The Finite Element Method in Electromagnetics (second edition)"{}, Wiley (2002) p. 501ff -- but note that Jin assumes that the potential varies like $ \exp(i\omega t)$ rather than $ \exp(-i\omega t)$ as assumed here) that the normal (radial) derivative, $ \partial u / \partial n =   
\partial u / \partial r, $ on the artificial boundary ~\newline
 $ \Gamma $ is given by  \[
 \frac {\partial u}{\partial r}\bigg|_{r=R} =
 \frac {\partial u}{\partial n}\bigg|_{r=R} =
 \gamma (u) \ \ \ \ \ \ \ (5)   
\] where  \[
\gamma (u) = \frac {k}{2 \pi} \sum_{n=-\infty}^{+\infty} 
\frac {H_n^{(1)^{\textnormal{\textquotesingle}}}(kR)}{H_n^{(1)}(kR)} \quad 
\int_0^{2\pi}u(R,\varphi^{\textnormal{\textquotesingle}}) \ e^{in(\varphi-\varphi^{\textnormal{\textquotesingle}})}
\,d\varphi^{\textnormal{\textquotesingle}}.  
 \ \ \ \ \ \ \ (6)   
\] Equation (5) again provides a condition on the normal derivative of the solution along the artificial boundary and is implemented in the {\ttfamily Helmholtz\+Dt\+NBoundary\+Element} class. Since $ \gamma $ depends on the solution everywhere along the artificial boundary (see (6)), the application of the boundary condition (5) introduces a non-\/local coupling between all the degrees of freedom located on that boundary. This is handled by classifying the unknowns that affect $ \gamma $ but are not associated with the element\textquotesingle{}s own nodes as external {\ttfamily Data}.

To facilitate the setup of the interaction between the {\ttfamily Helmholtz\+Dt\+NBoundary\+Elements}, {\ttfamily oomph-\/lib} provides the class {\ttfamily Helmholtz\+Dt\+NMesh} which provides storage for (the pointers to) the {\ttfamily Helmholtz\+Dt\+NBoundary\+Elements} that discretise the artificial boundary. The member function {\ttfamily Helmholtz\+Dt\+NMesh\+::setup\+\_\+gamma()} pre-\/computes the $ \gamma $ values required for the imposition of equation (5). The radius $ R $ of the artificial boundary and the (finite) number of (Fourier) terms used in the sum in (6) are specified as arguments to the constructor of the {\ttfamily Helmholtz\+Dt\+NMesh}.

{\bfseries{NOTE\+:}} Since $ \gamma $ depends on the solution, it must be recomputed whenever the unknowns are updated during the Newton iteration. This is best done by adding a call to {\ttfamily Helmholtz\+Dt\+NMesh\+::setup\+\_\+gamma()} to {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()}. \mbox{[}If Helmholtz\textquotesingle{}s equation is solved in isolation (or within a coupled, but linear problem), Newton\textquotesingle{}s method will converge in one iteration. In such cases the unnecessary recomputation of $ \gamma $ after the one-\/and-\/only Newton iteration can be suppressed by setting {\ttfamily Problem\+::\+Problem\+\_\+is\+\_\+nonlinear} to {\ttfamily false}.\mbox{]}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_scattering}{}\doxysection{\texorpdfstring{A specific example\+: Scattering of an acoustic wave from a sound-\/hard obstacle}{A specific example: Scattering of an acoustic wave from a sound-hard obstacle}}\label{index_scattering}
We will now demonstrate the methodology for a specific example\+: the scattering of sound waves in an acoustic medium of density $ \rho  $ and bulk modulus $ B $. Assuming that an incoming sound wave impacts a rigid, impermeable obstacle as shown in this sketch,

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{scattering}
\doxyfigcaption{Scattering of an incoming wave from a sound-\/hard obstacle -\/-\/ the scatterer. }
\end{DoxyImage}


we wish to find the wave field that is scattered from the body.

For this purpose we denote the time-\/dependent displacement of the fluid particle in the acoustic medium by $ {\bf u}^*(x^*,y^*,t^*) $ and introduce a displacement potential $ \Phi^*(x^*,y^*,t^*) $ such that  \[
{\bf u}^* = \nabla^* \Phi^*.
\] (As usual we employ asterisks to distinguish dimensional quantities from their non-\/dimensional equivalents, to be introduced below.) It is easy to show that $ \Phi^* $ satisfies the linear wave equation (1) with wave speed $ c = \sqrt{B/\rho}$.

Since the surface $ \partial D_{bound}$ of the scatterer is impenetrable, the normal displacement of the fluid has to vanish on $ \partial D_{bound}$ and the boundary condition for the displacement potential becomes  \[
\left. \frac{\partial \Phi^*}{\partial n^*}\right|_{\partial D_{bound}} = 0.
\ \ \ \ \ \ \ \ \ \ \ \ \  (7)
\]

We non-\/dimensionalise all lengths and displacements on some problem-\/dependent lengthscale $ {\cal L}$ (e.\+g. the radius of the scatterer), non-\/dimensionalise the potential as $ \Phi^* =  a^2 \Phi $ and scale time on the period of the oscillation, $ t^* = \frac{2\pi}{\omega} t.$ The governing equation then becomes  \[
\nabla^2 \Phi + k^2 \Phi = 0, \ \ \ \ \ \ \ \ \ \ \ (8)
\] where the square of the wavenumber is given by  \[
k^2  = \frac{\rho (a\omega)^2}{B}.
\]

Assuming that the incoming wave (already satisfying (8)) is described by a (known) non-\/dimensional displacement potential of the form  \[
\Phi_{inc}(x,y,t) = \phi_{inc}(x,y) \  e^{-i 2\pi t},
\] we write the total potential as  \[
\Phi(x,y,t) = \bigg( \phi_{inc}(x,y) + u(x,y) \bigg) \ e^{-i 2\pi t},
\] where $ u(x,y) \  e^{-i 2\pi t} $ represents the displacement potential associated with the scattered field which must satisfy (2). The boundary condition (7) then becomes a Neumann (flux) boundary condition for the scattered field,  \[
\left. \frac{\partial u}{\partial n}\right|_{\partial D_{bound}} =
- \left. \frac{\partial \phi_{inc}}{\partial n}\right|_{\partial D_{bound}}.
\ \ \ \ \ \ \ \ \ \ \ \ \  (9)
\]

For the special case of the incoming wave being a planar wave, propagating along the x-\/axis, the incoming field can be written in polar coordinates as  \[
  \phi_{inc}(r, \varphi)  
= \sum_{n=-\infty}^{+\infty} i^n  J_n(kr) e^{in\varphi}, 
\] where $ J_n $ is the Bessel function of the first kind of order $ n $. The exact solution for the scattering of such a wave from a circular disk is given by the series  \[
  u_{ex}(r,\varphi) 
= -\sum_{n=-\infty}^{+\infty} i^n \frac
{H^{\textnormal{\textquotesingle}}_{n}(k)}{J^{\textnormal{\textquotesingle}}_{n}(k)}  H_n(kr) e^{in\varphi},
\ \ \ \ \ \ \ \ \ \ \ \ \  (10)
\] where we have chosen the disk\textquotesingle{}s radius, $ a $, as the lengthscale by setting $ {\cal L} = a$. In the above expression, $ H_n $ denotes the Hankel function of the first kind of order $ n $ and the prime denotes differentiation with respect to the function\textquotesingle{}s argument.

A quantity that is of particular interest in wave propagation problems is the time-\/average of the power radiated by the scatterer,  \[
\overline{\cal P}^* = 
\frac{\omega}{2\pi} \int_{0}^{2\pi/\omega} {\cal P}^*(t) \ dt^*.
\] In the context of an acoustic wave, the total instantaneous power, $ {\cal P}^*(t), $ radiated over a closed boundary is  \[
{\cal P}^*(t) = \oint \frac{\partial {\bf u^*} }{\partial t^*} 
\cdot p^* {\bf n} \ dS^*,
\] where the pressure is related to the displacement potential via  \[
p^* = \rho \omega^2 \Phi^*.
\] The non-\/dimensional time-\/averaged radiated power can be expressed in terms of the complex potential $ \phi $ as  \[
\overline{\cal P} = \frac{\overline{\cal P}^*}{\rho \omega^3 {\cal L}^4} =
\frac{1}{2}
\oint\bigg[Im\bigg(\frac{\partial \phi}{\partial n}\bigg) \ Re(\phi) -
           Re\bigg(\frac{\partial \phi}{\partial n}\bigg) \ Im(\phi)
           \bigg]
 \ dS.
\] \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_results}{}\doxysection{\texorpdfstring{Results}{Results}}\label{index_results}
The figure below shows an animation of the displacement potential $ Re(u(x,y,t)) $ for scattering from a circular disk for a non-\/dimensional wavenumber of $ k=1 $ over one period of the oscillation. The simulation was performed in an annular computational domain, bounded by the outer surface the (unit) disk and an artificial outer boundary of non-\/dimensional radius $ R=1.5. $ The Sommerfeld radiation condition was imposed using the DtN mapping and the simulation was performed with spatial adaptivity (note the non-\/uniform refinement).

The "{}carpet plot"{} compares the exact (green) and computed (red) solutions for the displacement potential. The colours in the contour plot at the bottom of the figure provide an alternative visualisation of the magnitude of the scattered field.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{scattering_animation}
\doxyfigcaption{The displacement potential associated with the scattered wave, animated over one period of the oscillation. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_num_soln}{}\doxysection{\texorpdfstring{The numerical solution}{The numerical solution}}\label{index_num_soln}
\hypertarget{index_namespace}{}\doxysubsection{\texorpdfstring{The global namespace}{The global namespace}}\label{index_namespace}
As usual, we define the problem parameters in a global namespace. The main physical parameter is the (square of the) wave number, $ k^2 $. {\ttfamily N\+\_\+fourier} is the number of (Fourier) terms to be used in evaluation of the series in equations (6) and (10). The remaining parameters determine how the Sommerfeld radiation condition is applied.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====\ start\_of\_namespace=============================================}}

\end{DoxyCodeInclude}


The function {\ttfamily get\+\_\+exact\+\_\+u} returns the exact solution for the scattering problem. We will use this function for the validation of our results.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Exact\ solution\ for\ scattered\ field\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ (vector\ returns\ real\ and\ impaginary\ parts).}}
\DoxyCodeLine{\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{namespaceGlobalParameters_ae2320da6053f5527b2af5ebb362a8a07}{get\_exact\_u}}(\textcolor{keyword}{const}\ Vector<double>\&\ x,\ Vector<double>\&\ u)}
\DoxyCodeLine{\ \{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Switch\ to\ polar\ coordinates}}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{double}\ r;}
\DoxyCodeLine{\ \ r=sqrt(x[0]*x[0]+x[1]*x[1]);}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{double}\ theta;}
\DoxyCodeLine{\ \ theta=atan2(x[1],x[0]);}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Argument\ for\ Bessel/Hankel\ functions}}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{double}\ rr=sqrt(K\_squared)*r;\ \ }
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Evaluate\ Bessel/Hankel\ functions}}
\DoxyCodeLine{\ \ complex\ <double\ >\ u\_ex(0.0,0.0);}
\DoxyCodeLine{\ \ Vector<double>\ jn(N\_fourier+1),\ yn(N\_fourier+1),}
\DoxyCodeLine{\ \ \ jnp(N\_fourier+1),\ ynp(N\_fourier+1);}
\DoxyCodeLine{\ \ Vector<double>\ jn\_a(N\_fourier+1),yn\_a(N\_fourier+1),}
\DoxyCodeLine{\ \ \ jnp\_a(N\_fourier+1),\ ynp\_a(N\_fourier+1);}
\DoxyCodeLine{\ \ Vector<complex<double>\ >\ h(N\_fourier+1),h\_a(N\_fourier+1),}
\DoxyCodeLine{\ \ \ hp(N\_fourier+1),\ hp\_a(N\_fourier+1);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ We\ want\ to\ compute\ N\_fourier\ terms\ but\ the\ function}}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ may\ return\ fewer\ than\ that.}}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{int}\ n\_actual=0;}
\DoxyCodeLine{\ \ CRBond\_Bessel::bessjyna(N\_fourier,sqrt(K\_squared),n\_actual,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \&jn\_a[0],\&yn\_a[0],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \&jnp\_a[0],\&ynp\_a[0]);\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Shout\ if\ things\ went\ wrong\ \ }}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef\ PARANOID}}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{if}\ (n\_actual!=\textcolor{keywordtype}{int}(N\_fourier))}
\DoxyCodeLine{\ \ \ \{}
\DoxyCodeLine{\ \ \ \ std::ostringstream\ error\_stream;\ }
\DoxyCodeLine{\ \ \ \ error\_stream\ <<\ \textcolor{stringliteral}{"{}CRBond\_Bessel::bessjyna()\ only\ computed\ "{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ n\_actual\ <<\ \textcolor{stringliteral}{"{}\ rather\ than\ "{}}\ <<\ \mbox{\hyperlink{namespaceGlobalParameters_ae4df03bf0ffa55b741ac846ca7b6c155}{N\_fourier}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ Bessel\ functions.\(\backslash\)n"{}};\ \ \ \ }
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{throw}\ OomphLibError(error\_stream.str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ OOMPH\_CURRENT\_FUNCTION,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ OOMPH\_EXCEPTION\_LOCATION);}
\DoxyCodeLine{\ \ \ \}}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Evaluate\ Hankel\ at\ actual\ radius}}
\DoxyCodeLine{\ \ Hankel\_functions\_for\_helmholtz\_problem::Hankel\_first(N\_fourier,rr,h,hp);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Evaluate\ Hankel\ at\ inner\ (unit)\ radius}}
\DoxyCodeLine{\ \ Hankel\_functions\_for\_helmholtz\_problem::Hankel\_first(N\_fourier}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ,sqrt(K\_squared),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ h\_a,hp\_a);}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Compute\ the\ sum:\ Separate\ the\ computation\ of\ the\ negative\ }}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ and\ positive\ terms}}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ i=0;i<\mbox{\hyperlink{namespaceGlobalParameters_ae4df03bf0ffa55b741ac846ca7b6c155}{N\_fourier}};i++)}
\DoxyCodeLine{\ \ \ \{}
\DoxyCodeLine{\ \ \ \ u\_ex-\/=pow(I,i)*h[i]*((jnp\_a[i])/hp\_a[i])*pow(exp(I*theta),i);}
\DoxyCodeLine{\ \ \ \}}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ i=1;i<\mbox{\hyperlink{namespaceGlobalParameters_ae4df03bf0ffa55b741ac846ca7b6c155}{N\_fourier}};i++)}
\DoxyCodeLine{\ \ \ \{}
\DoxyCodeLine{\ \ \ \ u\_ex-\/=pow(I,i)*h[i]*((jnp\_a[i])/hp\_a[i])*pow(exp(-\/I*theta),i);}
\DoxyCodeLine{\ \ \ \}}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Get\ the\ real\ \&\ imaginary\ part\ of\ the\ result}}
\DoxyCodeLine{\ \ u[0]=real(u\_ex);}
\DoxyCodeLine{\ \ u[1]=imag(u\_ex);}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \}\textcolor{comment}{//\ end\ of\ get\_exact\_u}}

\end{DoxyCodeInclude}
 Next we provide a function that computes the prescribed flux (normal derivative) of the solution, $ \partial u/\partial n =
-\partial \phi_{inc}/\partial n $, evaluated on the surface of the unit disk.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Flux\ (normal\ derivative)\ on\ the\ unit\ disk}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ for\ a\ planar\ incoming\ wave}}
\DoxyCodeLine{\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{namespaceGlobalParameters_a5183de63b992338ee60bb4da78a45039}{prescribed\_incoming\_flux}}(\textcolor{keyword}{const}\ Vector<double>\&\ x,\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ complex<double>\&\ flux)}
\DoxyCodeLine{\ \{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Switch\ to\ polar\ coordinates}}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{double}\ r;}
\DoxyCodeLine{\ \ r=sqrt(x[0]*x[0]+x[1]*x[1]);}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{double}\ theta;}
\DoxyCodeLine{\ \ theta=atan2(x[1],x[0]);}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Argument\ of\ the\ Bessel/Hankel\ fcts}}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{double}\ rr=sqrt(K\_squared)*r;\ \ }
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Compute\ Bessel/Hankel\ functions}}
\DoxyCodeLine{\ \ Vector<double>\ jn(N\_fourier+1),\ yn(N\_fourier+1),}
\DoxyCodeLine{\ \ \ jnp(N\_fourier+1),\ ynp(N\_fourier+1);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ We\ want\ to\ compute\ N\_fourier\ terms\ but\ the\ function}}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ may\ return\ fewer\ than\ that.}}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{int}\ n\_actual=0;}
\DoxyCodeLine{\ \ CRBond\_Bessel::bessjyna(N\_fourier,rr,n\_actual,\&jn[0],\&yn[0],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \&jnp[0],\&ynp[0]);}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Shout\ if\ things\ went\ wrong...}}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef\ PARANOID}}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{if}\ (n\_actual!=\textcolor{keywordtype}{int}(N\_fourier))}
\DoxyCodeLine{\ \ \ \{}
\DoxyCodeLine{\ \ \ \ std::ostringstream\ error\_stream;\ }
\DoxyCodeLine{\ \ \ \ error\_stream\ <<\ \textcolor{stringliteral}{"{}CRBond\_Bessel::bessjyna()\ only\ computed\ "{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ n\_actual\ <<\ \textcolor{stringliteral}{"{}\ rather\ than\ "{}}\ <<\ \mbox{\hyperlink{namespaceGlobalParameters_ae4df03bf0ffa55b741ac846ca7b6c155}{N\_fourier}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ Bessel\ functions.\(\backslash\)n"{}};\ \ \ \ }
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{throw}\ OomphLibError(error\_stream.str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ OOMPH\_CURRENT\_FUNCTION,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ OOMPH\_EXCEPTION\_LOCATION);}
\DoxyCodeLine{\ \ \ \}}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Compute\ the\ sum:\ Separate\ the\ computation\ of\ the\ negative\ and\ }}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ positive\ terms}}
\DoxyCodeLine{\ \ flux=std::complex<double>(0.0,0.0);}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ i=0;i<\mbox{\hyperlink{namespaceGlobalParameters_ae4df03bf0ffa55b741ac846ca7b6c155}{N\_fourier}};i++)}
\DoxyCodeLine{\ \ \ \{}
\DoxyCodeLine{\ \ \ \ flux+=pow(I,i)*(sqrt(K\_squared))*pow(exp(I*theta),i)*jnp[i];}
\DoxyCodeLine{\ \ \ \}}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ i=1;i<\mbox{\hyperlink{namespaceGlobalParameters_ae4df03bf0ffa55b741ac846ca7b6c155}{N\_fourier}};i++)}
\DoxyCodeLine{\ \ \ \{}
\DoxyCodeLine{\ \ \ \ flux+=pow(I,i)*(sqrt(K\_squared))*pow(exp(-\/I*theta),i)*jnp[i];}
\DoxyCodeLine{\ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \}\textcolor{comment}{//\ end\ of\ prescribed\_incoming\_flux\ }}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ namespace}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysubsection{\texorpdfstring{The driver code}{The driver code}}\label{index_main}
The driver code is very straightforward. We parse the command line to determine which boundary condition to use and set the flags in the global namespace accordingly.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==========start\_of\_main=================================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Solve\ 2D\ Helmholtz\ problem\ for\ scattering\ of\ a\ planar\ wave\ from\ a\ }\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ unit\ disk\ }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{barrel_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}(\textcolor{keywordtype}{int}\ argc,\ \textcolor{keywordtype}{char}\ **argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Store\ command\ line\ arguments}}
\DoxyCodeLine{\ CommandLineArgs::setup(argc,argv);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Define\ case\ to\ be\ run}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ i\_case=0;}
\DoxyCodeLine{\ CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"{}-\/-\/case"{}},\&i\_case);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Parse\ command\ line}}
\DoxyCodeLine{\ CommandLineArgs::parse\_and\_assign();\ }
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Doc\ what\ has\ actually\ been\ specified\ on\ the\ command\ line}}
\DoxyCodeLine{\ CommandLineArgs::doc\_specified\_flags();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Now\ set\ flags\ accordingly}}
\DoxyCodeLine{\ \textcolor{keywordflow}{switch}(i\_case)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{case}\ 0:}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{namespaceGlobalParameters_a6e2bba1769e86a5d3db88e2c7062bc63}{GlobalParameters::DtN\_BC}}=\textcolor{keyword}{true};}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \textcolor{keywordflow}{case}\ 1:}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{namespaceGlobalParameters_a6e2bba1769e86a5d3db88e2c7062bc63}{GlobalParameters::DtN\_BC}}=\textcolor{keyword}{false};}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{namespaceGlobalParameters_a552eed3548a269715a95161ad3c4b96a}{GlobalParameters::ABC\_order}}=1;}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{case}\ 2:}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{namespaceGlobalParameters_a6e2bba1769e86a5d3db88e2c7062bc63}{GlobalParameters::DtN\_BC}}=\textcolor{keyword}{false};}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{namespaceGlobalParameters_a552eed3548a269715a95161ad3c4b96a}{GlobalParameters::ABC\_order}}=2;}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{case}\ 3:}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{namespaceGlobalParameters_a6e2bba1769e86a5d3db88e2c7062bc63}{GlobalParameters::DtN\_BC}}=\textcolor{keyword}{false};}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{namespaceGlobalParameters_a552eed3548a269715a95161ad3c4b96a}{GlobalParameters::ABC\_order}}=3;}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{\ \ \}}

\end{DoxyCodeInclude}
 Next we build the problem, either with or without enabling spatial adaptivity and define the output directory.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//Set\ up\ the\ problem}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef\ ADAPTIVE}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//Set\ up\ the\ problem\ with\ 2D\ nine-\/node\ elements\ from\ the}}
\DoxyCodeLine{\ \textcolor{comment}{//QHelmholtzElement\ family.}}
\DoxyCodeLine{\ \mbox{\hyperlink{classScatteringProblem}{ScatteringProblem<RefineableQHelmholtzElement<2,3>}}\ >\ }
\DoxyCodeLine{\ \ problem;}
\DoxyCodeLine{\ }
\DoxyCodeLine{\textcolor{preprocessor}{\#else}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//Set\ up\ the\ problem\ with\ 2D\ nine-\/node\ elements\ from\ the}}
\DoxyCodeLine{\ \textcolor{comment}{//QHelmholtzElement\ family.\ }}
\DoxyCodeLine{\ \mbox{\hyperlink{classScatteringProblem}{ScatteringProblem<QHelmholtzElement<2,3>}}\ >\ }
\DoxyCodeLine{\ \ problem;}
\DoxyCodeLine{\ }
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ label\ for\ output}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ DocInfo\ doc\_info;}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ output\ directory}}
\DoxyCodeLine{\ doc\_info.set\_directory(\textcolor{stringliteral}{"{}RESLT"{}});}

\end{DoxyCodeInclude}
 Finally, we solve the problem and document the results.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef\ ADAPTIVE}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Max.\ number\ of\ adaptations}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ max\_adapt=1;}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Solve\ the\ problem\ with\ Newton's\ method,\ allowing}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ up\ to\ max\_adapt\ mesh\ adaptations\ after\ every\ solve.}}
\DoxyCodeLine{\ \ \ problem.newton\_solve(max\_adapt);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#else}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Solve\ the\ problem\ with\ Newton's\ method}}
\DoxyCodeLine{\ \ \ problem.newton\_solve();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Output\ solution}}
\DoxyCodeLine{\ problem.\mbox{\hyperlink{classScatteringProblem_af83ab14c4f4750ea17c21466f6c6364f}{doc\_solution}}(doc\_info);}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\}\ \textcolor{comment}{//end\ of\ main}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_class}{}\doxysubsection{\texorpdfstring{The problem class}{The problem class}}\label{index_class}
The problem class is very similar to that employed for the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\texttt{ adaptive solution of the 2D Poisson equation with flux boundary conditions.}} The only difference is that we provide two separate meshes of {\ttfamily Face\+Elements\+:} one for the inner boundary where the {\ttfamily Helmholtz\+Flux\+Elements} apply the Neumann condition (9), and one for the outer boundary where we apply the (approximate) Sommerfeld radiation condition. As discussed in section \doxysectlink{index_DtN}{The Dirichlet-\/to-\/\+Neumann mapping (DtN)}{2} , we use the function {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} to recompute the $ \gamma $ integral whenever the unknowns are updated during the Newton iteration.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=========\ start\_of\_problem\_class=====================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Problem\ class\ to\ compute\ scattering\ of\ planar\ wave\ from\ unit\ disk}}
\DoxyCodeLine{\textcolor{comment}{//=====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>\ }
\DoxyCodeLine{\textcolor{keyword}{class\ }\mbox{\hyperlink{classScatteringProblem}{ScatteringProblem}}\ :\ \textcolor{keyword}{public}\ Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Constructor}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classScatteringProblem_a94710f5d2ee52abc3df9dc8d1fd3eb71}{ScatteringProblem}}();}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Destructor\ (empty)}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classScatteringProblem_a0a9838027d0286f22706fe6945bbac0a}{\string~ScatteringProblem}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Doc\ the\ solution.\ DocInfo\ object\ stores\ flags/labels\ for\ where\ the}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ output\ gets\ written\ to}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_af83ab14c4f4750ea17c21466f6c6364f}{doc\_solution}}(DocInfo\&\ doc\_info);}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ the\ problem\ specs\ before\ solve\ (empty)}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_a91ce14b928ec6edbb9d85515a310b1fb}{actions\_before\_newton\_solve}}()\{\}\ }
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ the\ problem\ specs\ after\ solve\ (empty)}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_abf1e7b97518c94e12802205dec08b15e}{actions\_after\_newton\_solve}}()\{\}}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Recompute\ gamma\ integral\ before\ checking\ Newton\ residuals}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_ad096c311ee474d23514656d2ba76a4b8}{actions\_before\_newton\_convergence\_check}}()}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{if}\ (\mbox{\hyperlink{namespaceGlobalParameters_a6e2bba1769e86a5d3db88e2c7062bc63}{GlobalParameters::DtN\_BC}})}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \mbox{\hyperlink{classScatteringProblem_a9692c8592b57a4363e557e5b012c744b}{Helmholtz\_outer\_boundary\_mesh\_pt}}-\/>setup\_gamma();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Actions\ before\ adapt:\ Wipe\ the\ mesh\ of\ prescribed\ flux\ elements}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_aca1b756a307f9c1d8a70c7b7e68a296b}{actions\_before\_adapt}}();}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Actions\ after\ adapt:\ Rebuild\ the\ mesh\ of\ prescribed\ flux\ elements}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_a13d8f85e74666c260de7364917359ed5}{actions\_after\_adapt}}();}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Create\ BC\ elements\ on\ boundary\ b\ of\ the\ Mesh\ pointed}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ to\ by\ bulk\_mesh\_pt\ and\ add\ them\ to\ the\ specified\ survace\ Mesh\ }}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_a408e05fbe1f1456ab7013a7e8ab29ccc}{create\_outer\_bc\_elements}}(}
\DoxyCodeLine{\ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \&b,\ Mesh*\ \textcolor{keyword}{const}\ \&bulk\_mesh\_pt,}
\DoxyCodeLine{\ \ Mesh*\ \textcolor{keyword}{const}\ \&\ helmholtz\_outer\_boundary\_mesh\_pt);}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Create\ Helmholtz\ flux\ elements\ on\ boundary\ b\ of\ the\ Mesh\ pointed}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ to\ by\ bulk\_mesh\_pt\ and\ add\ them\ to\ the\ specified\ surface\ Mesh\ }}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_af06ff518ad3250f914c0c659af3001c8}{create\_flux\_elements}}(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \&b,\ Mesh*\ \textcolor{keyword}{const}\ \&bulk\_mesh\_pt,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Mesh*\ \textcolor{keyword}{const}\ \&\ helmholtz\_inner\_boundary\_mesh\_pt);}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Delete\ boundary\ face\ elements\ and\ wipe\ the\ surface\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_aaef8a78e317333ddadd0be6a500c1134}{delete\_face\_elements}}(\ Mesh*\ \textcolor{keyword}{const}\ \&\ boundary\_mesh\_pt);}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Set\ pointer\ to\ prescribed-\/flux\ function\ for\ all}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ elements\ in\ the\ surface\ mesh\ on\ the\ surface\ of\ the\ unit\ disk}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_ae75307dde909513a0f11057c96cdd622}{set\_prescribed\_incoming\_flux\_pt}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Set\ up\ boundary\ condition\ elements\ on\ outer\ boundary}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_a76bd8299ea7ed559681b294acfb2aad4}{setup\_outer\_boundary}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef\ ADAPTIVE}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ Pointer\ to\ the\ "{}bulk"{}\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ RefineableTwoDAnnularMesh<ELEMENT>*\ \mbox{\hyperlink{classScatteringProblem_a8c61657a1d09ce49a5871ca3febe5658}{Bulk\_mesh\_pt}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#else}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ the\ "{}bulk"{}\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ TwoDAnnularMesh<ELEMENT>*\ \mbox{\hyperlink{classScatteringProblem_a8c61657a1d09ce49a5871ca3febe5658}{Bulk\_mesh\_pt}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ mesh\ containing\ the\ DtN\ (or\ ABC)\ boundary}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ condition\ elements}}
\DoxyCodeLine{\textcolor{comment}{}\ HelmholtzDtNMesh<ELEMENT>*\ \mbox{\hyperlink{classScatteringProblem_a9692c8592b57a4363e557e5b012c744b}{Helmholtz\_outer\_boundary\_mesh\_pt}};}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ the\ mesh\ containing\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ the\ Helmholtz\ inner\ boundary\ condition\ elements\ }}
\DoxyCodeLine{\textcolor{comment}{}\ Mesh*\ \mbox{\hyperlink{classScatteringProblem_a56b5fc73bbb51b701a43dc38f9815104}{Helmholtz\_inner\_boundary\_mesh\_pt}};}
\DoxyCodeLine{}
\DoxyCodeLine{\};\ \textcolor{comment}{//\ end\ of\ problem\ class}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constr}{}\doxysubsection{\texorpdfstring{The problem constructor}{The problem constructor}}\label{index_constr}
We start by building the bulk mesh, using the refineable or non-\/refineable version of the {\ttfamily Two\+DAnnular\+Mesh}, depending on the macro {\ttfamily ADAPTIVE}. (The error tolerances for the adaptive version are chosen such that the mesh is refined non-\/uniformly -- with the default tolerances, {\ttfamily oomph-\/lib\textquotesingle{}s} automatic mesh adaptation procedure refine the mesh uniformly.)

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=======start\_of\_constructor=============================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Constructor\ for\ Helmholtz\ problem}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classScatteringProblem_a94710f5d2ee52abc3df9dc8d1fd3eb71}{ScatteringProblem<ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classScatteringProblem_a94710f5d2ee52abc3df9dc8d1fd3eb71}{ScatteringProblem}}()}
\DoxyCodeLine{\{\ }
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Setup\ "{}bulk"{}\ mesh}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ \#\ of\ elements\ in\ theta}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_theta=15;}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ \#\ of\ elements\ in\ radius}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_r=5;}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Inner\ radius}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ a=1.0;}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Thickness\ of\ annular\ computational\ domain}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ h=0.5;\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ outer\ radius}}
\DoxyCodeLine{\ \mbox{\hyperlink{namespaceGlobalParameters_a61b086072a6b8fd38af1a85f1dd1674a}{GlobalParameters::Outer\_radius}}=a+h;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Mesh\ is\ periodic}}
\DoxyCodeLine{\ \textcolor{keywordtype}{bool}\ periodic=\textcolor{keyword}{true};\ }
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Full\ circle}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ azimuthal\_fraction=1.0;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef\ ADAPTIVE}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Build\ "{}bulk"{}\ mesh}}
\DoxyCodeLine{\ Bulk\_mesh\_pt=}
\DoxyCodeLine{\ \ \textcolor{keyword}{new}\ RefineableTwoDAnnularMesh<ELEMENT>(periodic,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ azimuthal\_fraction,n\_theta,n\_r,a,h);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Create/set\ error\ estimator}}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>spatial\_error\_estimator\_pt()=\textcolor{keyword}{new}\ Z2ErrorEstimator;}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Choose\ error\ tolerances\ to\ force\ some\ uniform\ refinement}}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>min\_permitted\_error()=0.004;}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>max\_permitted\_error()=0.01;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#else}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Build\ "{}bulk"{}\ mesh}}
\DoxyCodeLine{\ Bulk\_mesh\_pt=}
\DoxyCodeLine{\ \ \textcolor{keyword}{new}\ TwoDAnnularMesh<ELEMENT>(periodic,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ azimuthal\_fraction,n\_theta,n\_r,a,h);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}

\end{DoxyCodeInclude}
 Next we create the two (empty) meshes for the {\ttfamily Face\+Elements},

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Pointer\ to\ mesh\ containing\ the\ Helmholtz\ outer\ boundary\ condition}}
\DoxyCodeLine{\ \textcolor{comment}{//\ elements.\ Specify\ outer\ radius\ and\ number\ of\ Fourier\ terms\ to\ be}}
\DoxyCodeLine{\ \textcolor{comment}{//\ used\ in\ gamma\ integral}}
\DoxyCodeLine{\ Helmholtz\_outer\_boundary\_mesh\_pt\ =\ }
\DoxyCodeLine{\ \ \textcolor{keyword}{new}\ HelmholtzDtNMesh<ELEMENT>(a+h,\mbox{\hyperlink{namespaceGlobalParameters_ae4df03bf0ffa55b741ac846ca7b6c155}{GlobalParameters::N\_fourier}});}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Pointer\ to\ mesh\ containing\ the\ Helmholtz\ inner\ boundary\ condition}}
\DoxyCodeLine{\ \textcolor{comment}{//\ elements.\ Specify\ outer\ radius}}
\DoxyCodeLine{\ Helmholtz\_inner\_boundary\_mesh\_pt\ =\ \textcolor{keyword}{new}\ Mesh;}

\end{DoxyCodeInclude}
 and populate them using the functions {\ttfamily create\+\_\+flux\+\_\+elements(...)} and {\ttfamily create\+\_\+outer\+\_\+bc\+\_\+elements(...)}.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ prescribed-\/flux\ elements\ from\ all\ elements\ that\ are\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ adjacent\ to\ the\ inner\ boundary\ ,\ but\ add\ them\ to\ a\ separate\ mesh.}}
\DoxyCodeLine{\ create\_flux\_elements(0,Bulk\_mesh\_pt,Helmholtz\_inner\_boundary\_mesh\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ outer\ boundary\ elements\ from\ all\ elements\ that\ are\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ adjacent\ to\ the\ outer\ boundary\ ,\ but\ add\ them\ to\ a\ separate\ mesh.}}
\DoxyCodeLine{\ create\_outer\_bc\_elements(2,Bulk\_mesh\_pt,Helmholtz\_outer\_boundary\_mesh\_pt);}

\end{DoxyCodeInclude}
 We add the various (sub-\/)meshes to the problem and build the global mesh

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Add\ the\ several\ \ sub\ meshes\ to\ the\ problem}}
\DoxyCodeLine{\ add\_sub\_mesh(Bulk\_mesh\_pt);}
\DoxyCodeLine{\ add\_sub\_mesh(Helmholtz\_outer\_boundary\_mesh\_pt);\ }
\DoxyCodeLine{\ add\_sub\_mesh(Helmholtz\_inner\_boundary\_mesh\_pt);\ \ \ }
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Build\ the\ Problem's\ global\ mesh\ from\ its\ various\ sub-\/meshes}}
\DoxyCodeLine{\ build\_global\_mesh();}

\end{DoxyCodeInclude}
 Finally, we complete the build of the various elements by by passing pointers to the relevant quantities to them, and assign the equation numbers.  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Complete\ the\ build\ of\ all\ elements\ so\ they\ are\ fully\ functional}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Loop\ over\ the\ Helmholtz\ bulk\ elements\ to\ set\ up\ element-\/specific\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ things\ that\ cannot\ be\ handled\ by\ constructor:\ Pass\ pointer\ to\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ wave\ number\ squared}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_element\ =\ Bulk\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ e=0;e<n\_element;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Upcast\ from\ GeneralisedElement\ to\ Helmholtz\ bulk\ element}}
\DoxyCodeLine{\ \ \ ELEMENT\ *el\_pt\ =\ \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt-\/>element\_pt(e));}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Set\ the\ k\_squared\ \ pointer}}
\DoxyCodeLine{\ \ \ el\_pt-\/>k\_squared\_pt()\ =\ \&\mbox{\hyperlink{namespaceGlobalParameters_aae73cb63b27d51a87845c3392cd944eb}{GlobalParameters::K\_squared}};}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ up\ elements\ on\ outer\ boundary}}
\DoxyCodeLine{\ setup\_outer\_boundary();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ pointer\ to\ prescribed\ flux\ function\ for\ flux\ elements}}
\DoxyCodeLine{\ set\_prescribed\_incoming\_flux\_pt();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Setup\ equation\ numbering\ scheme}}
\DoxyCodeLine{\ cout\ <<\textcolor{stringliteral}{"{}Number\ of\ equations:\ "{}}\ <<\ assign\_eqn\_numbers()\ <<\ std::endl;\ }
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ constructor}}

\end{DoxyCodeInclude}
 The problem is now ready to be solved.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_before_adapt}{}\doxysubsection{\texorpdfstring{Actions before adapt}{Actions before adapt}}\label{index_before_adapt}
The mesh adaptation is driven by the error estimates for the bulk elements. The various {\ttfamily Face\+Elements} must therefore be removed from the global mesh before the adaptation takes place. We do this by calling the function {\ttfamily delete\+\_\+flux\+\_\+elements(...)} for the two face meshes, before rebuilding the Problem\textquotesingle{}s global mesh.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====================start\_of\_actions\_before\_adapt======================}}
\DoxyCodeLine{\textcolor{comment}{///\ Actions\ before\ adapt:\ Wipe\ the\ mesh\ of\ face\ elements}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_aca1b756a307f9c1d8a70c7b7e68a296b}{ScatteringProblem<ELEMENT>::actions\_before\_adapt}}()}
\DoxyCodeLine{\{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Kill\ the\ flux\ elements\ and\ wipe\ the\ boundary\ meshs}}
\DoxyCodeLine{\ delete\_face\_elements(Helmholtz\_outer\_boundary\_mesh\_pt);}
\DoxyCodeLine{\ delete\_face\_elements(Helmholtz\_inner\_boundary\_mesh\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Rebuild\ the\ Problem's\ global\ mesh\ from\ its\ various\ sub-\/meshes}}
\DoxyCodeLine{\ rebuild\_global\_mesh();}
\DoxyCodeLine{}
\DoxyCodeLine{\}\textcolor{comment}{//\ end\ of\ actions\_before\_adapt}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_after_adapt}{}\doxysubsection{\texorpdfstring{Actions after adapt}{Actions after adapt}}\label{index_after_adapt}
After the (bulk-\/)mesh has been adapted, the flux elements must be re-\/attached. This is done by calling the functions {\ttfamily create\+\_\+flux\+\_\+elements(...)} and {\ttfamily create\+\_\+outer\+\_\+bc\+\_\+elements}, followed by rebuilding the Problem\textquotesingle{}s global mesh. Finally, we complete the build of the {\ttfamily Face\+Elements} by calling the functions {\ttfamily setup\+\_\+outer\+\_\+boundary()} and {\ttfamily set\+\_\+prescribed\+\_\+incoming\+\_\+flux\+\_\+pt()}.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====================start\_of\_actions\_after\_adapt=======================}}
\DoxyCodeLine{\textcolor{comment}{///\ \ Actions\ after\ adapt:\ Rebuild\ the\ face\ element\ meshes}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_a13d8f85e74666c260de7364917359ed5}{ScatteringProblem<ELEMENT>::actions\_after\_adapt}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ prescribed-\/flux\ elements\ and\ BC\ elements\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ from\ all\ elements\ that\ are\ adjacent\ to\ the\ boundaries\ and\ add\ them\ to\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ Helmholtz\_boundary\_meshes}}
\DoxyCodeLine{\ create\_outer\_bc\_elements(2,Bulk\_mesh\_pt,Helmholtz\_outer\_boundary\_mesh\_pt);}
\DoxyCodeLine{\ create\_flux\_elements(0,Bulk\_mesh\_pt,Helmholtz\_inner\_boundary\_mesh\_pt);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Rebuild\ the\ Problem's\ global\ mesh\ from\ its\ various\ sub-\/meshes}}
\DoxyCodeLine{\ rebuild\_global\_mesh();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ pointer\ to\ prescribed\ flux\ function\ and\ DtN\ mesh}}
\DoxyCodeLine{\ setup\_outer\_boundary();}
\DoxyCodeLine{\ set\_prescribed\_incoming\_flux\_pt();\ }
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\}\textcolor{comment}{//\ end\ of\ actions\_after\_adapt}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_delete}{}\doxysubsection{\texorpdfstring{Delete flux elements}{Delete flux elements}}\label{index_delete}
The helper function {\ttfamily delete\+\_\+face\+\_\+elements()} is used to delete all {\ttfamily Face\+Elements} in a given surface mesh before the mesh adaptation.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_delete\_face\_elements================}}
\DoxyCodeLine{\textcolor{comment}{///\ Delete\ face\ elements\ and\ wipe\ the\ boundary\ mesh}}
\DoxyCodeLine{\textcolor{comment}{//==========================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_aaef8a78e317333ddadd0be6a500c1134}{ScatteringProblem<ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classScatteringProblem_aaef8a78e317333ddadd0be6a500c1134}{delete\_face\_elements}}(Mesh*\ \textcolor{keyword}{const}\ \&\ boundary\_mesh\_pt)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Loop\ over\ the\ surface\ elements}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_element\ =\ boundary\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ e=0;e<n\_element;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Kill\ surface\ element}}
\DoxyCodeLine{\ \ \ \textcolor{keyword}{delete}\ \ boundary\_mesh\_pt-\/>element\_pt(e);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Wipe\ the\ mesh}}
\DoxyCodeLine{\ boundary\_mesh\_pt-\/>flush\_element\_and\_node\_storage();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ delete\_outer\_face\_elements}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_create_flux}{}\doxysubsection{\texorpdfstring{Creating the face elements}{Creating the face elements}}\label{index_create_flux}
The functions {\ttfamily create\+\_\+flux\+\_\+elements(...)} and {\ttfamily create\+\_\+outer\+\_\+bc\+\_\+elements(...)} create the {\ttfamily Face\+Elements} required to apply the boundary conditions on the inner and outer boundaries of the annular computational domain. They both loop over the bulk elements that are adjacent to the appropriate mesh boundary and attach the required {\ttfamily Face\+Elements} to their faces. The newly created {\ttfamily Face\+Elements} are then added to the appropriate mesh.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_create\_outer\_bc\_elements==============================}}
\DoxyCodeLine{\textcolor{comment}{///\ Create\ outer\ BC\ elements\ on\ the\ b-\/th\ boundary\ of\ }\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ the\ Mesh\ object\ pointed\ to\ by\ bulk\_mesh\_pt\ and\ add\ the\ elements\ }}
\DoxyCodeLine{\textcolor{comment}{///\ to\ the\ Mesh\ object\ pointed\ to\ by\ helmholtz\_outer\_boundary\_mesh\_pt.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//===========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_a408e05fbe1f1456ab7013a7e8ab29ccc}{ScatteringProblem<ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classScatteringProblem_a408e05fbe1f1456ab7013a7e8ab29ccc}{create\_outer\_bc\_elements}}(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \&b,\ Mesh*\ \textcolor{keyword}{const}\ \&bulk\_mesh\_pt,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Mesh*\ \textcolor{keyword}{const}\ \&\ helmholtz\_outer\_boundary\_mesh\_pt)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Loop\ over\ the\ bulk\ elements\ adjacent\ to\ boundary\ b?}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_element\ =\ bulk\_mesh\_pt-\/>nboundary\_element(b);}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ e=0;e<n\_element;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Get\ pointer\ to\ the\ bulk\ element\ that\ is\ adjacent\ to\ boundary\ b}}
\DoxyCodeLine{\ \ \ ELEMENT*\ bulk\_elem\_pt\ =\ \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{\ \ \ \ bulk\_mesh\_pt-\/>boundary\_element\_pt(b,e));}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Find\ the\ index\ of\ the\ face\ of\ element\ e\ along\ boundary\ b\ }}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{int}\ face\_index\ =\ bulk\_mesh\_pt-\/>face\_index\_at\_boundary(b,e);}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Build\ the\ corresponding\ outer\ flux\ element}}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Dirichlet\ to\ Neumann\ boundary\ conditon}}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{if}\ (\mbox{\hyperlink{namespaceGlobalParameters_a6e2bba1769e86a5d3db88e2c7062bc63}{GlobalParameters::DtN\_BC}})}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ HelmholtzDtNBoundaryElement<ELEMENT>*\ flux\_element\_pt\ =\ \textcolor{keyword}{new}\ }
\DoxyCodeLine{\ \ \ \ \ \ HelmholtzDtNBoundaryElement<ELEMENT>(bulk\_elem\_pt,face\_index);}
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//Add\ the\ flux\ boundary\ element\ to\ the\ \ helmholtz\_outer\_boundary\_mesh}}
\DoxyCodeLine{\ \ \ \ \ helmholtz\_outer\_boundary\_mesh\_pt-\/>add\_element\_pt(flux\_element\_pt);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ \ ABCs\ BC}}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ HelmholtzAbsorbingBCElement<ELEMENT>*\ flux\_element\_pt\ =\ \textcolor{keyword}{new}\ }
\DoxyCodeLine{\ \ \ \ \ \ HelmholtzAbsorbingBCElement<ELEMENT>(bulk\_elem\_pt,face\_index);}
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//Add\ the\ flux\ boundary\ element\ to\ the\ \ helmholtz\_outer\_boundary\_mesh}}
\DoxyCodeLine{\ \ \ \ \ helmholtz\_outer\_boundary\_mesh\_pt-\/>add\_element\_pt(flux\_element\_pt);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}\ \textcolor{comment}{//end\ of\ loop\ over\ bulk\ elements\ adjacent\ to\ boundary\ b}}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ create\_outer\_bc\_elements}}

\end{DoxyCodeInclude}
 (We omit the listing of the function {\ttfamily create\+\_\+flux\+\_\+elements(...)} because it is very similar. Feel free to inspect in the \href{../../../../demo_drivers/helmholtz/scattering/scattering.cc}{\texttt{ source code.}})

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_doc}{}\doxysubsection{\texorpdfstring{Post-\/processing}{Post-processing}}\label{index_doc}
The post-\/processing function {\ttfamily doc\+\_\+solution(...)} computes and outputs the total radiated power, and plots the computed and exact solutions (real and complex parts).

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====================start\_of\_doc=======================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Doc\ the\ solution:\ doc\_info\ contains\ labels/output\ directory\ etc.}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classScatteringProblem_af83ab14c4f4750ea17c21466f6c6364f}{ScatteringProblem<ELEMENT>::doc\_solution}}(DocInfo\&\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ doc\_info)\ }
\DoxyCodeLine{\{\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ ofstream\ some\_file,some\_file2;}
\DoxyCodeLine{\ \textcolor{keywordtype}{char}\ filename[100];}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Number\ of\ plot\ points}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ npts;}
\DoxyCodeLine{\ npts=5;\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Compute/output\ the\ radiated\ power}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/power\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.number());}
\DoxyCodeLine{\ some\_file.open(filename);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Accumulate\ contribution\ from\ elements}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ power=0.0;}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ nn\_element=Helmholtz\_outer\_boundary\_mesh\_pt-\/>nelement();\ }
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ e=0;e<nn\_element;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ HelmholtzBCElementBase<ELEMENT>\ *el\_pt\ =\ }
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{dynamic\_cast<}\ HelmholtzBCElementBase<ELEMENT>*\textcolor{keyword}{>}(}
\DoxyCodeLine{\ \ \ \ \ Helmholtz\_outer\_boundary\_mesh\_pt-\/>element\_pt(e));\ }
\DoxyCodeLine{\ \ \ power\ +=\ el\_pt-\/>global\_power\_contribution(some\_file);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ some\_file.close();}
\DoxyCodeLine{\ oomph\_info\ <<\ \textcolor{stringliteral}{"{}Total\ radiated\ power:\ "{}}\ <<\ power\ <<\ std::endl;\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Output\ solution\ }}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/soln\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.number());}
\DoxyCodeLine{\ some\_file.open(filename);}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>output(some\_file,npts);}
\DoxyCodeLine{\ some\_file.close();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Output\ exact\ solution\ }}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/exact\_soln\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.number());}
\DoxyCodeLine{\ some\_file.open(filename);}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>output\_fct(some\_file,npts,\mbox{\hyperlink{namespaceGlobalParameters_ae2320da6053f5527b2af5ebb362a8a07}{GlobalParameters::get\_exact\_u}});\ }
\DoxyCodeLine{\ some\_file.close();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ error,norm;}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/error\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.number());}
\DoxyCodeLine{\ some\_file.open(filename);}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>compute\_error(some\_file,\mbox{\hyperlink{namespaceGlobalParameters_ae2320da6053f5527b2af5ebb362a8a07}{GlobalParameters::get\_exact\_u}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ error,norm);\ }
\DoxyCodeLine{\ some\_file.close();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Doc\ L2\ error\ and\ norm\ of\ solution}}
\DoxyCodeLine{\ oomph\_info\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)nNorm\ of\ error\ \ \ :\ "{}}\ <<\ sqrt(error)\ <<\ std::endl;\ }
\DoxyCodeLine{\ oomph\_info\ <<\ \textcolor{stringliteral}{"{}Norm\ of\ solution:\ "{}}\ <<\ sqrt(norm)\ <<\ std::endl\ <<\ std::endl;}

\end{DoxyCodeInclude}
 Finally, we create the data required to produce an animation of the actual (real) potential at 40 instants during a period of the oscillation.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Do\ animation\ of\ Helmholtz\ solution}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ nstep=40;}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ i=0;i<nstep;i++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ sprintf(filename,\textcolor{stringliteral}{"{}\%s/helmholtz\_animation\%i\_frame\%i.dat"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ doc\_info.number(),i);}
\DoxyCodeLine{\ \ \ some\_file.open(filename);}
\DoxyCodeLine{\ \ \ sprintf(filename,\textcolor{stringliteral}{"{}\%s/exact\_helmholtz\_animation\%i\_frame\%i.dat"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ doc\_info.number(),i);}
\DoxyCodeLine{\ \ \ some\_file2.open(filename);}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{double}\ phi=2.0*MathematicalConstants::Pi*double(i)/double(nstep-\/1);}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{unsigned}\ nelem=Bulk\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ e=0;e<nelem;e++)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ ELEMENT*\ el\_pt=\textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{\ \ \ \ \ \ Bulk\_mesh\_pt-\/>element\_pt(e));}
\DoxyCodeLine{\ \ \ \ \ el\_pt-\/>output\_real(some\_file,phi,npts);\ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ el\_pt-\/>output\_real\_fct(some\_file2,phi,npts,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceGlobalParameters_ae2320da6053f5527b2af5ebb362a8a07}{GlobalParameters::get\_exact\_u}});\ }
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ some\_file.close();}
\DoxyCodeLine{\ \ \ some\_file2.close();}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ doc}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comm_ex}{}\doxysection{\texorpdfstring{Comments and Exercises}{Comments and Exercises}}\label{index_comm_ex}
\hypertarget{index_numbering}{}\doxysubsection{\texorpdfstring{The enumeration of the unknowns}{The enumeration of the unknowns}}\label{index_numbering}
As discussed in the introduction, most practically relevant solutions of the Helmholtz equation are complex valued. Since {\ttfamily oomph-\/lib\textquotesingle{}s} solvers only deal with real (double precision) unknowns, the equations are separated into their real and imaginary parts. In the implementation of the Helmholtz elements, we store the real and imaginary parts of the solution as two separate values at each node. By default, the real and imaginary parts are accessible via {\ttfamily Node\+::value(0)} and {\ttfamily Node\+::value(1)}. However, to facilitate the use of the elements in multi-\/physics problems we avoid accessing the unknowns directly in this manner but provide the virtual function 
\begin{DoxyCode}{0}
\DoxyCodeLine{std::complex<unsigned>\ HelmholtzEquations<DIM>::u\_index\_helmholtz()}

\end{DoxyCode}
 which returns a complex number made of the two unsigneds that indicate which nodal value represents the real and imaginary parts of the solution. This function may be overloaded in combined multi-\/physics elements in which a Helmholtz element is combined (by multiple inheritance) with another element, using the strategy described in \href{../../../multi_physics/b_convection/html/index.html}{\texttt{ the Boussinesq convection tutorial}}.

\DoxyHorRuler{0}
\hypertarget{index_ex}{}\doxysubsection{\texorpdfstring{Exercises}{Exercises}}\label{index_ex}
\hypertarget{index_lin}{}\doxysubsubsection{\texorpdfstring{Exploiting linearity}{Exploiting linearity}}\label{index_lin}
Confirm that the (costly) re-\/computation of the $ \gamma $ integral in {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} after the first (and only) linear solve in the Newton iteration can be avoided by declaring the problem to be linear.\hypertarget{index_acc}{}\doxysubsubsection{\texorpdfstring{The accuracy of the boundary condition elements}{The accuracy of the boundary condition elements}}\label{index_acc}
Explore the accuracy (and computational cost) of the various {\ttfamily Face\+Elements} that apply the Sommmerfeld radiation condition. In particular, confirm that the accuracy of the DtN boundary condition is (nearly) independent of the radius of the artificial outer boundary, whereas the accuracy of the ABC boundary condition can only be improved by increasing the size of the computational domain.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{\texorpdfstring{Source files for this tutorial}{Source files for this tutorial}}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/helmholtz/scattering}{\texttt{ demo\+\_\+drivers/helmholtz/scattering/ }} \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/helmholtz/scattering/scattering.cc}{\texttt{ demo\+\_\+drivers/helmholtz/scattering/scattering.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{\texorpdfstring{PDF file}{PDF file}}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
