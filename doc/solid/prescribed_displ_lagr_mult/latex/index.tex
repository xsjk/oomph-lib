\chapter{Demo problem\+: Deformation of a solid by a prescribed boundary motion}
\hypertarget{index}{}\label{index}\index{Demo problem: Deformation of a solid by a prescribed boundary motion@{Demo problem: Deformation of a solid by a prescribed boundary motion}}
The purpose of this tutorial is to demonstrate how to impose the deformation of domain boundaries using Lagrange multipliers. This functionality is required, e.\+g. when using (pseudo-\/)solid mechanics to update the shape of the fluid mesh in fluid-\/structure interaction problems, say. (See \doxysectlink{index_comm_and_ex}{Comments and Exercises}{1} for a discussion of an alternative, somewhat easier method for imposing boundary displacements in single-\/physics solid mechanics problems).

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_model}{}\doxysection{\texorpdfstring{The model problem}{The model problem}}\label{index_model}
Here is a sketch of the model problem. A unit square is parametrised by two Lagrangian coordinates $ (\xi^1,\xi^2) $. Three of the four boundaries are held in a fixed position while the square\textquotesingle{}s upper boundary $ \partial D_{prescr}$ (which is parametrised by the boundary coordinate $ \zeta$) is displaced to a new position given by $ {\bf R}_{prescr}(\zeta) $\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{sketch}
\doxyfigcaption{Sketch of the problem. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_theory}{}\doxysection{\texorpdfstring{Theory and implementation}{Theory and implementation}}\label{index_theory}
We identify the upper boundary by writing the Lagrangian coordinates of points on $ \partial D_{prescr} $ as  \[
\left. \big( \xi^1, \xi^2\big)\right|_{\partial D_{prescr}} = 
\big( \xi^1_{\partial D_{prescr}}(\zeta), 
      \xi^2_{\partial D_{prescr}}(\zeta) \big)
\] which allows us to write the displacement constraint as  \[
{\bf R}(\xi^1_{\partial D_{prescr}}(\zeta),\xi^2_{\partial
D_{prescr}}(\zeta)) = {\bf R}_{prescr}(\zeta).
\] We enforce this constraint by augmenting the principle of virtual displacements, discussed in \href{../../solid_theory/html/index.html\#equilibrium}{\texttt{ the solid mechanics theory tutorial}}, by a Lagrange multiplier term so that it becomes  \[
\int \left\{ \sigma^{ij}  \ \delta \gamma_{ij} -  \left( {\bf f} - 
\Lambda^2 \frac{\partial^2 {\bf R}}{\partial t^2} \right) \cdot 
\delta {\bf R} \right\} \ dv -
\oint_{A_{tract}} {\bf T} \cdot \delta {\bf R} \ dA
\ + \ \delta \Pi_{constraint} = 0
\ \ \ \ \ \ \ \ (1)
\] where  \[
 \Pi_{constraint} = \int_{\partial D} 
\bigg( {\bf R}(\xi^1(\zeta),\xi^2(\zeta)) - {\bf R}_{prescr}(\zeta) \bigg)
\cdot {\bf \Lambda} \ dS.
\] Here  \[ 
dS = \left| \frac{d {\bf R}(\xi^1(\zeta),\xi^2(\zeta))}{d \zeta}
\right| d\zeta 
\] is the differential of the arclength along the domain boundary and the vector $ {\bf \Lambda} $ (not to be confused with the scalar $ \Lambda^2 $ which represents the non-\/dimensional density in (1)!) is the Lagrange multiplier -- the surface traction to be applied to $ \partial D_{prescr} $ to deform the boundary into the required shape.

We discretise this constraint by attaching {\ttfamily Face\+Elements} to the boundaries of the "{}bulk"{} solid elements that are adjacent to $ \partial D_{prescr} $. We denote the number of nodes in these {\ttfamily Face\+Elements} by $ N $ and write the $ i $-\/th component of the discrete Lagrange multiplier stored at node $ j $ as $ L_{ij} $. Thus the $ i $ -\/th component of the Lagrange multiplier at local coordinate $ s $ in the element is given by  \[
\Lambda_i = \sum_{j=1}^{N} L_{ij} \psi_j(s)
\] where $ \psi_j(s) $ is the shape function associated with node $ j $.

Upon taking the variations of the discretised constraint with respect to the unknown nodal positions and the discrete Lagrange multipliers we obtain {\bfseries{(i)}} additional contributions to the residuals of the "{}bulk"{} solid mechanics equations (these may be interpreted as the virtual work done by the boundary tractions required to impose the prescribed boundary displacement) and {\bfseries{(ii)}} the equations that impose the displacement constraints in weak form.

The actual implementation of this approach in {\ttfamily oomph-\/lib} is best thought of as a generalisation of the {\ttfamily Solid\+Traction\+Elements} that are used to impose a prescribed traction to the boundary of a solid domain. The main difference is that in the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Element}, the imposed traction is one of the unknowns in the problem and must be determined via the displacement constraint, using the approach described above. The element introduces additional unknowns (the nodal values of the Lagrange multiplier) into the problem, therefore the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Element} resizes (increases) the number of values stored at the node from the value that was originally assigned by the "{}bulk"{} solid element it is attached to. (If the elements are used in a single-\/physics solid mechanics problem the discrete Lagrange multipliers are the only nodal values in the problem since the unknown nodal positions are stored in a separate {\ttfamily Data} item; cf. \href{../../solid_theory/html/index.html\#solid_node}{\texttt{ "{}\+Solid mechanics\+: Theory and implementation"{}}} for more details). The prescribed boundary shape $ {\bf R}_{prescr}(\zeta) $ is provided by a {\ttfamily Geom\+Object}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_results}{}\doxysection{\texorpdfstring{Results}{Results}}\label{index_results}
The animation below shows the domain deformation in response to a prescribed boundary displacement given by

\[
{\bf R}_{prescr}(\zeta)=
\left(
\begin{array}{c}
\zeta \\
1
\end{array}
\right)
+ A
\left(
\begin{array}{c}
5 \zeta\ (\zeta-1) \ (\zeta-0.7) \\
\frac{1}{2}\left(1-\cos\left(2\pi\zeta\right)\right)  
\end{array}
\right)
\]

With this choice the upper boundary remains flat (i.\+e. at $ x_2=1 $) when $ A=0 $. As $ A $ increases, the boundary is pulled upwards into a sinusoidal shape while simultaneously being pushed to the right. The vectors in the animation represent the Lagrange multipliers (i.\+e. the physical surface tractions) required to deform the domain into the required shape. Note how the automatic mesh adaptation refines the mesh in regions where the solid is strongly deformed.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{lagr_distort}
\doxyfigcaption{Domain deformation in response to the prescribed boundary displacement. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_prescribed_boundary}{}\doxysection{\texorpdfstring{Describing the prescribed boundary motion with a Geom\+Object}{Describing the prescribed boundary motion with a GeomObject}}\label{index_prescribed_boundary}
Here is the implementation of the prescribed boundary shape as the {\ttfamily \doxylink{classWarpedLine}{Warped\+Line}}, a two-\/dimensional {\ttfamily Geom\+Object} whose shape is parametrised by a single intrinsic coordinate.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//======Start\_of\_warped\_line===============================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Warped\ line\ in\ 2D\ space}}
\DoxyCodeLine{\textcolor{comment}{//=========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{class\ }\mbox{\hyperlink{classWarpedLine}{WarpedLine}}\ :\ \textcolor{keyword}{public}\ GeomObject}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Constructor:\ Specify\ amplitude\ of\ deflection\ from\ straight\ horizontal\ line}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classWarpedLine}{WarpedLine}}(\textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ \mbox{\hyperlink{classWarpedLine_aea69e0dccb0af23ffeb8cd98c0aa6853}{ampl}})\ :\ GeomObject(1,2)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{classWarpedLine_ac44286e84ff213e67e0f247d00ad50af}{Ampl}}=\mbox{\hyperlink{classWarpedLine_aea69e0dccb0af23ffeb8cd98c0aa6853}{ampl}};}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Broken\ copy\ constructor}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classWarpedLine}{WarpedLine}}(\textcolor{keyword}{const}\ \mbox{\hyperlink{classWarpedLine}{WarpedLine}}\&\ dummy)\ }
\DoxyCodeLine{\ \ \{\ }
\DoxyCodeLine{\ \ \ BrokenCopy::broken\_copy(\textcolor{stringliteral}{"{}WarpedLine"{}});}
\DoxyCodeLine{\ \ \}\ }
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Broken\ assignment\ operator}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classWarpedLine_ae2ee796906c0caa7e94f277f6fc499e1}{operator=}}(\textcolor{keyword}{const}\ \mbox{\hyperlink{classWarpedLine}{WarpedLine}}\&)\ }
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ BrokenCopy::broken\_assign(\textcolor{stringliteral}{"{}WarpedLine"{}});}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Empty\ Destructor}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classWarpedLine_a4cb07fb7f06d42e2008afe65d8750cad}{\string~WarpedLine}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Position\ vector\ at\ Lagrangian\ coordinate\ zeta\ }}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classWarpedLine_aaeef89818148ee3a305c561e91c8851d}{position}}(\textcolor{keyword}{const}\ Vector<double>\&\ zeta,\ Vector<double>\&\ r)\textcolor{keyword}{\ const}}
\DoxyCodeLine{\textcolor{keyword}{\ \ }\{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Position\ vector}}
\DoxyCodeLine{\ \ \ r[0]\ =\ zeta[0]+5.0*\mbox{\hyperlink{classWarpedLine_ac44286e84ff213e67e0f247d00ad50af}{Ampl}}*zeta[0]*(zeta[0]-\/1.0)*(zeta[0]-\/0.7);}
\DoxyCodeLine{\ \ \ r[1]\ =\ 1.0+\mbox{\hyperlink{classWarpedLine_ac44286e84ff213e67e0f247d00ad50af}{Ampl}}*0.5*(1.0-\/cos(2.0*MathematicalConstants::Pi*zeta[0]));}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Parametrised\ position\ on\ object:\ r(zeta).\ Evaluated\ at}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ previous\ timestep.\ t=0:\ current\ time;\ t>0:\ previous}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ timestep.\ Forward\ to\ steady\ version}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classWarpedLine_aaeef89818148ee3a305c561e91c8851d}{position}}(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ t,\ \textcolor{keyword}{const}\ Vector<double>\&\ zeta,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Vector<double>\&\ r)\textcolor{keyword}{\ const}}
\DoxyCodeLine{\textcolor{keyword}{\ \ }\{}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{classWarpedLine_aaeef89818148ee3a305c561e91c8851d}{position}}(zeta,r);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Access\ to\ amplitude}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{double}\&\ \mbox{\hyperlink{classWarpedLine_aea69e0dccb0af23ffeb8cd98c0aa6853}{ampl}}()\ \{\textcolor{keywordflow}{return}\ \mbox{\hyperlink{classWarpedLine_ac44286e84ff213e67e0f247d00ad50af}{Ampl}};\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ How\ many\ items\ of\ Data\ does\ the\ shape\ of\ the\ object\ depend\ on?}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ None.}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{unsigned}\ \mbox{\hyperlink{classWarpedLine_aa4157cd4ff2e80f33b106b7ed4e4d804}{ngeom\_data}}()\textcolor{keyword}{\ const}}
\DoxyCodeLine{\textcolor{keyword}{\ \ }\{}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Amplitude\ of\ perturbation}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{double}\ \mbox{\hyperlink{classWarpedLine_ac44286e84ff213e67e0f247d00ad50af}{Ampl}};}
\DoxyCodeLine{}
\DoxyCodeLine{\};}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_namespace}{}\doxysection{\texorpdfstring{Global parameters}{Global parameters}}\label{index_namespace}
As usual we define the problem parameters in a global namespace. We provide an instantiation of the {\ttfamily Geom\+Object} that defines the deformed boundary shape (setting its initial displacement amplitude to zero), and create an instance of {\ttfamily oomph-\/lib\textquotesingle{}s} generalised Hookean constitutive equation with a Poisson ratio of 0.\+3 (recall that the use of the single-\/argument constructor for this constitutive equation implies that all stresses are non-\/dimensionalised on Young\textquotesingle{}s modulus $ E $; see \href{../../solid_theory/html/index.html\#non-dim_solid}{\texttt{ the solid mechanics theory tutorial}} for details).

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=======start\_namespace==========================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Global\ parameters}}
\DoxyCodeLine{\textcolor{comment}{//================================================================}}
\DoxyCodeLine{\textcolor{keyword}{namespace\ }\mbox{\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ GeomObject\ specifying\ the\ shape\ of\ the\ boundary:\ Initially\ it's\ flat.}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classWarpedLine}{WarpedLine}}\ \mbox{\hyperlink{namespaceGlobal__Physical__Variables_ab0a184463cbaaa353f2235411adef3c4}{Boundary\_geom\_object}}(0.0);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Poisson's\ ratio}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{double}\ \mbox{\hyperlink{namespaceGlobal__Physical__Variables_a9e06f4ada334a9a911aa8cdcfb3ff30b}{Nu}}=0.3;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Generalised\ Hookean\ constitutive\ equations}}
\DoxyCodeLine{\ GeneralisedHookean\ Constitutive\_law(\&\mbox{\hyperlink{namespaceGlobal__Physical__Variables_a9e06f4ada334a9a911aa8cdcfb3ff30b}{Global\_Physical\_Variables::Nu}});}
\DoxyCodeLine{\ }
\DoxyCodeLine{\}\ \textcolor{comment}{//end\ namespace}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_driver}{}\doxysection{\texorpdfstring{The driver code}{The driver code}}\label{index_driver}
We build an instantiation of the {\ttfamily Problem} class (described below), using nine-\/noded, two-\/dimensional {\ttfamily Refineable\+QPVDElements} to discretise the domain, and document the initial domain shape.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=======start\_of\_main==================================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Driver\ code}}
\DoxyCodeLine{\textcolor{comment}{//======================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{prescribed__displ__lagr__mult_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//Set\ up\ the\ problem}}
\DoxyCodeLine{\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem}{PrescribedBoundaryDisplacementProblem<RefineableQPVDElement<2,3>}}\ >\ problem;}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Doc\ initial\ domain\ shape}}
\DoxyCodeLine{\ problem.\mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_abc58821d6b49cd9773dcd90b240aab6e}{doc\_solution}}();}

\end{DoxyCodeInclude}


We perform a parameter study, increasing the amplitude of the prescribed boundary deflection in small increments, while allowing one mesh adaptation per solution. ~\newline



\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Max.\ number\ of\ adaptations\ per\ solve}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ max\_adapt=1;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Parameter\ incrementation}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ nstep=2;\ }
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ i=0;i<nstep;i++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Increment\ imposed\ boundary\ displacement}}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{namespaceGlobal__Physical__Variables_ab0a184463cbaaa353f2235411adef3c4}{Global\_Physical\_Variables::Boundary\_geom\_object}}.\mbox{\hyperlink{classWarpedLine_aea69e0dccb0af23ffeb8cd98c0aa6853}{ampl}}()+=0.1;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Solve\ the\ problem\ with\ Newton's\ method,\ allowing}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ up\ to\ max\_adapt\ mesh\ adaptations\ after\ every\ solve.}}
\DoxyCodeLine{\ \ \ problem.newton\_solve(max\_adapt);}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Doc\ solution}}
\DoxyCodeLine{\ \ \ problem.\mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_abc58821d6b49cd9773dcd90b240aab6e}{doc\_solution}}();}

\end{DoxyCodeInclude}
 Since the main use of the methodology demonstrated here is in free-\/boundary problems where the solution of the solid problem merely serves to update the nodal positions in response to the prescribed boundary motion, we re-\/set the nodes\textquotesingle{} Lagrangian coordinates to their Eulerian positions after every solve. This makes the deformed configuration stress-\/free and tends to stabilise the computation, allowing larger domain deformations to be computed. We stress, however, that this renders the computed solutions physically meaningless in the sense that the domain shapes no longer represent the solution of the original elasticity problem for which the stress-\/free, undeformed configuration remains unchanged throughout the body\textquotesingle{}s deformation.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ For\ maximum\ stability:\ Reset\ the\ current\ nodal\ positions\ to\ be}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ the\ "{}stress-\/free"{}\ ones\ -\/-\/\ this\ assignment\ means\ that\ the}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ parameter\ study\ no\ longer\ corresponds\ to\ a\ physical\ experiment}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ but\ is\ what\ we'd\ do\ if\ we\ wanted\ to\ use\ the\ solid\ solve}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ to\ update\ a\ fluid\ mesh\ in\ an\ FSI\ problem,\ say.}}
\DoxyCodeLine{\ \ \ problem.\mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_a4fd215944a513b61ff9e9ea328abfa67}{solid\_mesh\_pt}}()-\/>set\_lagrangian\_nodal\_coordinates();}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\}\ \textcolor{comment}{//end\ of\ main}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_problem}{}\doxysection{\texorpdfstring{The Problem class}{The Problem class}}\label{index_problem}
The definition of the {\ttfamily Problem} class follows the usual pattern. We provide an access functions to the bulk mesh, as well as a few private helper functions that attach and detach the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} from the bulk mesh before and after the mesh adaptation.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=============begin\_problem============================================\ }}
\DoxyCodeLine{\textcolor{comment}{///\ Problem\ class\ for\ deformation\ of\ elastic\ block\ by\ prescribed}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ boundary\ motion.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//======================================================================\ }}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class\ }\mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem}{PrescribedBoundaryDisplacementProblem}}\ :\ \textcolor{keyword}{public}\ Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Constructor:}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_ac0c8b47eeb75ba2c618757e6b56e62dc}{PrescribedBoundaryDisplacementProblem}}();}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ function\ (empty)}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_a53e7d18d9d748388160d6c4106f1d493}{actions\_after\_newton\_solve}}()\ \{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ function\ (empty)}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_ad2184bb8d7391da21bec62d4aacf5c20}{actions\_before\_newton\_solve}}()\ \{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Access\ function\ for\ the\ solid\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ ElasticRefineableRectangularQuadMesh<ELEMENT>*\&\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_a4fd215944a513b61ff9e9ea328abfa67}{solid\_mesh\_pt}}()\ }
\DoxyCodeLine{\ \ \{\textcolor{keywordflow}{return}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_a6d2cdbd9ae1077c80831d938bdb72a61}{Solid\_mesh\_pt}};\}\ }
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Actions\ before\ adapt:\ Wipe\ the\ mesh\ of\ Lagrange\ multiplier\ elements}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_a2e9f335e8680b0f2338b579e37e9d38a}{actions\_before\_adapt}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Actions\ after\ adapt:\ Rebuild\ the\ mesh\ of\ Lagrange\ multiplier\ elements}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_aae7225db18ad5c8429c0eb96fa37b585}{actions\_after\_adapt}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Doc\ the\ solution}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_abc58821d6b49cd9773dcd90b240aab6e}{doc\_solution}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Create\ elements\ that\ enforce\ prescribed\ boundary\ motion}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ by\ Lagrange\ multiplilers}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_adf4798f13809f5b2f2be6e3d63421edc}{create\_lagrange\_multiplier\_elements}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Delete\ elements\ that\ enforce\ prescribed\ boundary\ motion}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ by\ Lagrange\ multiplilers}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_a0204ae947ffd18ed3d7690395901a1e8}{delete\_lagrange\_multiplier\_elements}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ solid\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ ElasticRefineableRectangularQuadMesh<ELEMENT>*\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_a6d2cdbd9ae1077c80831d938bdb72a61}{Solid\_mesh\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointers\ to\ meshes\ of\ Lagrange\ multiplier\ elements}}
\DoxyCodeLine{\textcolor{comment}{}\ SolidMesh*\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_abb87cb0933297f449af7ceac7fe2bd77}{Lagrange\_multiplier\_mesh\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ DocInfo\ object\ for\ output}}
\DoxyCodeLine{\textcolor{comment}{}\ DocInfo\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_aef72ea29567df89d82fe93235f1907f8}{Doc\_info}};}
\DoxyCodeLine{\ }
\DoxyCodeLine{\};}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysection{\texorpdfstring{The Problem constructor}{The Problem constructor}}\label{index_constructor}
We start by creating the "{}bulk"{} mesh, discretising the domain with 5x5 elements of the type specified by the class\textquotesingle{}s template argument.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===========start\_of\_constructor=======================================\ }}
\DoxyCodeLine{\textcolor{comment}{///\ Constructor:\ }}
\DoxyCodeLine{\textcolor{comment}{//======================================================================\ }}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_ac0c8b47eeb75ba2c618757e6b56e62dc}{PrescribedBoundaryDisplacementProblem<ELEMENT>::PrescribedBoundaryDisplacementProblem}}()\ }
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ the\ mesh}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ \#\ of\ elements\ in\ x-\/direction}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_x=5;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ \#\ of\ elements\ in\ y-\/direction}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_y=5;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Domain\ length\ in\ x-\/direction}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ l\_x=1.0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Domain\ length\ in\ y-\/direction}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ l\_y=1.0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Now\ create\ the\ mesh\ }}
\DoxyCodeLine{\ solid\_mesh\_pt()\ =\ \textcolor{keyword}{new}\ ElasticRefineableRectangularQuadMesh<ELEMENT>(}
\DoxyCodeLine{\ \ n\_x,n\_y,l\_x,l\_y);}

\end{DoxyCodeInclude}
 Next we specify the error estimator, pass the pointer to the constitutive equation to the elements and perform one uniform mesh refinement\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ error\ estimator}}
\DoxyCodeLine{\ solid\_mesh\_pt()-\/>spatial\_error\_estimator\_pt()=\textcolor{keyword}{new}\ Z2ErrorEstimator;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Assign\ the\ physical\ properties\ to\ the\ elements\ before\ any\ refinement}}
\DoxyCodeLine{\ \textcolor{comment}{//Loop\ over\ the\ elements\ in\ the\ main\ mesh}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_element\ =solid\_mesh\_pt()-\/>nelement();}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ i=0;i<n\_element;i++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Cast\ to\ a\ solid\ element}}
\DoxyCodeLine{\ \ \ ELEMENT\ *el\_pt\ =\ \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(solid\_mesh\_pt()-\/>element\_pt(i));}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Set\ the\ constitutive\ law}}
\DoxyCodeLine{\ \ \ el\_pt-\/>constitutive\_law\_pt()=\&Global\_Physical\_Variables::Constitutive\_law;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Refine\ the\ mesh\ uniformly}}
\DoxyCodeLine{\ solid\_mesh\_pt()-\/>refine\_uniformly();}

\end{DoxyCodeInclude}
 We now create a new {\ttfamily Solid\+Mesh} in which we store the elements that apply the displacement constraint. These elements are built (and added to the newly created {\ttfamily Solid\+Mesh}) in the helper function {\ttfamily create\+\_\+lagrange\+\_\+multiplier\+\_\+elements()}. Both meshes are then combined to the {\ttfamily Problem\textquotesingle{}s} global mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Construct\ the\ mesh\ of\ elements\ that\ enforce\ prescribed\ boundary\ motion}}
\DoxyCodeLine{\ \textcolor{comment}{//\ by\ Lagrange\ multipliers}}
\DoxyCodeLine{\ Lagrange\_multiplier\_mesh\_pt=\textcolor{keyword}{new}\ SolidMesh;}
\DoxyCodeLine{\ create\_lagrange\_multiplier\_elements();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Solid\ mesh\ is\ first\ sub-\/mesh}}
\DoxyCodeLine{\ add\_sub\_mesh(solid\_mesh\_pt());}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Add\ Lagrange\ multiplier\ sub-\/mesh}}
\DoxyCodeLine{\ add\_sub\_mesh(Lagrange\_multiplier\_mesh\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Build\ combined\ "{}global"{}\ mesh}}
\DoxyCodeLine{\ build\_global\_mesh();}

\end{DoxyCodeInclude}
 We pin the position of the nodes on all domain boundaries apart from the top boundary (boundary 2) and pin any redundant pressure degrees of freedom. (This is not strictly necessary in the present driver code since the displacement-\/based {\ttfamily Refineable\+QPVDElements} do not have any pressure degrees of freedom. However, it is good practice to do this anyway to guard against unpleasant surprises when the element type is changed at some point).


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Pin\ nodal\ positions\ on\ all\ boundaries\ apart\ from\ the\ top\ one\ (2)\ }}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ b=0;b<4;b++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{if}\ (b!=2)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \textcolor{keywordtype}{unsigned}\ n\_side\ =\ solid\_mesh\_pt()-\/>nboundary\_node(b);}
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//Loop\ over\ the\ nodes}}
\DoxyCodeLine{\ \ \ \ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ i=0;i<n\_side;i++)}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ solid\_mesh\_pt()-\/>boundary\_node\_pt(b,i)-\/>pin\_position(0);}
\DoxyCodeLine{\ \ \ \ \ \ \ solid\_mesh\_pt()-\/>boundary\_node\_pt(b,i)-\/>pin\_position(1);}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Pin\ the\ redundant\ solid\ pressures\ (if\ any)}}
\DoxyCodeLine{\ PVDEquationsBase<2>::pin\_redundant\_nodal\_solid\_pressures(}
\DoxyCodeLine{\ \ solid\_mesh\_pt()-\/>element\_pt());}

\end{DoxyCodeInclude}
 Finally, we assign the equation numbers and specify the output directory.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Setup\ equation\ numbering\ scheme}}
\DoxyCodeLine{\ cout\ <<\ \textcolor{stringliteral}{"{}Number\ of\ dofs:\ "{}}\ <<\ assign\_eqn\_numbers()\ <<\ std::endl;\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ output\ directory}}
\DoxyCodeLine{\ Doc\_info.set\_directory(\textcolor{stringliteral}{"{}RESLT"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//end\ of\ constructor}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_actions_before_adapt}{}\doxysection{\texorpdfstring{Actions before mesh adaptation}{Actions before mesh adaptation}}\label{index_actions_before_adapt}
As usual, we remove the {\ttfamily Face\+Elements} that apply the displacement constraints before the bulk mesh is adapted.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====================start\_of\_actions\_before\_adapt======================}}
\DoxyCodeLine{\textcolor{comment}{///\ Actions\ before\ adapt:\ Wipe\ the\ mesh\ of\ elements\ that\ impose}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ the\ prescribed\ boundary\ displacements}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_a2e9f335e8680b0f2338b579e37e9d38a}{PrescribedBoundaryDisplacementProblem<ELEMENT>::actions\_before\_adapt}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Kill\ the\ \ elements\ and\ wipe\ surface\ mesh}}
\DoxyCodeLine{\ delete\_lagrange\_multiplier\_elements();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Rebuild\ the\ Problem's\ global\ mesh\ from\ its\ various\ sub-\/meshes}}
\DoxyCodeLine{\ rebuild\_global\_mesh();}
\DoxyCodeLine{}
\DoxyCodeLine{\}\textcolor{comment}{//\ end\ of\ actions\_before\_adapt}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_actions_after_adapt}{}\doxysection{\texorpdfstring{Actions after mesh adaptation}{Actions after mesh adaptation}}\label{index_actions_after_adapt}
We re-\/attach the {\ttfamily Face\+Elements} that apply the displacement constraints once the bulk mesh has been adapted. Since the hanging status of nodes in the bulk mesh can change during the mesh adaptation it is again good practice to pin any nodal solid pressure values that may have become redundant.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====================start\_of\_actions\_after\_adapt=======================}}
\DoxyCodeLine{\textcolor{comment}{///\ \ Actions\ after\ adapt:\ Rebuild\ the\ mesh\ of\ elements\ that\ impose}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ the\ prescribed\ boundary\ displacements}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_aae7225db18ad5c8429c0eb96fa37b585}{PrescribedBoundaryDisplacementProblem<ELEMENT>::actions\_after\_adapt}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ the\ elements\ that\ impose\ the\ displacement\ constraint\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ and\ attach\ them\ to\ the\ bulk\ elements\ that\ are}}
\DoxyCodeLine{\ \textcolor{comment}{//\ adjacent\ to\ boundary\ 2\ }}
\DoxyCodeLine{\ create\_lagrange\_multiplier\_elements();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Rebuild\ the\ Problem's\ global\ mesh\ from\ its\ various\ sub-\/meshes}}
\DoxyCodeLine{\ rebuild\_global\_mesh();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Pin\ the\ redundant\ solid\ pressures\ (if\ any)}}
\DoxyCodeLine{\ PVDEquationsBase<2>::pin\_redundant\_nodal\_solid\_pressures(}
\DoxyCodeLine{\ \ solid\_mesh\_pt()-\/>element\_pt());}
\DoxyCodeLine{\ }
\DoxyCodeLine{\}\textcolor{comment}{//\ end\ of\ actions\_after\_adapt}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_lagr_elements}{}\doxysection{\texorpdfstring{Creating the Lagrange multiplier elements that impose the displacement constraint}{Creating the Lagrange multiplier elements that impose the displacement constraint}}\label{index_lagr_elements}
The creation of the Lagrange multiplier elements that impose the displacement constraint follows the usual pattern. We loop over the "{}bulk"{} solid elements that are adjacent to mesh boundary 2 and attach {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} to the appropriate faces.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_create\_lagrange\_multiplier\_elements===============}}
\DoxyCodeLine{\textcolor{comment}{///\ Create\ elements\ that\ impose\ the\ prescribed\ boundary\ displacement}}
\DoxyCodeLine{\textcolor{comment}{//=======================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_adf4798f13809f5b2f2be6e3d63421edc}{PrescribedBoundaryDisplacementProblem<ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_adf4798f13809f5b2f2be6e3d63421edc}{create\_lagrange\_multiplier\_elements}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Lagrange\ multiplier\ elements\ are\ located\ on\ boundary\ 2:}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ b=2;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ How\ many\ bulk\ elements\ are\ adjacent\ to\ boundary\ b?}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_element\ =\ solid\_mesh\_pt()-\/>nboundary\_element(b);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Loop\ over\ the\ bulk\ elements\ adjacent\ to\ boundary\ b?}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ e=0;e<n\_element;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Get\ pointer\ to\ the\ bulk\ element\ that\ is\ adjacent\ to\ boundary\ b}}
\DoxyCodeLine{\ \ \ ELEMENT*\ bulk\_elem\_pt\ =\ \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{\ \ \ \ solid\_mesh\_pt()-\/>boundary\_element\_pt(b,e));}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Find\ the\ index\ of\ the\ face\ of\ element\ e\ along\ boundary\ b}}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{int}\ face\_index\ =\ solid\_mesh\_pt()-\/>face\_index\_at\_boundary(b,e);}
\DoxyCodeLine{\ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Create\ new\ element\ and\ add\ to\ mesh}}
\DoxyCodeLine{\ \ \ Lagrange\_multiplier\_mesh\_pt-\/>add\_element\_pt(}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{new}\ ImposeDisplacementByLagrangeMultiplierElement<ELEMENT>(}
\DoxyCodeLine{\ \ \ \ \ bulk\_elem\_pt,face\_index));\ \ \ }
\DoxyCodeLine{\ \ \}\ \ }

\end{DoxyCodeInclude}
 Next we loop over the newly-\/created ~\newline
 {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} and specify the {\ttfamily Geom\+Object} that defines the imposed boundary displacements. We also specify which boundary of the bulk mesh the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} are located on. This is required to enable the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} to extract the appropriate boundary coordinate from its constituent nodes. (We discussed \href{../../../poisson/fish_poisson2/html/index.html\#boundary_coords}{\texttt{ elsewhere}} that boundary coordinates are usually defined (and passed to the nodes) when the nodes are first created, typically during the construction of the bulk mesh. Since nodes can be located on multiple domain boundaries, each boundary coordinate is associated with a particular boundary number. Passing this number to the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} allows them to obtain the correct boundary coordinate from the node.)


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Loop\ over\ the\ elements\ in\ the\ Lagrange\ multiplier\ element\ mesh}}
\DoxyCodeLine{\ \textcolor{comment}{//\ for\ elements\ on\ the\ top\ boundary\ (boundary\ 2)}}
\DoxyCodeLine{\ n\_element=Lagrange\_multiplier\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ i=0;i<n\_element;i++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Cast\ to\ a\ Lagrange\ multiplier\ element}}
\DoxyCodeLine{\ \ \ ImposeDisplacementByLagrangeMultiplierElement<ELEMENT>\ *el\_pt\ =\ }
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{dynamic\_cast<}ImposeDisplacementByLagrangeMultiplierElement<ELEMENT>*\textcolor{keyword}{>}}
\DoxyCodeLine{\ \ \ \ (Lagrange\_multiplier\_mesh\_pt-\/>element\_pt(i));}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Set\ the\ GeomObject\ that\ defines\ the\ boundary\ shape\ and}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ specify\ which\ bulk\ boundary\ we\ are\ attached\ to\ (needed\ to\ extract}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ the\ boundary\ coordinate\ from\ the\ bulk\ nodes)}}
\DoxyCodeLine{\ \ \ el\_pt-\/>set\_boundary\_shape\_geom\_object\_pt(\ }
\DoxyCodeLine{\ \ \ \ \&\mbox{\hyperlink{namespaceGlobal__Physical__Variables_ab0a184463cbaaa353f2235411adef3c4}{Global\_Physical\_Variables::Boundary\_geom\_object}},b);}

\end{DoxyCodeInclude}


Finally, we impose boundary conditions for the Lagrange multipliers. Their values must be pinned (and set to zero) at the left and right ends of the upper mesh boundary (boundary 2), since the displacement of the nodes at these points is already enforced by the boundary conditions imposed at the left and right vertical boundaries (boundaries 1 and 3).

\label{index_bcs_for_lagrange_multipliers}%
\Hypertarget{index_bcs_for_lagrange_multipliers}%
 We discussed above that the discrete Lagrange multipliers are added to any already existing nodal degrees of freedom when the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} are attached to the faces of the "{}bulk"{} solid elements. The number of nodal values that were stored at an element\textquotesingle{}s {\ttfamily j} -\/th node before the additional nodal values were added, can be obtained from the function {\ttfamily nbulk\+\_\+value(j)}, defined in the {\ttfamily Face\+Element} base class. We pin the Lagrange multipliers at the "{}corner nodes"{} by looping over all nodes in the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} and pinning the additional nodal values of any nodes that are located on mesh boundaries 1 or 3.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Loop\ over\ the\ nodes\ }}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{unsigned}\ nnod=el\_pt-\/>nnode();}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ j=0;j<nnod;j++)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ Node*\ nod\_pt\ =\ el\_pt-\/>node\_pt(j);}
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ Is\ the\ node\ also\ on\ boundary\ 1\ or\ 3?}}
\DoxyCodeLine{\ \ \ \ \ \textcolor{keywordflow}{if}\ ((nod\_pt-\/>is\_on\_boundary(1))||(nod\_pt-\/>is\_on\_boundary(3)))}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{comment}{//\ How\ many\ nodal\ values\ were\ used\ by\ the\ "{}bulk"{}\ element}}
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{comment}{//\ that\ originally\ created\ this\ node?}}
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{keywordtype}{unsigned}\ n\_bulk\_value=el\_pt-\/>nbulk\_value(j);}
\DoxyCodeLine{\ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{comment}{//\ The\ remaining\ ones\ are\ Lagrange\ multipliers\ and\ we\ pin\ them.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{keywordtype}{unsigned}\ nval=nod\_pt-\/>nvalue();}
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ j=n\_bulk\_value;j<nval;j++)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ nod\_pt-\/>pin(j);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ create\_lagrange\_multiplier\_elements}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_kill_lagr_elements}{}\doxysection{\texorpdfstring{Deleting the Lagrange multiplier elements that impose the displacement constraint}{Deleting the Lagrange multiplier elements that impose the displacement constraint}}\label{index_kill_lagr_elements}
The function {\ttfamily delete\+\_\+lagrange\+\_\+multiplier\+\_\+elements()} deletes the Lagrange multiplier elements that impose the displacement constraint and flushes the associated mesh.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//====start\_of\_delete\_lagrange\_multiplier\_elements=======================}}
\DoxyCodeLine{\textcolor{comment}{///\ Delete\ elements\ that\ impose\ the\ prescribed\ boundary\ displacement}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ and\ wipe\ the\ associated\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//=======================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_a0204ae947ffd18ed3d7690395901a1e8}{PrescribedBoundaryDisplacementProblem<ELEMENT>::delete\_lagrange\_multiplier\_elements}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ How\ many\ surface\ elements\ are\ in\ the\ surface\ mesh}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_element\ =\ Lagrange\_multiplier\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Loop\ over\ the\ surface\ elements}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ e=0;e<n\_element;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Kill\ surface\ element}}
\DoxyCodeLine{\ \ \ \textcolor{keyword}{delete}\ Lagrange\_multiplier\_mesh\_pt-\/>element\_pt(e);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Wipe\ the\ mesh}}
\DoxyCodeLine{\ Lagrange\_multiplier\_mesh\_pt-\/>flush\_element\_and\_node\_storage();}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ delete\_lagrange\_multiplier\_elements}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_doc}{}\doxysection{\texorpdfstring{Post-\/processing}{Post-processing}}\label{index_doc}
The function {\ttfamily doc\+\_\+solution()} outputs the shape of the deformed body and the Lagrange multiplier along the upper boundary.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==============start\_doc===========================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Doc\ the\ solution}}
\DoxyCodeLine{\textcolor{comment}{//==================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classPrescribedBoundaryDisplacementProblem_abc58821d6b49cd9773dcd90b240aab6e}{PrescribedBoundaryDisplacementProblem<ELEMENT>::doc\_solution}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ ofstream\ some\_file;}
\DoxyCodeLine{\ \textcolor{keywordtype}{char}\ filename[100];}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Number\ of\ plot\ points}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_plot\ =\ 5;\ }
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Output\ shape\ of\ deformed\ body}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/soln\%i.dat"{}},Doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ Doc\_info.number());}
\DoxyCodeLine{\ some\_file.open(filename);}
\DoxyCodeLine{\ solid\_mesh\_pt()-\/>output(some\_file,n\_plot);}
\DoxyCodeLine{\ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Output\ Lagrange\ multipliers}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/lagr\%i.dat"{}},Doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ Doc\_info.number());}
\DoxyCodeLine{\ some\_file.open(filename);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ This\ makes\ sure\ the\ elements\ are\ ordered\ in\ same\ way\ every\ time}}
\DoxyCodeLine{\ \textcolor{comment}{//\ the\ code\ is\ run\ -\/-\/\ necessary\ for\ validation\ tests.}}
\DoxyCodeLine{\ std::vector<FiniteElement*>\ el\_pt;}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ nelem=Lagrange\_multiplier\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ e=0;e<nelem;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ el\_pt.push\_back(Lagrange\_multiplier\_mesh\_pt-\/>finite\_element\_pt(e));}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ std::sort(el\_pt.begin(),el\_pt.end(),\mbox{\hyperlink{classFiniteElementComp}{FiniteElementComp}}());}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ e=0;e<nelem;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ el\_pt[e]-\/>output(some\_file);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Increment\ label\ for\ output\ files}}
\DoxyCodeLine{\ Doc\_info.number()++;}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//end\ doc}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comm_and_ex}{}\doxysection{\texorpdfstring{Comments and Exercises}{Comments and Exercises}}\label{index_comm_and_ex}
\hypertarget{index_comm}{}\doxysubsection{\texorpdfstring{Comments}{Comments}}\label{index_comm}
As mentioned in the introduction, there is an alternative, much simpler way of imposing prescribed boundary motions which does not require Lagrange multipliers\+: Pin the nodal positions of all nodes on $ \partial D_{prescr} $ and update their positions manually before calling the Newton solver, e.\+g. by changing the {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+solve()} function to

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ boundary\ position\ directly}}
\DoxyCodeLine{\ \textcolor{keywordtype}{void}\ actions\_before\_newton\_solve()}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Loop\ over\ all\ nodes\ on\ top\ boundary\ (boundary\ 2)}}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{unsigned}\ b=2;}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{unsigned}\ n\_nod\ =\ solid\_mesh\_pt()-\/>nboundary\_node(b);}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ i=0;i<n\_nod;i++)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ Node*\ nod\_pt=\ solid\_mesh\_pt()-\/>boundary\_node\_pt(b,i);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ Get\ boundary\ coordinate\ associated\ with\ boundary\ 2}}
\DoxyCodeLine{\ \ \ \ \ Vector<double>\ zeta(1);}
\DoxyCodeLine{\ \ \ \ \ nod\_pt-\/>get\_coordinates\_on\_boundary(b,zeta);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ Get\ prescribed\ position\ from\ GeomObject}}
\DoxyCodeLine{\ \ \ \ \ Vector<double>\ r(2);}
\DoxyCodeLine{\ \ \ \ \ \mbox{\hyperlink{namespaceGlobal__Physical__Variables_ab0a184463cbaaa353f2235411adef3c4}{Global\_Physical\_Variables::Boundary\_geom\_object}}.\mbox{\hyperlink{classWarpedLine_aaeef89818148ee3a305c561e91c8851d}{position}}(zeta,r);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ Update\ position}}
\DoxyCodeLine{\ \ \ \ \ nod\_pt-\/>x(0)=r[0];}
\DoxyCodeLine{\ \ \ \ \ nod\_pt-\/>x(1)=r[1];}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \}\ \textcolor{comment}{//\ end\ actions\_before\_newton\_solve}}

\end{DoxyCodeInclude}
 This approach is implemented in the alternative driver code \href{../../../../demo_drivers/solid/prescribed_displ_lagr_mult/prescribed_displ_lagr_mult2.cc}{\texttt{ prescribed\+\_\+displ\+\_\+lagr\+\_\+mult2.\+cc}}. ~\newline
\hypertarget{index_ex}{}\doxysubsection{\texorpdfstring{Exercises}{Exercises}}\label{index_ex}

\begin{DoxyEnumerate}
\item In order to familiarise yourself with the details of how {\ttfamily Face\+Elements} add additional nodal values to the nodes they are attached to, output the values of {\ttfamily n\+\_\+bulk\+\_\+value} and {\ttfamily nval} in the loop that pins the Lagrange multipliers in {\ttfamily create\+\_\+lagrange\+\_\+multiplier\+\_\+elements()}. Explain why, for the {\ttfamily Refineable\+QPVDElement$<$2,3$>$} used here, we have {\ttfamily n\+\_\+bulk\+\_\+value} = 0. What happens if you use elements of type {\ttfamily Refineable\+QPVDElement\+With\+Continous\+Pressure$<$2$>$} instead? ~\newline
~\newline

\item Comment out the call to {\ttfamily set\+\_\+lagrangian\+\_\+nodal\+\_\+coordinates()} after the solve and compare the robustness of the computation and the resulting domain shapes. \mbox{[}Hint\+: You will have to reduce the increment for the amplitude of the prescribed boundary deflection to 0.\+025 or less, otherwise the Newton iteration will diverge very rapidly.\mbox{]} ~\newline
~\newline

\item Explore the performance of the alternative driver code (without the use of Lagrange multipliers) \href{../../../../demo_drivers/solid/prescribed_displ_lagr_mult/prescribed_displ_lagr_mult2.cc}{\texttt{ prescribed\+\_\+displ\+\_\+lagr\+\_\+mult2.\+cc}} and explain why it is less robust than the version with Lagrange multipliers (in the sense that the increment in the amplitude of the prescribed boundary displacement has to be reduced significantly to keep the Newton method from diverging). Hint\+: Compare the domain shapes before the call to the Newton solver. ~\newline
~\newline

\item Omit the specification of the boundary number in the bulk mesh by commenting out the call to {\ttfamily set\+\_\+boundary\+\_\+number\+\_\+in\+\_\+bulk\+\_\+mesh(...)} in the function {\ttfamily create\+\_\+lagrange\+\_\+multiplier\+\_\+elements()}. Check what happens when the code is compiled with and without the {\ttfamily PARANOID} flag.
\end{DoxyEnumerate}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{\texorpdfstring{PDF file}{PDF file}}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
