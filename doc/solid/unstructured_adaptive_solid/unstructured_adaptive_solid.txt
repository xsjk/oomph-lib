\mainpage Demo problem: Solid Mechanics using unstructured meshes with adaptivity

The purpose of this tutorial is to demonstrate the adaptive solution of
solid mechanics problems using unstructured meshes generated by \c oomph-lib's 
<a href="../../../../doc/meshes/mesh_from_inline_triangle/html/index.html">
inline unstructured mesh generation </a> procedures. The use of these
methods for solid mechanics problems required no additional effort 
on the part of the user and the setup is essentially the same as that
described for <a href="../../unstructured_solid/html/index.html">
unstructured solid mechanics without mesh adaptation. </a>
Lagrangian coordinates are projected
between meshes in the same way as all other field variables, Eulerian
coordinates and history values, see the description in
 <a href="../../../meshes/mesh_from_inline_triangle/html/index.html"> 
another tutorial. </a>

The solid mechanics problem described here can be regarded as a
sub-problem for the  
<a href="../../../../doc/interaction/unstructured_adaptive_fsi/html/index.html">
unstructured adaptive fluid--structure interaction tutorial.</a> In
addition, we can use the problem to assess the 
errors incurred when projecting the solution between different meshes.
 
<HR>
<HR>

\section problem The problem 
An elastic bar is fixed at the base and 
loaded by a constant pressure on its left-hand
side. The pressure load is increased and then decreased so that at the
end of the simulation the bar should return to its undeformed
position. The strain energy in the final configuration is a measure of
the projection error because if there were no projection at all it
would be exactly zero (or certainly zero to less than machine precision).

@I w 0.75\textwidth  solid_sketch "Sketch of the problem. "

<HR>
<HR>

\section results Results
The animation shown below illustrates the solid's deformation and
illustrates the adaptation of the mesh as the load changes.

@I w 0.75\textwidth solid_res "Plot of the deformation. "

The initial strain energy is \f$ O(10^{-28}) \f$, and the strain
energy in the final configuration after the external pressure has been
reset to zero, but the mesh has been adapted, is \f$ O(10^{-8})
\f$. The strain energy at the maximum deflection is \f$ O(10^{-3}) \f$.

<HR>
<HR>

\section namespace Global Physical Variables
We define the various physical variables in a 
global namespace. We define Poisson's ratio and 
prepare a pointer to a constitutive equation.

\dontinclude unstructured_adaptive_solid.cc
\skipline start_namespace
\until Constitutive_law_pt

Next we define the pressure load to be applied at the left-hand boundary,

\until end namespace

<HR>
<HR>

\section main The driver code

The driver code consists of essentially the same code repeated for three
different formulations of solid mechanics: (i) (compressible) 
displacement only; (ii) (compressible) displacement-pressure; and
(iii) incompressible displacement-pressure. We shall describe
the code only for the first formulation.

Initially, we specify an output directory
and instantiate a constitutive equation. (Recall that the
single-argument constructor to the \c GeneralisedHookean
constitutive law implies that all stresses are non-dimensionalised
on Young's modulus \f$ E \f$).

\dontinclude unstructured_adaptive_solid.cc
\skipline start_main
\until ::Nu);

We then open an output file for the strain energy, create 
the \c Problem object using a displacement formulation of
the equations and output the initial configuration.

\until ()++

Finally, we perform the parameter study by slowly increasing and then
reducing the pressure on the left-hand boundary. Note that one round
of mesh adaptation is specified for every Newton solve.

\until end_displacement_formulation

<HR>
<HR>

\section class The Problem class
The \c Problem class has the obvious member functions as well as a
function to set whether the material is incompressible and a function
to compute the strain energy of the elastic body. The class provides
storage for the two sub-meshes: the bulk mesh of 2D solid elements
and the mesh of 1D traction elements that will be attached to the 
left-hand boundary. In addition, storage is provided for the polygon that
represents the initial outer boundary of the solid body and a boolean
flag that is used to specify whether the material is incompressible or not.

\dontinclude unstructured_adaptive_solid.cc
\skipline start_problem
\until };

<HR>
<HR>

\section constructor The Problem constructor

 We begin by building the closed, piecewise linear 
 boundary of the undeformed solid body \f$ x_{1} \in [0,1] \f$, \f$
 x_{2} \in [0,5]. \f$ The boundaries are labelled anticlockwise with
 boundary with the left-hand boundary being boundary 0, see the sketch
 above. This process is a simplified version of the construction used in 
<a href="../../../../doc/meshes/mesh_from_inline_triangle/html/index.html">
another tutorial. </a> 

\dontinclude unstructured_adaptive_solid.cc
\skipline start_constructor
\until triangle_mesh_parameters)

We next construct an error estimator and
specify the target errors and element sizes.

\until min_element_size()

 We output the boundaries, construct an empty traction
 mesh and combine the bulk and traction meshes into a global mesh.

\until build_global_mesh()

 Finally we call  \c actions_after_adapt(), which constructs the
 traction elements, sets the boundary conditions and completes the build
 of the elements, and then we assign the equation numbers

\until end constructor

<HR>
<HR>

\section adapt_after Actions before adaptation

 The \c actions_before_adapt() function simply deletes the traction
 elements and clears the storage in the face mesh.

\dontinclude unstructured_adaptive_solid.cc
\skipline start_actions_before
\until end_actions_before

<HR>
<HR>

\section adapt_after Actions after adaptation

 The function \c actions_after_adapt() first builds the traction
 elements adjacent to the left-hand boundary (boundary 0) and rebuilds
 the global mesh. The \c constant_pressure() load function is passed
 to each of the traction elements.

\until rebuild_global_mesh()

 Next, the boundary conditions of a fixed base (boundary 3) are
 set. These must be reset every time after an adaptation because
 completely new nodes are generated.

\until End of set boundary

 Finally, the constitutive law and, if required, incompressibility
 flag are passed to the bulk (solid) elements. Again, this must be
 performed after every adaptation because a completely new mesh is
 generated.

\until end_actions_after

<HR>
<HR>

\section strain Computation of the strain energy

 The strain energy is computed by looping over all elements in the
 bulk mesh and adding their contributions to the  potential (strain)
 energy.
 
\dontinclude unstructured_adaptive_solid.cc
\skipline start_get_strain
\until end_get_strain 

<HR>
<HR>

\section doc Post-processing

The post-processing routine outputs the deformed domain shape
and the applied traction. In the spirit of continuing paranoia
we also document the domain boundaries. It is exactly the same as in
the related <a href="../../unstructured_solid/html/index.html">
non-adaptive unstructured solid tutorial. </a>


<HR>
<HR>

\section comm_ex Comments and Exercises

\subsection ex Exercises

-# Examine the changes in strain energy under variations in mesh
   refinement tolerances and number of intermediate steps between the
   undeformed and maximally deformed states.
-# What happens if the Lagrangian coordinates are reset after every
   adaptation? Why?
-# Modify the problem so that compression is from the upper surface,
   rather than the left-hand side. What happens when the material is
   incompressible?

<HR>
<HR>

\section sources Source files for this tutorial
- The source files for this tutorial are located in the directory:\n\n
<CENTER>
<A HREF="../../../../demo_drivers/solid/unstructured_adaptive_solid/">
demo_drivers/solid/unstructured_adaptive_solid/
</A>
</CENTER>\n
- The driver codes are: \n\n
<CENTER>
<A HREF="../../../../demo_drivers/solid/unstructured_adaptive_solid/unstructured_adaptive_solid.cc">
demo_drivers/solid/unstructured_solid/unstructured_adaptive_solid.cc
</A>
</CENTER>
.










