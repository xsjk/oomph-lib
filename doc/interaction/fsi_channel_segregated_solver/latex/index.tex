\chapter{Segregated solvers for fluid-\/structure-\/interaction problems\+: Revisiting the flow in a 2D collapsible channel}
\hypertarget{index}{}\label{index}\index{Segregated solvers for fluid-\/structure-\/interaction problems: Revisiting the flow in a 2D collapsible channel@{Segregated solvers for fluid-\/structure-\/interaction problems: Revisiting the flow in a 2D collapsible channel}}
In this document we discuss the implementation of segregated solution strategies for multi-\/physics problems, in particular fluid-\/structure interaction, within {\ttfamily oomph-\/lib}. The method illustrated by revisiting the fluid-\/structure interaction problem of \href{../../fsi_collapsible_channel/html/index.html}{\texttt{ finite-\/\+Reynolds-\/number flow in a 2D collapsible channel;}} an example discussed in detail in \begin{center} \href{http://www.springerlink.com/content/m3r6318701g338g4/}{\texttt{ Heil, M., Hazel, A.\+L. \& Boyle, J. (2008)\+: Solvers for large-\/displacement fluid-\/structure interaction problems\+: Segregated vs. monolithic approaches. Computational Mechanics.}} \end{center} 

where we compare the relative performance of segregated and monolithic solvers. Since the paper comes to the conclusion that, despite various claims in the literature, segregated solvers are not necessarily more efficient than fully-\/coupled monolithic schemes (of the type employed in {\ttfamily oomph-\/lib}) you should also consult the \href{../../../preconditioners/fsi/html/index.html}{\texttt{ related tutorial on the monolithic solution of the problem with {\ttfamily oomph-\/lib\textquotesingle{}s} FSI preconditioner.}}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_problem}{}\doxysection{\texorpdfstring{The problem}{The problem}}\label{index_problem}
\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{Flow in a 2D collapsible channel }} \end{center} 

The figure below shows a sketch of the problem\+: Flow is driven by a prescribed Poiseuille flow $U^{*}_{p}$ through a 2D channel of width $ H^* $ and total length $ L^*_{total} = L^*_{up} + L^*_{collapsible} + L^*_{down}. $ The upstream and downstream lengths of the channel are rigid, whereas the upper wall in the central section is an elastic membrane whose shape is parametrised by a Lagrangian coordinate, $ \xi^* $ , so that the position vector to the moving wall is given by $ {\bf R}_w^*(\xi^*,t^*) $ . The wall is loaded by the external pressure $ p_{ext}^* $ and by the traction that the viscous fluid exerts on it.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{collapsible_channel_sketch}
\doxyfigcaption{Sketch of the problem. }
\end{DoxyImage}


The non-\/dimensionalisation and governing equations have already been discussed in the \href{../../fsi_collapsible_channel/html/index.html}{\texttt{ previous (monolithic) example. }} The problem is not quite the same, however, because the upstream boundary condition is now one of prescribed flow, rather than prescribed pressure\+:
\begin{DoxyItemize}
\item Prescribed inflow,  \[
  {\bf u}(x_1,x_2) = {\bf u}_{p}(x_1,x_2) =   
  6 \ x_2 \  (1-x_2) \ {\bf e}_1.
  \ \ \ \ \ \ \ \ \ \ (1)
  \] at $ x_{1}=0$.
\end{DoxyItemize}All other boundary conditions remain the same.

\\\cline{1-1}
\end{longtabu}
~\newline
 \end{center} 

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_reslt}{}\doxysection{\texorpdfstring{Results}{Results}}\label{index_reslt}
The behaviour of the system under the prescribed-\/inflow boundary conditions is somewhat different to its behaviour when the pressure drop is prescribed. In the first instance, we consider steady states, in which all time-\/derivatives are neglected. The figure below shows steady flows at a Reynolds number of $ Re=500 $ and two values of the fluid-\/structure-\/interaction parameter, $ Q =
10^{-4} $ (upper) and $ Q = 10^{-2}$ (lower). For low values of $Q$, corresponding to weak fluid-\/structure interaction, the deformation of the wall is approximately symmetric, being dominated by the external pressure. As $Q$ increases, the influence of fluid traction can been seen in the asymmetric deformation of the elastic wall. The viscous pressure drop along the tube leads to higher pressure upstream (causing an outward deformation) and lower pressures downstream (causing an inward deflection).

 
\begin{DoxyImage}
\includegraphics[width=0.8\textwidth]{steady_flows}
\doxyfigcaption{Steady flows at Re=500 and Q=10e-\/4 (upper), Q=10e-\/2 (lower). }
\end{DoxyImage}


The overall behaviour of the system can be characterised by steady load-\/displacement curves in which the vertical position of a control point on the elastic section of the channel wall is plotted as a function of the external pressure.

 
\begin{DoxyImage}
\includegraphics[width=0.5\textwidth]{steady_trace}
\doxyfigcaption{Load-\/displacement curve\+: the vertical position of a control point on the elastic wall (located at 50, 50, 60 and 70 percent of its length for Q = 0, 10e-\/4, 10e-\/3 and 10e-\/2, respectively) as a function of the external pressure. }
\end{DoxyImage}


At low $Q$, the displacement is directly proportional to the external pressure. As $Q$ increases the curves shift to the right because a large external pressure is required to keep the wall in its undeformed position; ~\newline
 a consequence of the increased viscous pressure drop {\itshape and} the boundary condition that $p=0$ at the outlet. A second consequence of increasing $Q$ is that (at finite Reynolds number) a smaller increase in external pressure is required to achieve a given degree of collapse. This is because the Bernoulli effect reduces the fluid pressure in the region that is most strongly collapsed and therefore increases the compressive load on the wall. For $Q = 10^{-2}$ two limit points develop on the load-\/displacement curve, indicating that the wall "{}snaps through"{} into a collapsed buckled configuration when $p_{ext}$ becomes sufficiently large. The appearance of the limit points means that it is no longer possible to perform the steady parameter study by slowly increasing $p_{ext}: $ At sufficiently large values of $Q$ the displacement of the control point is not a single-\/valued function of the external pressure $ p_{ext}$. However, the application of "{}displacement control"{}, described in the tutorial discussing the \href{../../../beam/steady_ring/html/index.html}{\texttt{ large-\/displacement post-\/buckling of an elastic ring}} is sufficient to circumvent this difficulty\+: We treat the external pressure as an unknown and control the channel\textquotesingle{}s collapse by prescribing the vertical position of the control point, $ x_2^{[ctrl]}.$ This resolves the problem because the curve $ p_{ext}(x_2^{[ctrl]})$ is single-\/valued, allowing us to perform the parameter study by slowly increasing the wall collapse by reducing $ x_2^{[ctrl]}$, computing the pressure required to achieve this deformation as part of the solution.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_overview}{}\doxysection{\texorpdfstring{Overview\+: Segregated solution strategies with oomph-\/lib}{Overview: Segregated solution strategies with oomph-lib}}\label{index_overview}
The general methodology for setting up fluid-\/structure-\/interaction problems is discussed in \href{../../fsi_collapsible_channel/html/index.html\#overview}{\texttt{ another tutorial; }} and we shall assume that the standard monolithic problem has already been written. In the present example, the monolithic problem class {\ttfamily \doxylink{classFSICollapsibleChannelProblem}{FSICollapsible\+Channel\+Problem}} is specified in the header file \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/fsi_chan_problem.h}{\texttt{ fsi\+\_\+chan\+\_\+problem.\+h}}

Having specified the monolithic (fully-\/coupled) discretisation, our segregated solution strategy proceeds by alternating between fluid and solid solves\+: Initially, the degrees of freedom associated with the (pure) solid mechanics problem are "{}pinned"{} and the global assembly procedure is modified to omit the corresponding solid elements. The Newton solver will, therefore, solve the fluid equations with a "{}frozen"{} wall shape. Next, the degrees of freedom associated with the (pure) fluid mechanics problem are pinned and the original boundary conditions for the solid mechanics problem are re-\/assigned. The assembly procedure is now modified so that only solid elements contribute to the global system. The Newton solver will then solve for a new wall shape corresponding to the tractions exerted by the given flow field. At this point we allow for under-\/relaxation, i.\+e. we provide the option to increment the solid mechanics degrees of freedom by a fraction of the change computed by the Newton solver. These two steps are repeated in a fixed-\/point iteration which continues until a given convergence criterion is satisfied, or a maximum number of iterations is exceeded. We note that different linear solvers/preconditioners may be specified for solution of the linear systems arising during the Newton iteration for the isolated "{}fluid"{} and "{}solid"{} problems, allowing the re-\/use of optimal solution methods for individual sub-\/problems. This is generally perceived to be one of the key advantages of segregated solvers.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_how_its_done}{}\doxysection{\texorpdfstring{Brief discussion of the implementation}{Brief discussion of the implementation}}\label{index_how_its_done}
\hypertarget{index_seg_problem}{}\doxysubsection{\texorpdfstring{The Segregatable\+FSIProblem}{The SegregatableFSIProblem}}\label{index_seg_problem}
{\bfseries{a. Overall structure}}

The \href{../../../the_data_structure/html/classoomph_1_1SegregatableFSIProblem.html}{\texttt{ {\ttfamily Segregatable\+FSIProblem} }} class is used to implement our segregated solution strategy within {\ttfamily oomph-\/lib}. The most important problem-\/specific task is to divide all the problem data into distinct fluid and solid degrees of freedom and to partition the monolithic mesh into a mesh of fluid elements and a mesh of solid elements. The problem-\/specific partitioning should be implemented in the (pure) virtual member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{///\ Identify\ fluid\ and\ solid\ data}}
\DoxyCodeLine{\textcolor{keyword}{virtual}\ \textcolor{keywordtype}{void}\ identify\_fluid\_and\_solid\_dofs(Vector<Data*>\&\ fluid\_data\_pt,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Vector<Data*>\&\ solid\_data\_pt,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Mesh*\&\ fluid\_mesh\_pt,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Mesh*\&\ solid\_mesh\_pt)=0;}

\end{DoxyCode}
 which returns vectors of fluid and solid data and the meshes of fluid and solid elements. This virtual function is called within the member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{///\ \(\backslash\)short\ Set\ up\ segregated\ solver.\ The\ optional\ boolean\ argument}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ defaults\ to\ true\ and\ causes\ the\ identify\_fluid\_and\_solid\_dofs(...)}}
\DoxyCodeLine{\textcolor{comment}{///\ to\ be\ called\ again.\ This\ is\ required,\ e.g.\ if\ any\ of\ the}}
\DoxyCodeLine{\textcolor{comment}{///\ meshes\ were\ adapted\ since\ the\ previous\ call\ to\ the\ segregated\ solver.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{keywordtype}{void}\ setup\_segregated\_solver(\textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ \&full\_setup\_of\_fluid\_and\_solid\_dofs=\textcolor{keyword}{true})}

\end{DoxyCode}
 which {\itshape must} be called immediately before every segregated solve. The optional boolean flag may be set to {\ttfamily false} if the solid and fluid meshes have not changed between solves (i.\+e. if no spatial adaptation was performed since the last call to the segregated solver). The {\ttfamily setup\+\_\+segregated\+\_\+solver(...)} function must still be called, however, in order that data associated with convergence acceleration techniques is reset to its default values.

{\bfseries{b. The segregated solvers}}

The class inherits from the standard {\ttfamily Problem} class, which provides the standard (monolithic) {\ttfamily newton\+\_\+solve()} and related functions. Thus any {\ttfamily Segregated\+FSIProblem} can be solved "{}monolithically"{} as normal and, moreover, it is straightforward to ensure that exactly the same system is being solved when comparing monolithic and segregated solutions. The segregated solution strategy is implemented in the analogous member functions\+:
\begin{DoxyItemize}
\item The equivalent of the monolithic {\ttfamily Problem\+::newton\+\_\+solve()} is 
\begin{DoxyCode}{0}
\DoxyCodeLine{SegregatedFSIProblem::segregated\_solve();}

\end{DoxyCode}

\item The equivalent of the monolithic {\ttfamily Problem\+::steady\+\_\+newton\+\_\+solve()} is 
\begin{DoxyCode}{0}
\DoxyCodeLine{SegregatedFSIProblem::steady\_segregated\_solve();}

\end{DoxyCode}

\item Finally, the equivalent of {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve(dt)} is 
\begin{DoxyCode}{0}
\DoxyCodeLine{PicardConvergenceData\ unsteady\_segregated\_solve(\textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ \&dt);}

\end{DoxyCode}

\end{DoxyItemize}All three functions return an instance of a {\ttfamily Picard\+Convergence\+Data} object which stores the convergence statistics of the segregated solve.

In addition, the virtual member functions 
\begin{DoxyCode}{0}
\DoxyCodeLine{SegregatedFSIProblem::actions\_before\_segregated\_solve()\ }

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{SegregatedFSIProblem::actions\_after\_segregated\_solve()\ }

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{SegregatedFSIProblem::actions\_before\_segregated\_convergence\_check()\ }

\end{DoxyCode}
 are provided to allow the user to specify any actions, such as initialisation of counters, mesh updates, output, etc, that should be performed before or after each complete segregated solve. Note that the {\ttfamily Problem} member functions 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_before\_newton\_solve()\ }

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_after\_newton\_solve()\ }

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_before\_newton\_convergence\_check()\ }

\end{DoxyCode}
 are called as usual during the Newton solve of each sub-\/problem and may be used for fine-\/grained operations that should be performed before or after each fluid or solid solve. For this purpose, the {\ttfamily Segregated\+FSIProblem} provides a flag, {\ttfamily int} {\ttfamily Segregated\+FSIProblem\+::\+Solve\+\_\+type} that indicates which (sub-\/)solve is currently being performed. The flag can take the (enumerated) values {\ttfamily Segregated\+FSIProblem\+::\+Full\+\_\+solve}, {\ttfamily Segregated\+FSIProblem\+::\+Fluid\+\_\+solve} and {\ttfamily Segregated\+FSIProblem\+::\+Solid\+\_\+solve}, allowing the user to perform specific actions during the distinct sub-\/solves.

{\bfseries{c. Choosing the convergence criterion}}

Other public member functions provided by the {\ttfamily Segregated\+FSIProblem} class are used to specify the convergence criterion for the global fixed-\/point iteration\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{///\ Base\ convergence\ based\ on\ max.\ global\ residual}}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ assess\_convergence\_based\_on\_max\_global\_residual(\textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ \&tol)}

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{///\ Base\ convergence\ on\ maximum\ absolute\ change\ of\ solid\ degrees\ of\ freedom}}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ assess\_convergence\_based\_on\_absolute\_solid\_change(\textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ \&tol)}

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{///\ Base\ convergence\ on\ maximum\ relative\ change\ of\ solid\ degrees\ of\ freedom}}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ assess\_convergence\_based\_on\_relative\_solid\_change(\textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ \&tol)}

\end{DoxyCode}
 If a tolerance is not specified the default {\ttfamily Problem\+::\+Newton\+\_\+solver\+\_\+tolerance} is used.

{\bfseries{d. Under-\/relaxation}}

Finally, there are several member functions that are used to specify the convergence-\/acceleration techniques\+:
\begin{DoxyEnumerate}
\item {\bfseries{Static under-\/relaxation\+:}} ~\newline
~\newline
 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//Use\ under-\/relaxation\ for\ solid\ degrees\ of\ freedom\ and\ specify\ }}
\DoxyCodeLine{\textcolor{comment}{//the\ optional\ under-\/relaxation\ parameter.\ The\ default\ of\ 1.0\ }}
\DoxyCodeLine{\textcolor{comment}{//corresponds\ to\ no\ under-\/relaxation.}}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ use\_under\_relaxation\ (\textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ \&omega=1.0)}

\end{DoxyCode}
 If this function is called, under-\/relaxation is performed after the solid sub-\/solve, i.\+e. each solid degree of freedom, $ s $, say is updated via  \[
    s = s_{new} + (1-\omega) (s_{old} - s_{new})
    \] where $ s_{new} $ is the new value computed by the Newton solver and $ s_{old} $ is its previous value.
\item {\bfseries{Adaptive under-\/relaxation\+:}} ~\newline
~\newline
 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//Boolean\ flag\ that\ controls\ whether\ Irons\ \&\ Tuck\ extrapolation}}
\DoxyCodeLine{\textcolor{comment}{//is\ used\ to\ dynamically\ modify\ the\ under-\/relaxation\ parameter\ for}}
\DoxyCodeLine{\textcolor{comment}{//the\ under-\/relaxation\ of\ the\ solid\ degrees\ of\ freedom.}}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ enable\_irons\_and\_tuck\_extrapolation\ ()}

\end{DoxyCode}
 If this function is called (and if under-\/relaxation is enabled) the under-\/relaxation parameter $ \omega $ is adjusted throughout the fixed-\/point iteration, using Irons \& Tucks convergence acceleration procedure; see Irons, B.\+M. \& Tuck, R.\+C. "{}\+A version of the Aitken accelerator for computer iteration"{}. International Journal of Numerical Methods in Engineering {\bfseries{1}}, 275-\/277 (1969).
\item {\bfseries{Pointwise Aitken-\/acceleration\+:}} ~\newline
~\newline
 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//Set\ a\ boolean\ flag\ that\ controls\ whether\ pointwise\ Aitken}}
\DoxyCodeLine{\textcolor{comment}{//extrapolation\ is\ used.\ The\ optional\ argument\ specifies\ the\ Picard}}
\DoxyCodeLine{\textcolor{comment}{//Iteration\ after\ which\ the\ extrapolation\ is\ to\ be\ used\ for\ the\ first}}
\DoxyCodeLine{\textcolor{comment}{//time.\ The\ default\ value\ is\ zero.}}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ enable\_pointwise\_aitken\ (\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \&pointwise\_aitken\_start)}

\end{DoxyCode}
 If this function is called, the classical Aitken extrapolation is used to accelerate the convergence of (individual) solid degrees of freedom after every three iterations.
\end{DoxyEnumerate}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_channel_seg_problem}{}\doxysection{\texorpdfstring{The Segregated\+FSICollapsible\+Channel\+Problem}{The SegregatedFSICollapsibleChannelProblem}}\label{index_channel_seg_problem}
We shall now briefly discuss the application of the segregated solver for the collapsible channel problem. The {\ttfamily \doxylink{classSegregatedFSICollapsibleChannelProblem}{Segregated\+FSICollapsible\+Channel\+Problem}} is defined in the driver code {\ttfamily \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/simple_segregated_driver.cc}{\texttt{ simple\+\_\+segregated\+\_\+driver.\+cc}} } and inherits from the "{}monolithic"{} {\ttfamily \doxylink{classFSICollapsibleChannelProblem}{FSICollapsible\+Channel\+Problem}} and also from the \href{../../../the_data_structure/html/classoomph_1_1SegregatableFSIProblem.html}{\texttt{ {\ttfamily Segregatable\+FSIProblem} }} class. The code {\ttfamily  \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/simple_segregated_driver.cc}{\texttt{ simple\+\_\+segregated\+\_\+driver.\+cc}} } is specifically designed for ease of exposition and does not contain any timing statements or documentation of convergence histories. The alternative driver code {\ttfamily  \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/fsi_chan_seg_driver.cc}{\texttt{ fsi\+\_\+chan\+\_\+seg\+\_\+driver.\+cc}}} contains complete timing and documentation statements and is the code that was used by \href{http://www.springerlink.com/content/m3r6318701g338g4/}{\texttt{ Heil, Hazel \& Boyle (2008). }}

The simplified {\ttfamily \doxylink{classSegregatedFSICollapsibleChannelProblem}{Segregated\+FSICollapsible\+Channel\+Problem}} class contains six member functions
\begin{DoxyItemize}
\item The constructor
\item The destructor
\item {\ttfamily void} {\ttfamily identify\+\_\+fluid\+\_\+and\+\_\+solid\+\_\+dofs(...)} 
\item {\ttfamily void} {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} 
\item {\ttfamily void} {\ttfamily actions\+\_\+before\+\_\+segregated\+\_\+convergence\+\_\+check()} 
\item {\ttfamily void} {\ttfamily steady\+\_\+run()} 
\item {\ttfamily void} {\ttfamily doc\+\_\+solution(\+Doc\+Info\& doc\+\_\+info)} 
\end{DoxyItemize}The {\ttfamily doc\+\_\+solution(...)} function simply writes the bulk (fluid) elements and wall (solid) elements to two separate files and the destructor is empty. We discuss the other four member functions below.

\DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysubsection{\texorpdfstring{The constructor}{The constructor}}\label{index_constructor}
The constructor calls the constructor of the underlying "{}monolithic"{} problem and then selects the convergence criterion and convergence-\/acceleration technique based on the values of control flags defined in the namespace {\ttfamily \doxylink{namespaceFlags}{Flags}}.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====start\_of\_constructor======================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Constructor\ for\ the\ collapsible\ channel\ problem}}
\DoxyCodeLine{\textcolor{comment}{//===============================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classSegregatedFSICollapsibleChannelProblem_ac762b472c2baafa23dae6b9ce38f31da}{SegregatedFSICollapsibleChannelProblem<\ ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classSegregatedFSICollapsibleChannelProblem_ac762b472c2baafa23dae6b9ce38f31da}{SegregatedFSICollapsibleChannelProblem}}(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ nup,\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ ncollapsible,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ ndown,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ ny,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ lup,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ lcollapsible,\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ ldown,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ ly,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\&\ displ\_control,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\&\ steady\_flag)\ :}
\DoxyCodeLine{\ \mbox{\hyperlink{classFSICollapsibleChannelProblem}{FSICollapsibleChannelProblem}}<ELEMENT>(nup,\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ncollapsible,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ndown,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ny,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lup,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lcollapsible,\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ldown,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ly,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ displ\_control,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ steady\_flag)\ }
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Choose\ convergence\ criterion\ based\ on\ Flag::Convergence\ criterion}}
\DoxyCodeLine{\ \textcolor{comment}{//\ with\ tolerance\ given\ by\ Flag::Convergence\_tolerance}}
\DoxyCodeLine{\ \textcolor{keywordflow}{if}\ (\mbox{\hyperlink{namespaceFlags_aba930ff1e462e642a27904df95baab7c}{Flags::Convergence\_criterion}}==0)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ assess\_convergence\_based\_on\_max\_global\_residual(}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{namespaceFlags_a5550ee43b27fd03898a6718246b44e4a}{Flags::Convergence\_tolerance}});}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (\mbox{\hyperlink{namespaceFlags_aba930ff1e462e642a27904df95baab7c}{Flags::Convergence\_criterion}}==1)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ assess\_convergence\_based\_on\_absolute\_solid\_change(}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{namespaceFlags_a5550ee43b27fd03898a6718246b44e4a}{Flags::Convergence\_tolerance}});}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (\mbox{\hyperlink{namespaceFlags_aba930ff1e462e642a27904df95baab7c}{Flags::Convergence\_criterion}}==2)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ assess\_convergence\_based\_on\_relative\_solid\_change(}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{namespaceFlags_a5550ee43b27fd03898a6718246b44e4a}{Flags::Convergence\_tolerance}});}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//Select\ a\ convergence-\/acceleration\ technique\ based\ on\ control\ flags}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Pointwise\ Aitken\ extrapolation}}
\DoxyCodeLine{\ \textcolor{keywordflow}{if}(\mbox{\hyperlink{namespaceFlags_aabfbfdb3e91e4df3fc2ec6e2a2e3567d}{Flags::Use\_pointwise\_aitken}})}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ this-\/>enable\_pointwise\_aitken();}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \textcolor{keywordflow}{else}}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ this-\/>disable\_pointwise\_aitken();}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Under-\/relaxation}}
\DoxyCodeLine{\ this-\/>enable\_under\_relaxation(\mbox{\hyperlink{namespaceFlags_a6c3895aecba834ceda5fe1c3ecb13bba}{Flags::Omega\_under\_relax}});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Irons\ and\ Tuck's\ extrapolation}}
\DoxyCodeLine{\ \textcolor{keywordflow}{if}(\mbox{\hyperlink{namespaceFlags_a9d92a2ec6ebd4e2ea66605c063e53915}{Flags::Use\_irons\_and\_tuck\_extrapolation}})}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ this-\/>enable\_irons\_and\_tuck\_extrapolation();}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \textcolor{keywordflow}{else}}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ this-\/>disable\_irons\_and\_tuck\_extrapolation();}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//end\_of\_constructor}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
\hypertarget{index_identify}{}\doxysubsection{\texorpdfstring{Identifying the fluid and solid degrees of freedom}{Identifying the fluid and solid degrees of freedom}}\label{index_identify}
The underlying monolithic problem provides pointers to the fluid and solid (sub-\/)meshes via the member data 
\begin{DoxyCode}{0}
\DoxyCodeLine{AlgebraicCollapsibleChannelMesh<ELEMENT>*\ Bulk\_mesh\_pt;}

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{OneDLagrangianMesh<FSIHermiteBeamElement>*\ Wall\_mesh\_pt;\ }

\end{DoxyCode}
 which are accessible via the member functions ~\newline
 {\ttfamily \doxylink{classFSICollapsibleChannelProblem_ae9ad9667460168fa74f8ec8e3ab9e988}{Segregated\+FSICollapsible\+Channel\+Problem\+::bulk\+\_\+mesh\+\_\+pt()}} and {\ttfamily \doxylink{classFSICollapsibleChannelProblem_aec24d3eb06747f8429cf14857aed29a1}{Segregated\+FSICollapsible\+Channel\+Problem\+::wall\+\_\+mesh\+\_\+pt()}}, and so the identification of fluid and solid degrees of freedom is reasonably straightforward. The only complication arises because we may, or may not, be using displacement control which introduces a further element into the global mesh. Displacement control affects the solid problem suggesting that the (variable) external pressure should be regarded as a solid degrees of freedom and the {\ttfamily Displacement\+Control\+Element} should be included in the solid mesh.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====start\_of\_identify\_fluid\_and\_solid======================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Identify\ the\ fluid\ and\ solid\ Data\ and\ the\ meshes\ that}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ contain\ only\ elements\ that\ are\ involved\ in\ the\ respective\ sub-\/problems.\ }}
\DoxyCodeLine{\textcolor{comment}{///\ This\ implements\ a\ pure\ virtual\ function\ in\ the\ }}
\DoxyCodeLine{\textcolor{comment}{///\ SegregatableFSIProblem\ base\ class.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//============================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classSegregatedFSICollapsibleChannelProblem_a7b277b9583bb10e72655010dc653023e}{SegregatedFSICollapsibleChannelProblem<ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classSegregatedFSICollapsibleChannelProblem_a7b277b9583bb10e72655010dc653023e}{identify\_fluid\_and\_solid\_dofs}}(Vector<Data*>\&\ fluid\_data\_pt,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Vector<Data*>\&\ solid\_data\_pt,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Mesh*\&\ fluid\_mesh\_pt,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Mesh*\&\ solid\_mesh\_pt)}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//FLUID\ DATA:\ }}
\DoxyCodeLine{\ \textcolor{comment}{//All\ fluid\ elements\ are\ stored\ in\ the\ Mesh\ addressed\ by\ bulk\_mesh\_pt()\ }}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Reset\ the\ storage}}
\DoxyCodeLine{\ fluid\_data\_pt.clear();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Find\ number\ of\ fluid\ elements}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_fluid\_elem=this-\/>bulk\_mesh\_pt()-\/>nelement();}
\DoxyCodeLine{\ \textcolor{comment}{//Loop\ over\ fluid\ elements\ and\ add\ internal\ data\ to\ fluid\_data\_ptt}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ e=0;e<n\_fluid\_elem;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ GeneralisedElement*\ el\_pt=this-\/>bulk\_mesh\_pt()-\/>element\_pt(e);}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{unsigned}\ n\_internal=el\_pt-\/>ninternal\_data();}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ i=0;i<n\_internal;i++)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ fluid\_data\_pt.push\_back(el\_pt-\/>internal\_data\_pt(i));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//Find\ number\ of\ nodes\ in\ fluid\ mesh}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_fluid\_node=this-\/>bulk\_mesh\_pt()-\/>nnode();}
\DoxyCodeLine{\ \textcolor{comment}{//Loop\ over\ nodes\ and\ add\ the\ nodal\ data\ to\ fluid\_data\_pt}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ n=0;n<n\_fluid\_node;n++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ fluid\_data\_pt.push\_back(this-\/>bulk\_mesh\_pt()-\/>node\_pt(n));}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \textcolor{comment}{//\ The\ bulk\_mesh\_pt()\ is\ a\ mesh\ that\ contains\ only\ fluid\ elements}}
\DoxyCodeLine{\ fluid\_mesh\_pt\ =\ this-\/>bulk\_mesh\_pt();\ }
\DoxyCodeLine{\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//SOLID\ DATA}}
\DoxyCodeLine{\ \textcolor{comment}{//All\ solid\ elements\ are\ stored\ in\ the\ Mesh\ addressed\ by\ wall\_mesh\_pt()}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Reset\ the\ storage}}
\DoxyCodeLine{\ solid\_data\_pt.clear();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Find\ number\ of\ nodes\ in\ the\ solid\ mesh}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_solid\_node=this-\/>wall\_mesh\_pt()-\/>nnode();}
\DoxyCodeLine{\ \textcolor{comment}{//Loop\ over\ nodes\ and\ add\ nodal\ position\ data\ to\ solid\_data\_pt}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ n=0;n<n\_solid\_node;n++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ solid\_data\_pt.push\_back(}
\DoxyCodeLine{\ \ \ \ this-\/>wall\_mesh\_pt()-\/>node\_pt(n)-\/>variable\_position\_pt());}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \textcolor{comment}{//If\ we\ are\ using\ displacement\ control\ then\ the\ displacement\ control\ element}}
\DoxyCodeLine{\ \textcolor{comment}{//and\ external\ pressure\ degree\ of\ freedom\ should\ be\ treated\ as\ part}}
\DoxyCodeLine{\ \textcolor{comment}{//of\ the\ solid\ problem}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//We\ will\ assemble\ a\ single\ solid\ mesh\ from\ a\ vector\ of\ pointers\ to\ meshes}}
\DoxyCodeLine{\ Vector<Mesh*>\ s\_mesh\_pt(1);}
\DoxyCodeLine{\ \textcolor{comment}{//The\ wall\_mesh\_pt()\ contains\ all\ solid\ elements\ and\ is\ the\ first}}
\DoxyCodeLine{\ \textcolor{comment}{//entry\ in\ our\ vector}}
\DoxyCodeLine{\ s\_mesh\_pt[0]=this-\/>wall\_mesh\_pt();}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \textcolor{comment}{//If\ we\ are\ using\ displacement\ control}}
\DoxyCodeLine{\ \textcolor{keywordflow}{if}\ (this-\/>Displ\_control)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Add\ the\ external\ pressure\ data\ to\ solid\_data\_pt}}
\DoxyCodeLine{\ \ \ solid\_data\_pt.push\_back(\mbox{\hyperlink{namespaceGlobal__Physical__Variables_ad31ed4ea9a7fce4c20c2230d26047f6f}{Global\_Physical\_Variables::P\_ext\_data\_pt}});}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Add\ a\ pointer\ to\ a\ Mesh\ containing\ the\ displacement\ control\ element}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//to\ the\ vector\ of\ pointers\ to\ meshes}}
\DoxyCodeLine{\ \ \ s\_mesh\_pt.push\_back(this-\/>Displ\_control\_mesh\_pt);}
\DoxyCodeLine{\ \ \}\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Build\ "{}combined"{}\ mesh\ from\ our\ vector\ of\ solid\ meshes}}
\DoxyCodeLine{\ solid\_mesh\_pt\ =\ \textcolor{keyword}{new}\ Mesh(s\_mesh\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//end\_of\_identify\_fluid\_and\_solid}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
\hypertarget{index_actions}{}\doxysubsection{\texorpdfstring{Actions before convergence checks}{Actions before convergence checks}}\label{index_actions}
During a monolithic solve the function {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} must update the nodal positions in the bulk (fluid) mesh. In principle, it should remain empty during a segregated solve, but we found it beneficial to update the bulk mesh, and hence the fluid load on the wall, during the solution of the solid problem.

The function {\ttfamily actions\+\_\+before\+\_\+segregated\+\_\+convergence\+\_\+check()} contains an update of the nodal positions in the bulk mesh in order that the segregated solution is self-\/consistent.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ nodal\ positions\ in\ the\ fluid\ mesh\ in}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ response\ to\ changes\ in\ the\ wall\ displacement\ field\ after\ every}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Newton\ step\ in\ a\ monolithic\ or\ segregated\ solid\ solve.\ Note}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ the\ use\ of\ the\ (protected)\ flag\ Solve\_type,\ which\ can\ take\ the}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ values\ Full\_solve,\ Fluid\_solve\ or\ Solid\_solve.\ This\ flag\ is\ used}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ to\ allow\ specification\ of\ different\ actions\ depending\ on\ the}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ precise\ solve\ taking\ place.}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ actions\_before\_newton\_convergence\_check()}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//For\ a\ "{}true"{}\ segregated\ solver,\ we\ would\ not\ do\ this\ in\ fluid\ or\ solid}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//solves,\ but\ adding\ the\ bulk\ node\ update\ to\ the\ solid\ solve\ phase\ aids}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//convergence\ and\ makes\ it\ possible\ for\ larger\ values\ of\ Q.\ Of\ course,}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//there\ is\ a\ small\ cost\ associated\ with\ doing\ this.}}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{if}(Solve\_type!=Fluid\_solve)\ \{this-\/>Bulk\_mesh\_pt-\/>node\_update();\}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ nodal\ positions\ in\ the\ fluid\ mesh}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ in\ response\ to\ any\ changes\ in\ the\ wall\ displacement\ field\ after\ every\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ segregated\ solve.\ This\ is\ not\ strictly\ necessary\ because\ we}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ do\ the\ solid\ solve\ last,\ which\ performs\ its\ own\ node\ update\ before\ the\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ convergence\ check\ of\ the\ sub\ problem.\ It\ remains\ here\ because\ if\ we}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ were\ solving\ in\ a\ completely\ segregated\ fashion\ a\ node\ update\ would\ be\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ required\ for\ the\ fluid\ mesh\ in\ the\ final\ converged\ solution\ to\ be}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ consistent\ with\ the\ solid\ positions.}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ actions\_before\_segregated\_convergence\_check()}
\DoxyCodeLine{\ \ \{\ }
\DoxyCodeLine{\ \ \ this-\/>Bulk\_mesh\_pt-\/>node\_update();}
\DoxyCodeLine{\ \ \}\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ end\_of\_convergence\_checks}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
\hypertarget{index_steady}{}\doxysubsection{\texorpdfstring{Solving a steady problem}{Solving a steady problem}}\label{index_steady}
The function {\ttfamily steady\+\_\+run()} conducts a simple parameter study in which the external pressure (or prescribed displacement) is varied. After specification of the initial conditions, parameter increments and output directories, the parameter study is straightforward  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Parameter\ study\ (loop\ over\ the\ number\ of\ steps)}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ istep=0;istep<\mbox{\hyperlink{namespaceFlags_a8a6ffdb261330ef89965624209ab7b00}{Flags::Nsteps}};istep++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Setup\ segregated\ solver\ }}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//(Default\ behaviour\ will\ identify\ the\ fluid\ and\ solid\ dofs\ and}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ allocate\ memory,\ etc\ every\ time.\ This\ is\ a\ bit\ inefficient\ in\ }}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ this\ case,\ but\ it\ is\ safe\ and\ will\ always\ work)}}
\DoxyCodeLine{\ \ \ setup\_segregated\_solver();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ SEGREGATED\ SOLVER}}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{if}(\mbox{\hyperlink{namespaceFlags_a2cdfa6b776b959a060a1f2e8d4918789}{Flags::Use\_segregated\_solver}})}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//Set\ the\ maximum\ number\ of\ Picard\ steps}}
\DoxyCodeLine{\ \ \ \ \ Max\_picard\ =50;}
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ Solve\ ignoring\ return\ type\ (convergence\ data)}}
\DoxyCodeLine{\ \ \ \ \ (void)steady\_segregated\_solve();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ NEWTON\ SOLVER}}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//Explit\ call\ to\ the\ steady\ Newton\ solve.}}
\DoxyCodeLine{\ \ \ \ \ steady\_newton\_solve();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Output\ the\ solution}}
\DoxyCodeLine{\ \ \ doc\_solution(doc\_info);}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Increase\ the\ Step\ number}}
\DoxyCodeLine{\ \ \ doc\_info.number()++;}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Adjust\ control\ parameters}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//If\ displacment\ control\ increment\ position}}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{if}\ (this-\/>Displ\_control)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \mbox{\hyperlink{namespaceGlobal__Physical__Variables_afd29cc714595594020831c7c54387883}{Global\_Physical\_Variables::Yprescr}}+=delta\_y;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Otherwise\ increment\ external\ pressure}}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \textcolor{keywordtype}{double}\ old\_p=\mbox{\hyperlink{namespaceGlobal__Physical__Variables_ad31ed4ea9a7fce4c20c2230d26047f6f}{Global\_Physical\_Variables::P\_ext\_data\_pt}}-\/>value(0);}
\DoxyCodeLine{\ \ \ \ \ \mbox{\hyperlink{namespaceGlobal__Physical__Variables_ad31ed4ea9a7fce4c20c2230d26047f6f}{Global\_Physical\_Variables::P\_ext\_data\_pt}}-\/>set\_value(0,old\_p+delta\_p);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \}\ \textcolor{comment}{//\ End\ of\ parameter\ study}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysection{\texorpdfstring{The driver code}{The driver code}}\label{index_main}
Having written our {\ttfamily \doxylink{classSegregatedFSICollapsibleChannelProblem}{Segregated\+FSICollapsible\+Channel\+Problem}}, the driver code is extremely simple. We specify number of elements and dimensions of our computational domain, construct the problem and perform a steady parameter study.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_main====================================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Driver\ code\ for\ a\ segregated\ collapsible\ channel\ problem\ with\ FSI.}}
\DoxyCodeLine{\textcolor{comment}{//=============================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{simple__segregated__driver_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Number\ of\ elements\ in\ the\ domain}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ nup=4*\mbox{\hyperlink{namespaceFlags_a7c2437aa0b6a4f27df951f1cbcef7337}{Flags::Resolution\_factor}};}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ ncollapsible=20*\mbox{\hyperlink{namespaceFlags_a7c2437aa0b6a4f27df951f1cbcef7337}{Flags::Resolution\_factor}};}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ ndown=40*\mbox{\hyperlink{namespaceFlags_a7c2437aa0b6a4f27df951f1cbcef7337}{Flags::Resolution\_factor}};}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ ny=4*\mbox{\hyperlink{namespaceFlags_a7c2437aa0b6a4f27df951f1cbcef7337}{Flags::Resolution\_factor}};}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Geometry\ of\ the\ domain}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ lup=1.0;}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ lcollapsible=5.0;}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ ldown=10.0;}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ ly=1.0;}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Steady\ run\ by\ default}}
\DoxyCodeLine{\ \textcolor{keywordtype}{bool}\ steady\_flag=\textcolor{keyword}{true};}
\DoxyCodeLine{\ \textcolor{comment}{//\ with\ displacement\ control}}
\DoxyCodeLine{\ \textcolor{keywordtype}{bool}\ displ\_control=\textcolor{keyword}{true};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Build\ the\ problem\ with\ QTaylorHoodElements}}
\DoxyCodeLine{\ \mbox{\hyperlink{classSegregatedFSICollapsibleChannelProblem}{SegregatedFSICollapsibleChannelProblem}}}
\DoxyCodeLine{\ \ <AlgebraicElement<QTaylorHoodElement<2>\ >\ >\ }
\DoxyCodeLine{\ \ problem(nup,\ ncollapsible,\ ndown,\ ny,\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ lup,\ lcollapsible,\ ldown,\ ly,\ displ\_control,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ steady\_flag);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//Perform\ a\ steady\ run}}
\DoxyCodeLine{\ problem.steady\_run();}
\DoxyCodeLine{\ }
\DoxyCodeLine{\}\textcolor{comment}{//end\ of\ main}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comments_and_ex}{}\doxysection{\texorpdfstring{Comments and Exercises}{Comments and Exercises}}\label{index_comments_and_ex}
\hypertarget{index_comments}{}\doxysubsection{\texorpdfstring{Comments}{Comments}}\label{index_comments}

\begin{DoxyItemize}
\item {\bfseries{(In-\/)efficiency of {\ttfamily setup\+\_\+segregated\+\_\+solver()}}} ~\newline
~\newline
 In our simple example code, we did not employ spatial adaptivity. It is not necessary, therefore, to (re-\/)identify the fluid and solid degrees of freedom before each solve, the default (safe) behaviour of {\ttfamily setup\+\_\+segregated\+\_\+solver()}. Nonetheless, data associated with the techniques used to accelerate the convergence of the Picard iterations must be reset before each segregated solve. In the more complex driver code, a boolean flag {\ttfamily bool} {\ttfamily full\+\_\+setup} is used as an argument to {\ttfamily setup\+\_\+segregated\+\_\+solver()} which modifies the behaviour, as indicated below. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Boolean\ flag\ used\ to\ specify\ whether\ a\ full\ setup\ of\ solid\ and\ fluid\ dofs}}
\DoxyCodeLine{\textcolor{comment}{//\ is\ required}}
\DoxyCodeLine{\textcolor{keywordtype}{bool}\ full\_setup\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Parameter\ study}}
\DoxyCodeLine{\textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ istep=0;istep<\mbox{\hyperlink{namespaceFlags_a8a6ffdb261330ef89965624209ab7b00}{Flags::Nsteps}};istep++)}
\DoxyCodeLine{\ \{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Setup\ segregated\ solver}}
\DoxyCodeLine{\ \ setup\_segregated\_solver(full\_setup);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ [...]}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \ steady\_segregated\_solve()}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ [...]\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//We\ no\ longer\ need\ a\ full\ setup\ of\ the\ dofs}}
\DoxyCodeLine{\ \ full\_setup\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{\ \}}

\end{DoxyCode}
 . ~\newline

\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_ex}{}\doxysubsection{\texorpdfstring{Exercises}{Exercises}}\label{index_ex}

\begin{DoxyEnumerate}
\item Modify the control flags in {\ttfamily \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/simple_segregated_driver.cc}{\texttt{ simple\+\_\+segregated\+\_\+driver.\+cc}}} to verify that the monolithic solution is the same (to within finite precision) as the segregated solution.
\item Modify the control flags in {\ttfamily \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/simple_segregated_driver.cc}{\texttt{ simple\+\_\+segregated\+\_\+driver.\+cc}}} to investigate the influence of the convergence acceleration techniques and convergence criterion on the segregated solution. Which combination of parameters gives convergence in the fewest Picard iterations?
\item Investigate the behaviour of the system if the fluid (bulk) mesh is {\itshape not} updated after each Newton step in the solution of the solid problem. Can you obtain converged solutions?
\item Write your own {\ttfamily Segregated\+FSICollapsible\+Channel\+Flow\+::unsteady\+\_\+run()} member function that computes the time evolution of the system after a perturbation to the external pressure. Compare your answer with the equivalent member function in the much more comprehensive driver code {\ttfamily \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/fsi_chan_seg_driver.cc}{\texttt{ fsi\+\_\+chan\+\_\+seg\+\_\+driver.\+cc}}} that was used in \href{http://www.springerlink.com/content/m3r6318701g338g4/}{\texttt{ Heil, Hazel \& Boyle (2008). }} . ~\newline

\end{DoxyEnumerate}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{\texorpdfstring{Source files for this tutorial}{Source files for this tutorial}}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/}{\texttt{ demo\+\_\+drivers/interaction/fsi\+\_\+channel\+\_\+seg\+\_\+and\+\_\+precond/ }} \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/simple_segregated_driver.cc}{\texttt{ demo\+\_\+drivers/interaction/fsi\+\_\+channel\+\_\+seg\+\_\+and\+\_\+precond/simple\+\_\+segregated\+\_\+driver.\+cc }} \end{center} 
\end{DoxyItemize}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{\texorpdfstring{PDF file}{PDF file}}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
