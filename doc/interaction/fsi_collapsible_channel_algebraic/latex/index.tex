\chapter{Flow in a 2D collapsible channel revisited -- sparse algebraic node updates}
\hypertarget{index}{}\label{index}\index{Flow in a 2D collapsible channel revisited -- sparse algebraic node updates@{Flow in a 2D collapsible channel revisited -- sparse algebraic node updates}}
In an \href{../../fsi_collapsible_channel/html/index.html}{\texttt{ earlier example,}} we demonstrated how the {\ttfamily Macro\+Element/\+Domain} -\/ based node-\/update procedure that we originally developed for problems with moving, curvilinear domain boundaries may also be used in fluid-\/structure interaction problems in which the position of the domain boundary has to be determined as part of the solution. We demonstrated that the driver code for the coupled multi-\/physics problem was a straightforward combination of the driver codes for the two constituent single-\/physics problems. The two key steps required to couple the two single-\/physics codes were\+:
\begin{DoxyEnumerate}
\item Recast the wall mesh to a {\ttfamily Geom\+Object}, using the {\ttfamily Mesh\+As\+Geom\+Object} class. This class turns an existing solid mechanics mesh into a "{}compound"{} {\ttfamily Geom\+Object} in which material points on the ~\newline
 wall are identified by their Lagrangian coordinate, $ \xi $ , which doubles as the {\ttfamily Geom\+Object\textquotesingle{}s} intrinsic coordinate, $ \zeta $ . ~\newline
~\newline

\item Use the "{}compound"{} {\ttfamily Geom\+Object} to represent the moving boundary of the fluid mesh. "{}\+Upgrade"{} the fluid elements (of type {\ttfamily FLUID\+\_\+\+ELEMENT}, say) to the "{}wrapped"{} version {\ttfamily Macro\+Element\+Node\+Update\+Element$<$\+FLUID\+\_\+\+ELEMENT$>$} to allow the the node-\/update to be performed node-\/by-\/node, and to automatically evaluate the "{}shape derivatives"{} -- the derivatives of the fluid equations with respect to the (solid mechanics) degrees of freedom that determine their nodal positions. ~\newline
~\newline

\end{DoxyEnumerate}While the implementation of these steps is very straightforward, we pointed out that the resulting code was not particularly efficient as the fluid-\/node update is not as sparse as it could (should!) be\+: Since it is impossible to distinguish between the various sub-\/objects in the "{}compound"{} {\ttfamily Geom\+Object}, we can do no better than to assume the worst-\/case scenario, namely that the positional degrees of freedom of all {\ttfamily Solid\+Nodes} in the wall mesh potentially affect the nodal position in all fluid elements. This dramatically increases the size of the elemental Jacobian matrices, and creates many nonzero entries in the off-\/diagonal blocks in the global Jacobian matrix.\hypertarget{index_alg_sparse}{}\doxysection{\texorpdfstring{Sparse algebraic node updates in FSI problems}{Sparse algebraic node updates in FSI problems}}\label{index_alg_sparse}
To avoid this problem we need a node-\/update strategy in which the position of each fluid node is determined by only a small number of solid mechanics degrees of freedom. The algebraic node-\/update strategy discussed in the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\texttt{ non-\/\+FSI version of the collapsible channel problem,}} provides an ideal framework for this, as it allows each node to update its own position, using a node-\/specific update function. Recall that in the {\ttfamily Algebraic\+Mesh} -\/ version of the {\ttfamily Collapsible\+Channel\+Mesh}, each {\ttfamily Algebraic\+Node} stored a pointer to the (single) {\ttfamily Geom\+Object} that represented the moving curvilinear boundary, and the Lagrangian coordinate of a reference point on this {\ttfamily Geom\+Object}. The node\textquotesingle{}s node-\/update function then placed the node at a fixed vertical fraction on the line connecting the reference point on the "{}elastic"{} wall to a second reference point on the fixed lower channel wall. Furthermore, the "{}wrapped"{} element, {\ttfamily Algebraic\+Element$<$\+FLUID\+\_\+\+ELEMENT$>$}, automatically computes the "{}shape derivatives"{} by finite-\/differencing the fluid residuals with respect to the degrees of freedom stored in the {\ttfamily Geom\+Object\textquotesingle{}s} geometric {\ttfamily Data}, just as in the case of the {\ttfamily Macro\+Element} -\/ based node-\/update procedure.

If used in the form discussed in the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\texttt{ earlier example,}} this methodology does not (yet!) improve the sparsity of the node update\+: The geometric {\ttfamily Data} of the "{}compound"{} {\ttfamily Geom\+Object} that represents the wall still contains the positional degrees of freedom of {\itshape all} of the mesh\textquotesingle{}s constituent {\ttfamily FSIHermite\+Beam\+Elements}. This is wasteful because the position of a material point on the (discretised) wall depends only on the positional degrees of freedom of the element that this point is located in. The (costly-\/to-\/compute) derivatives with respect to all other solid mechanics degree of freedom are zero. We will therefore modify the node-\/update procedure as follows\+: Each {\ttfamily Algebraic\+Node} stores a pointer to the {\ttfamily FSIHermite\+Beam\+Element} that its reference point is located in. This is possible because {\ttfamily FSIHermite\+Beam\+Elements} are derived from the {\ttfamily Finite\+Element} class which, in turn, is derived from the {\ttfamily Geom\+Object} class. In other words, the sub-\/objects of the compound {\ttfamily Mesh\+As\+Geom\+Object} are {\ttfamily Geom\+Objects} themselves. Their shape is parametrised by the {\ttfamily FSIHermite\+Beam\+Element\textquotesingle{}s} local coordinate, $ s $ , which acts as the (sub-\/){\ttfamily Geom\+Object\textquotesingle{}s} intrinsic coordinate, $ \zeta $ .

Given a pointer to a compound {\ttfamily Geom\+Object}, {\ttfamily geom\+\_\+obj\+\_\+pt}, say, and the intrinsic coordinate $ \zeta_{compound} $ = {\ttfamily zeta\+\_\+compound} of a point in that {\ttfamily Geom\+Object}, the function {\ttfamily Geom\+Object\+::locate\+\_\+zeta(...)} may be used to determine a pointer, {\ttfamily sub\+\_\+obj\+\_\+pt}, to the sub-\/object that this point is located in, and the vector of intrinsic coordinates {\ttfamily zeta\+\_\+sub\+\_\+obj} of the point in this sub-\/object. This procedure is illustrated in this code fragment\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ [...]\ }
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Vector\ containing\ the\ (1D)\ intrinsic\ coordinate\ in\ the\ }}
\DoxyCodeLine{\textcolor{comment}{//\ compound\ GeomObject:}}
\DoxyCodeLine{Vector<double>\ zeta\_compound(1);}
\DoxyCodeLine{zeta\_compound[0]=0.3;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Pointer\ to\ the\ sub-\/GeomObject:}}
\DoxyCodeLine{GeomObject*\ sub\_geom\_obj\_pt;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Vector\ containing\ the\ (1D)\ intrinsic\ coordinate\ in\ the\ }}
\DoxyCodeLine{\textcolor{comment}{//\ sub-\/GeomObject:}}
\DoxyCodeLine{Vector<double>\ zeta\_sub\_obj(1);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Get\ it...}}
\DoxyCodeLine{geom\_obj\_pt-\/>locate\_zeta(zeta\_compound,\ sub\_geom\_obj\_pt,\ zeta\_sub\_obj);}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Check\ the\ result:\ }}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Position\ vector\ to\ the\ point\ when\ viewed\ from}}
\DoxyCodeLine{\textcolor{comment}{//\ the\ compound\ GeomObject}}
\DoxyCodeLine{Vector<double>\ r\_compound(2);}
\DoxyCodeLine{geom\_obj\_pt-\/>position(zeta\_compound,r\_compound);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Position\ vector\ to\ the\ point\ when\ viewed\ from}}
\DoxyCodeLine{\textcolor{comment}{//\ the\ sub-\/GeomObject}}
\DoxyCodeLine{Vector<double>\ r\_sub(2);}
\DoxyCodeLine{sub\_geom\_obj\_pt-\/>position(zeta\_sub,r\_sub);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ With\ a\ bit\ of\ luck\ we\ should\ now\ have\ r\_sub\ ==\ r\_compound...}}
\DoxyCodeLine{}
\DoxyCodeLine{[...]}

\end{DoxyCode}


Here is an illustration of the relation between the various coordinates and {\ttfamily Geom\+Objects\+:} 

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{locate_zeta}
\doxyfigcaption{Sketch of the various coordinates and Geom\+Objects. The (continuous) beam is parametrised by its Lagrangian coordinate xi which doubles as the intrinsic coordinate zeta for its role as a Geom\+Object. The (discretised) beam is a compound Geom\+Object, parametrised by the Lagrangian coordinate xi; its constituent FSI beam elements are sub-\/\+Geom\+Objects that are parametrised by their local coordinates, s. }
\end{DoxyImage}


We note that the {\ttfamily Geom\+Object} base class provides a default implementation for the {\ttfamily Geom\+Object\+::locate\+\_\+zeta(...)} function as a virtual member function which returns the {\ttfamily Geom\+Object\textquotesingle{}s} {\ttfamily "{}this"{}} pointer and sets $ \zeta_{compound} =
\zeta_{sub} $ . Unless the function is overloaded in a specific derived class, the {\ttfamily Geom\+Object} therefore acts as its own sub-\/object. This is a sensible default as it ensures that ({\ttfamily geom\+\_\+obj\+\_\+pt}, $ \zeta_{compound}$ ) and ({\ttfamily sub\+\_\+geom\+\_\+obj\+\_\+pt}, {\ttfamily $ \zeta_{sub}$} ) always identify the same point, regardless of whether nor not the {\ttfamily Geom\+Object} pointed to by {\ttfamily geom\+\_\+obj\+\_\+pt} is a "{}compound"{} {\ttfamily Geom\+Object}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_impl}{}\doxysection{\texorpdfstring{The implementation}{The implementation}}\label{index_impl}
The implementation of the sparse node-\/update strategy requires only a few minor modifications to the {\ttfamily Algebraic\+Collapsible\+Channel\+Mesh}, first discussed in the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\texttt{ non-\/\+FSI example.}}

\DoxyHorRuler{0}
\hypertarget{index_mesh}{}\doxysubsection{\texorpdfstring{The Algebraic\+Collapsible\+Channel\+Mesh}{The AlgebraicCollapsibleChannelMesh}}\label{index_mesh}
We construct the mesh by multiple inheritance, combining the already existing {\ttfamily Collapsible\+Channel\+Mesh} with the {\ttfamily Algebraic\+Mesh} base class\+:

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \textcolor{comment}{//========start\_of\_algebraic\_collapsible\_channel\_mesh==============}}
\DoxyCodeLine{\textcolor{comment}{\ \ ///\ Collapsible\ channel\ mesh\ with\ algebraic\ node\ update}}
\DoxyCodeLine{\ \ \textcolor{comment}{//=================================================================}}
\DoxyCodeLine{\ \ \textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\ \ \textcolor{keyword}{class\ }AlgebraicCollapsibleChannelMesh}
\DoxyCodeLine{\ \ \ \ :\ \textcolor{keyword}{public}\ \textcolor{keyword}{virtual}\ CollapsibleChannelMesh<ELEMENT>,}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{public}\ AlgebraicMesh}
\DoxyCodeLine{\ \ \{}

\end{DoxyCodeInclude}
 The constructor calls the constructor of the underlying {\ttfamily Collapsible\+Channel\+Mesh} and then calls the private member function {\ttfamily setup\+\_\+algebraic\+\_\+node\+\_\+update()} to initialise the data for the algebraic node update procedures. (The initialisation is implemented in a separate function so it can be called from additional mesh constructors that are not discussed here.) The destructor remains empty.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \textcolor{keyword}{public}:\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ ///\ Constructor:\ Pass\ number\ of\ elements\ in\ upstream/collapsible/}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ ///\ downstream\ segment\ and\ across\ the\ channel;\ lengths\ of\ upstream/}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ ///\ collapsible/downstream\ segments\ and\ width\ of\ channel,\ pointer\ to}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ ///\ GeomObject\ that\ defines\ the\ collapsible\ segment\ and\ pointer\ to}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ ///\ TimeStepper\ (defaults\ to\ the\ default\ timestepper,\ Steady).}}
\DoxyCodeLine{\textcolor{comment}{}\ \ \ \ AlgebraicCollapsibleChannelMesh(}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ nup,}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ ncollapsible,}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ ndown,}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ ny,}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ lup,}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ lcollapsible,}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ ldown,}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ ly,}
\DoxyCodeLine{\ \ \ \ \ \ GeomObject*\ wall\_pt,}
\DoxyCodeLine{\ \ \ \ \ \ TimeStepper*\ time\_stepper\_pt\ =\ \&Mesh::Default\_TimeStepper)}
\DoxyCodeLine{\ \ \ \ \ \ :\ CollapsibleChannelMesh<ELEMENT>(nup,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ncollapsible,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ndown,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ny,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lup,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lcollapsible,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ldown,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ly,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ wall\_pt,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ time\_stepper\_pt)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Add\ the\ geometric\ object\ to\ the\ list\ associated\ with\ this\ AlgebraicMesh}}
\DoxyCodeLine{\ \ \ \ \ \ AlgebraicMesh::add\_geom\_object\_list\_pt(wall\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Setup\ algebraic\ node\ update\ operations}}
\DoxyCodeLine{\ \ \ \ \ \ setup\_algebraic\_node\_update();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ ///\ Destructor:\ empty}}
\DoxyCodeLine{\textcolor{comment}{}\ \ \ \ \textcolor{keyword}{virtual}\ \string~AlgebraicCollapsibleChannelMesh()\ \{\}}

\end{DoxyCodeInclude}
 The function {\ttfamily algebraic\+\_\+node\+\_\+update(...)} is defined as a pure virtual function in the {\ttfamily Algebraic\+Mesh} base class and therefore must be implemented, whereas the virtual function {\ttfamily update\+\_\+node\+\_\+update(...)} is only required for refineable meshes and can remain empty.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ ///\ Update\ nodal\ position\ at\ time\ level\ t\ (t=0:\ present;}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ ///\ t>0:\ previous)}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ algebraic\_node\_update(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ t,\ AlgebraicNode*\&\ node\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ ///\ Update\ the\ node-\/udate\ data\ after\ mesh\ adaptation.}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ ///\ Empty\ -\/-\/\ no\ update\ of\ node\ update\ required\ as\ this\ is}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ ///\ non-\/refineable\ mesh.}}
\DoxyCodeLine{\textcolor{comment}{}\ \ \ \ \textcolor{keywordtype}{void}\ update\_node\_update(AlgebraicNode*\&\ node\_pt)\ \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keyword}{protected}:\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ ///\ Function\ to\ setup\ the\ algebraic\ node\ update}}
\DoxyCodeLine{\textcolor{comment}{}\ \ \ \ \textcolor{keywordtype}{void}\ setup\_algebraic\_node\_update();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ ///\ Dummy\ function\ pointer}}
\DoxyCodeLine{\textcolor{comment}{}\ \ \ \ CollapsibleChannelDomain::BLSquashFctPt\ Dummy\_fct\_pt;}
\DoxyCodeLine{\ \ \};}

\end{DoxyCodeInclude}


The setup of the algebraic node update is very similar to that used in the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\texttt{ non-\/\+FSI example discussed earlier.}} The main difference between the two versions of the mesh is that we use the function {\ttfamily Geom\+Object\+::locate\+\_\+zeta(...)} to determine the sub-\/{\ttfamily Geom\+Object} within which the reference point on the wall is located. As discussed above, the default implementation of this function in the {\ttfamily Geom\+Object} base class ensures that the mesh can be used with compound and non-\/compound {\ttfamily Geom\+Objects}.

We start by determining the x and y-\/coordinates of the nodes and decide if they are located in the collapsible part of the mesh. (The positions of nodes that are located in the rigid upstream and downstream channel segments do not have to be updated; for such nodes we skip the assignment of the node-\/update data. See the discussion in the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\texttt{ non-\/\+FSI example}} for details.)

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \textcolor{comment}{//=====start\_setup=================================================}}
\DoxyCodeLine{\textcolor{comment}{\ \ ///\ Setup\ algebraic\ mesh\ update\ -\/-\/\ assumes\ that\ mesh\ has}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ \ ///\ initially\ been\ set\ up\ with\ a\ flush\ upper\ wall}}
\DoxyCodeLine{\textcolor{comment}{}\ \ \textcolor{comment}{//=================================================================}}
\DoxyCodeLine{\ \ \textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{void}\ AlgebraicCollapsibleChannelMesh<ELEMENT>::setup\_algebraic\_node\_update()}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Shorthand\ for\ some\ geometric\ data:}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{double}\ l\_up\ =\ this-\/>domain\_pt()-\/>l\_up();}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{double}\ l\_collapsible\ =\ this-\/>domain\_pt()-\/>l\_collapsible();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Loop\ over\ all\ nodes\ in\ mesh}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{unsigned}\ nnod\ =\ this-\/>nnode();}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ j\ =\ 0;\ j\ <\ nnod;\ j++)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Get\ pointer\ to\ node\ -\/-\/\ recall\ that\ that\ Mesh::node\_pt(...)\ has\ been}}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ overloaded\ in\ the\ AlgebraicMesh\ class\ to\ return\ a\ pointer\ to}}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ an\ AlgebraicNode.}}
\DoxyCodeLine{\ \ \ \ \ \ AlgebraicNode*\ nod\_pt\ =\ node\_pt(j);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Get\ coordinates}}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keywordtype}{double}\ x\ =\ nod\_pt-\/>x(0);}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keywordtype}{double}\ y\ =\ nod\_pt-\/>x(1);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Check\ if\ it's\ in\ the\ collapsible\ part:}}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((x\ >=\ l\_up)\ \&\&\ (x\ <=\ (l\_up\ +\ l\_collapsible)))}

\end{DoxyCodeInclude}
 Assuming that the wall is in its undeformed position (we\textquotesingle{}ll check this in a second...), we determine the intrinsic coordinate of the reference point on the upper wall (taking the offset between $ x$ and $ \zeta$ into account\+: The left end of the elastic wall is located at $ \zeta=0$ and at $ x = L_{up}
$ ), and identify the sub -\/ {\ttfamily Geom\+Object} within which the reference point is located.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ zeta\ coordinate\ on\ the\ undeformed\ wall}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ Vector<double>\ zeta(1);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ zeta[0]\ =\ x\ -\/\ l\_up;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ pointer\ to\ geometric\ (sub-\/)object\ and\ Lagrangian\ coordinate}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ on\ that\ sub-\/object.\ For\ a\ wall\ that\ is\ represented\ by}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ a\ single\ geom\ object,\ this\ simply\ returns\ the\ input.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ the\ geom\ object\ consists\ of\ sub-\/objects\ (e.g.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ if\ it\ is\ a\ finite\ element\ mesh\ representing\ a\ wall,}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ then\ we'll\ obtain\ the\ pointer\ to\ the\ finite\ element}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ (in\ its\ incarnation\ as\ a\ GeomObject)\ and\ the}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ local\ coordinate\ in\ that\ element.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ GeomObject*\ geom\_obj\_pt;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ Vector<double>\ s(1);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ this-\/>Wall\_pt-\/>locate\_zeta(zeta,\ geom\_obj\_pt,\ s);}

\end{DoxyCodeInclude}
 Just to be on the safe side, we double check that the wall is still in its undeformed position\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ position\ vector\ to\ wall:}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ Vector<double>\ r\_wall(2);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ geom\_obj\_pt-\/>position(s,\ r\_wall);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Sanity\ check:\ Confirm\ that\ the\ wall\ is\ in\ its\ undeformed\ position}}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef\ PARANOID}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((std::fabs(r\_wall[0]\ -\/\ x)\ >\ 1.0e-\/15)\ \&\&}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ (std::fabs(r\_wall[1]\ -\/\ y)\ >\ 1.0e-\/15))}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ std::ostringstream\ error\_stream;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ error\_stream\ <<\ \textcolor{stringliteral}{"{}Wall\ must\ be\ in\ its\ undeformed\ position\ when\(\backslash\)n"{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}algebraic\ node\ update\ information\ is\ set\ up!\(\backslash\)n\ "{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}x-\/discrepancy:\ "{}}\ <<\ std::fabs(r\_wall[0]\ -\/\ x)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ std::endl}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}y-\/discrepancy:\ "{}}\ <<\ std::fabs(r\_wall[1]\ -\/\ y)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ OomphLibError(error\_stream.str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ OOMPH\_CURRENT\_FUNCTION,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ OOMPH\_EXCEPTION\_LOCATION);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}

\end{DoxyCodeInclude}
 Now we can create the node update data for the present {\ttfamily Algebraic\+Node}. The node update function involves a single {\ttfamily Geom\+Object\+:} The (sub-\/){\ttfamily Geom\+Object} within which the reference point on the upper wall is located.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ One\ geometric\ object\ is\ involved\ in\ update\ operation}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ Vector<GeomObject*>\ geom\_object\_pt(1);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ actual\ geometric\ object\ (If\ the\ wall\ is\ simple\ GeomObject}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ this\ is\ the\ same\ as\ Wall\_pt;\ if\ it's\ a\ compound\ GeomObject}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ this\ points\ to\ the\ sub-\/object)}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ geom\_object\_pt[0]\ =\ geom\_obj\_pt;}

\end{DoxyCodeInclude}
 As in the mesh used in the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\texttt{ non-\/\+FSI example}} we store the x-\/coordinate of the reference point on the lower wall, the fractional height of the node, and its intrinsic coordinate in the (sub-\/){\ttfamily Geom\+Object} on the upper wall. We also store the intrinsic coordinate of the reference point in the compound {\ttfamily Geom\+Object} (i.\+e. the Lagrangian coordinate of the reference point in the continuous beam). This will turn out to be useful in the refineable version of this mesh, to be discussed in \href{../../fsi_collapsible_channel_adapt/html/index.html}{\texttt{ the next example.}}


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ update\ function\ requires\ four\ \ parameters:}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ Vector<double>\ ref\_value(4);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ First\ reference\ value:\ Original\ x-\/position}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ref\_value[0]\ =\ r\_wall[0];}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Second\ \ reference\ value:\ fractional\ position\ along}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ straight\ line\ from\ the\ bottom\ (at\ the\ original\ x\ position)}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ to\ the\ point\ on\ the\ wall)}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ref\_value[1]\ =\ y\ /\ r\_wall[1];}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Third\ reference\ value:\ Reference\ local\ coordinate}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ in\ wall\ element\ (local\ coordinate\ in\ FE\ if\ we're\ dealing}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ with\ a\ wall\ mesh)}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ref\_value[2]\ =\ s[0];}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Fourth\ reference\ value:\ zeta\ coordinate\ on\ wall}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ the\ wall\ is\ a\ simple\ GeomObject,\ zeta[0]=s[0]}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ but\ if\ it's\ a\ compound\ GeomObject\ (e.g.\ a\ finite\ element\ mesh)}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ zeta\ scales\ during\ mesh\ refinement,\ whereas\ s[0]\ and\ the}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ pointer\ to\ the\ geom\ object\ have\ to\ be\ re-\/computed.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ref\_value[3]\ =\ zeta[0];}

\end{DoxyCodeInclude}
 Finally, we create the node update information by passing the pointer to the mesh, the pointer to the {\ttfamily Geom\+Object} and the reference values to the {\ttfamily Algebraic\+Node}.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Setup\ algebraic\ update\ for\ node:\ Pass\ update\ information}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ nod\_pt-\/>add\_node\_update\_info(\textcolor{keyword}{this},\ \textcolor{comment}{//\ mesh}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ geom\_object\_pt,\ \textcolor{comment}{//\ vector\ of\ geom\ objects}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ref\_value);\ \textcolor{comment}{//\ vector\ of\ \ ref.\ values}}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \}\ \textcolor{comment}{//\ end\ of\ setup\_algebraic\_node\_update}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
\hypertarget{index_driver}{}\doxysection{\texorpdfstring{The driver code}{The driver code}}\label{index_driver}
Since {\ttfamily oomph-\/lib\textquotesingle{}s} various node update procedures use the same interfaces, changing the node update strategy from the {\ttfamily Domain/\+Macro\+Element} -\/ based procedure, discussed in the \href{../../fsi_collapsible_channel/html/index.html}{\texttt{ previous example,}} to the procedure implemented in the {\ttfamily Algebraic\+Collapsible\+Channel\+Mesh}, only requires minimal changes to the driver code. In fact, the changes are so trivial, that both versions are implemented in the same driver code, \href{../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc}{\texttt{ fsi\+\_\+collapsible\+\_\+channel.\+cc}}, using compiler flags to switch from one version to the other. If the code is compiled with the flag {\ttfamily -\/DMACRO\+\_\+\+ELEMENT\+\_\+\+NODE\+\_\+\+UPDATE} the {\ttfamily Domain/\+Macro\+Element} -\/ based node-\/update procedure, implemented in the {\ttfamily Macro\+Element\+Node\+Update\+Collapsible\+Channel\+Mesh} is used, otherwise the code uses the {\ttfamily Algebraic\+Collapsible\+Channel\+Mesh}, discussed above. Here is one of the few portions of the code where the distinction between the two versions is required\+: The access function to the "{}bulk"{} (fluid) mesh in the problem class.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef\ MACRO\_ELEMENT\_NODE\_UPDATE}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Access\ function\ for\ the\ specific\ bulk\ (fluid)\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ MacroElementNodeUpdateCollapsibleChannelMesh<ELEMENT>*\ bulk\_mesh\_pt()\ }
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Upcast\ from\ pointer\ to\ the\ Mesh\ base\ class\ to\ the\ specific\ }}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ element\ type\ that\ we're\ using\ here.}}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{dynamic\_cast<}}
\DoxyCodeLine{\ \ \ \ MacroElementNodeUpdateCollapsibleChannelMesh<ELEMENT>*\textcolor{keyword}{>}}
\DoxyCodeLine{\ \ \ \ (Bulk\_mesh\_pt);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#else}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Access\ function\ for\ the\ specific\ bulk\ (fluid)\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ AlgebraicCollapsibleChannelMesh<ELEMENT>*\ bulk\_mesh\_pt()\ }
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Upcast\ from\ pointer\ to\ the\ Mesh\ base\ class\ to\ the\ specific\ }}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ element\ type\ that\ we're\ using\ here.}}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{dynamic\_cast<}}
\DoxyCodeLine{\ \ \ \ AlgebraicCollapsibleChannelMesh<ELEMENT>*\textcolor{keyword}{>}}
\DoxyCodeLine{\ \ \ \ (Bulk\_mesh\_pt);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}

\end{DoxyCodeInclude}
 Incidentally, the driver code also uses compiler flags to switch between Crouzeix-\/\+Raviart and Taylor-\/\+Hood elements for the discretisation of the Navier-\/\+Stokes equations. By default, Crouzeix-\/\+Raviart elements are used; Taylor-\/\+Hood elements are used if the code is compiled with with the flag {\ttfamily -\/DTAYLOR\+\_\+\+HOOD}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_results}{}\doxysection{\texorpdfstring{Results}{Results}}\label{index_results}
The animations shown below illustrate the interaction between fluid and solid mechanics degrees of freedom in the computations with the algebraic node update. Comparison with the corresponding animations for the {\ttfamily Domain/\+Macro\+Element} -\/ based procedures, shown in the \href{../../fsi_collapsible_channel/html/index.html\#comments}{\texttt{ earlier example}} demonstrates the greatly improved sparsity of the node update. With the algebraic node-\/update procedures, the residuals of the {\ttfamily FSIHermite\+Beam\+Elements} now only depend on the fluid degrees of freedom in the adjacent fluid elements and on the solid mechanics degree of freedom in the {\ttfamily FSIHermite\+Beam\+Elements} that affect the nodal position in these fluid elements.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{cr_alg}
\doxyfigcaption{Animation of the Data values that affect the fluid traction that the adjacent fluid elements exert onto the various FSIHermite\+Beam\+Elements in the wall mesh. (The fluid elements are 2D Crouzeix-\/\+Raviart elements.) }
\end{DoxyImage}


Here is the corresponding animation for a discretisation with 2D Taylor-\/\+Hood elements. These elements have no internal {\ttfamily Data} but the pressure degrees of freedom are stored at the fluid element\textquotesingle{}s corner nodes\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{th_alg}
\doxyfigcaption{Animation of the Data values that affect the fluid traction that the adjacent fluid elements exert onto the various FSIHermite\+Beam\+Elements in the wall mesh. (The fluid elements are 2D Taylor-\/\+Hood elements.) }
\end{DoxyImage}


Finally, here is an animation that shows the (solid mechanics) degrees of freedom that affect the node-\/update of a given fluid node. The red square marker shows the fluid node; the green numbers show the number of the degrees of freedom at the {\ttfamily Solid\+Nodes} that are involved that fluid node\textquotesingle{}s node update. With the algebraic node update, the position of each fluid node is only affected by the solid mechanics degree of freedom in the {\ttfamily FSIHermite\+Beam\+Element} that contains its reference point.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fsi_fluid_nodes}
\doxyfigcaption{Animation of the Data values that affect the node update of the fluid nodes. }
\end{DoxyImage}


The improved sparsity leads to a very significant speedup compared to the {\ttfamily Macro\+Element/\+Domain} -\/ based node update procedure.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_ex}{}\doxysection{\texorpdfstring{Exercises}{Exercises}}\label{index_ex}

\begin{DoxyEnumerate}
\item Demonstrate that the dramatically improved execution speed achieved with the {\ttfamily Algebraic\+Collapsible\+Channel\+Mesh} is mainly due to the improved sparsity of the node update, achieved by using the {\ttfamily Geom\+Object\+::locate\+\_\+zeta(...)} function. ~\newline
~\newline
 {\bfseries{Hint\+:}} You can either copy the basic {\ttfamily My\+Algebraic\+Collapsible\+Channel\+Mesh} in the file \href{../../../../demo_drivers/navier_stokes/collapsible_channel/my_alg_channel_mesh.h}{\texttt{ my\+\_\+algebraic\+\_\+collapsible\+\_\+channel\+\_\+mesh.\+h}}, developed for the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\texttt{ non-\/\+FSI version of the collapsible channel problem,}} into the FSI driver code \href{../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc}{\texttt{ fsi\+\_\+collapsible\+\_\+channel.\+cc}} and use that mesh instead of the {\ttfamily Algebraic\+Collapsible\+Channel\+Mesh}, or replace the line ~\newline
~\newline
 
\begin{DoxyCode}{0}
\DoxyCodeLine{this-\/>Wall\_pt-\/>locate\_zeta(zeta,geom\_obj\_pt,s);}

\end{DoxyCode}
 ~\newline
~\newline
 in the function {\ttfamily Algebraic\+Collapsible\+Channel\+Mesh$<$\+ELEMENT$>$\+::setup\+\_\+algebraic\+\_\+node\+\_\+update()} in \href{../../../../src/meshes/collapsible_channel_mesh.template.cc}{\texttt{ collapsible\+\_\+channel\+\_\+mesh.\+template.\+cc}} by ~\newline
~\newline
 
\begin{DoxyCode}{0}
\DoxyCodeLine{this-\/>Wall\_pt-\/>GeomObject::locate\_zeta(zeta,geom\_obj\_pt,s);}

\end{DoxyCode}
 ~\newline
~\newline
 thus bypassing the "{}sparsification"{}. ~\newline
~\newline

\item Explore how the speedup achievable with the algebraic node update procedure depends on the mesh resolution. A speedup by a factor of ten is typical for computations on the coarse mesh used for the validation runs; much more dramatic speedups tend to be obtained on finer meshes. ~\newline
~\newline
 ~\newline

\end{DoxyEnumerate}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{\texorpdfstring{Source files for this tutorial}{Source files for this tutorial}}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/fsi_collapsible_channel/}{\texttt{ demo\+\_\+drivers/interaction/fsi\+\_\+collapsible\+\_\+channel/ }} \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc}{\texttt{ demo\+\_\+drivers/interaction/fsi\+\_\+collapsible\+\_\+channel/fsi\+\_\+collapsible\+\_\+channel.\+cc }} \end{center} 
\end{DoxyItemize}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{\texorpdfstring{PDF file}{PDF file}}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
