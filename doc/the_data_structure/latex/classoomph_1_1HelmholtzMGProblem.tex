\doxysection{oomph\+::Helmholtz\+MGProblem Class Reference}
\hypertarget{classoomph_1_1HelmholtzMGProblem}{}\label{classoomph_1_1HelmholtzMGProblem}\index{oomph::HelmholtzMGProblem@{oomph::HelmholtzMGProblem}}


\doxylink{classoomph_1_1HelmholtzMGProblem}{Helmholtz\+MGProblem} class; subclass of \doxylink{classoomph_1_1Problem}{Problem}.  




{\ttfamily \#include $<$helmholtz\+\_\+geometric\+\_\+multigrid.\+h$>$}

Inheritance diagram for oomph\+::Helmholtz\+MGProblem\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classoomph_1_1HelmholtzMGProblem}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1HelmholtzMGProblem_ab74fba72dcdfc8f448a992944764cd4c}{Helmholtz\+MGProblem}} ()
\begin{DoxyCompactList}\small\item\em Constructor. Initialise pointers to coarser and finer levels. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1HelmholtzMGProblem_a0cc940bfc51d6e95e420b60938640e54}{\texorpdfstring{$\sim$}{\string~}\+Helmholtz\+MGProblem}} ()
\begin{DoxyCompactList}\small\item\em Destructor (empty) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1HelmholtzMGProblem}{Helmholtz\+MGProblem}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1HelmholtzMGProblem_a174dfbef9a1f46e103e50046c47138e6}{make\+\_\+new\+\_\+problem}} ()=0
\begin{DoxyCompactList}\small\item\em This function needs to be implemented in the derived problem\+: Returns a pointer to a new object of the same type as the derived problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TreeBasedRefineableMeshBase}{Tree\+Based\+Refineable\+Mesh\+Base}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1HelmholtzMGProblem_a647ea79cc9e3e032158aa8416419af8c}{mg\+\_\+bulk\+\_\+mesh\+\_\+pt}} ()=0
\begin{DoxyCompactList}\small\item\em Function to get a pointer to the mesh we will be working with. If there are flux elements present in the mesh this will be overloaded to return a pointer to the bulk mesh otherwise it can be overloaded to point to the global mesh but it must be of type \doxylink{classoomph_1_1RefineableMeshBase}{Refineable\+Mesh\+Base}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classoomph_1_1Problem}{oomph\+::\+Problem}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a36c95c8211cc02558118288888aab5e1}{debug\+\_\+hook\+\_\+fct}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Hook for debugging. Can be overloaded in driver code; argument allows identification of where we\textquotesingle{}re coming from. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_aecef49e98bbcede9b8c3137592c2cc5a}{set\+\_\+analytic\+\_\+dparameter}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Function to turn on analytic calculation of the parameter derivatives in continuation and bifurcation detection problems. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_aff7bcab5505ba482a8c9ba7bace68bc0}{unset\+\_\+analytic\+\_\+dparameter}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Function to turn off analytic calculation of the parameter derivatives in continuation and bifurcation detection problems. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a41a7b9cf8e6fe1156fc92baa43c3fe4b}{is\+\_\+dparameter\+\_\+calculated\+\_\+analytically}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Function to determine whether the parameter derivatives are calculated analytically. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a45f64c33501e0f9c65927eefed253eef}{set\+\_\+analytic\+\_\+hessian\+\_\+products}} ()
\begin{DoxyCompactList}\small\item\em Function to turn on analytic calculation of the parameter derivatives in continuation and bifurcation detection problems. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_accd672b3da8c5bf28ad6bd856e28d1cf}{unset\+\_\+analytic\+\_\+hessian\+\_\+products}} ()
\begin{DoxyCompactList}\small\item\em Function to turn off analytic calculation of the parameter derivatives in continuation and bifurcation detection problems. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_af6235ced9e7e85324f785f2681ab3872}{are\+\_\+hessian\+\_\+products\+\_\+calculated\+\_\+analytically}} ()
\begin{DoxyCompactList}\small\item\em Function to determine whether the hessian products are calculated analytically. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a820d3c43c7d678b4fe186a8c83a90732}{set\+\_\+pinned\+\_\+values\+\_\+to\+\_\+zero}} ()
\begin{DoxyCompactList}\small\item\em Set all pinned values to zero. Used to set boundary conditions to be homogeneous in the copy of the problem used in adaptive bifurcation tracking (ALH\+: TEMPORARY HACK, WILL BE FIXED) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_af5e9f1623cad361048856a4c0463ea23}{distributed}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em If we have MPI return the "{}problem has been distributed"{} flag, otherwise it can\textquotesingle{}t be distributed so return false. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402}{Distributed\+\_\+problem\+\_\+matrix\+\_\+distribution}} \& \mbox{\hyperlink{classoomph_1_1Problem_ade5ea0368c7d37a11567f834e97871ae}{distributed\+\_\+problem\+\_\+matrix\+\_\+distribution}} ()
\begin{DoxyCompactList}\small\item\em accesss function to the distributed matrix distribution method 1 -\/ Automatic -\/ the \doxylink{classoomph_1_1Problem}{Problem} distribution is employed, unless any processor has number of rows equal to 110\% of N/P, in which case uniform distribution is employed. 2 -\/ \doxylink{classoomph_1_1Problem}{Problem} -\/ the jacobian on processor p only contains rows that correspond to equations that are on this processor. (minimises communication) 3 -\/ Uniform -\/ each processor holds as close to N/P matrix rows as possible. (very well load balanced) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a577bca9cc5ee9504480b372f82e924dd}{enable\+\_\+doc\+\_\+imbalance\+\_\+in\+\_\+parallel\+\_\+assembly}} ()
\begin{DoxyCompactList}\small\item\em Enable doc of load imbalance in parallel assembly of distributed problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a9365d2b0057089ae5551b97488a3a62a}{disable\+\_\+doc\+\_\+imbalance\+\_\+in\+\_\+parallel\+\_\+assembly}} ()
\begin{DoxyCompactList}\small\item\em Disable doc of load imbalance in parallel assembly of distributed problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ \mbox{\hyperlink{classoomph_1_1Problem_ac5eb0ed2c07c8d0c5d6246394d335c73}{elemental\+\_\+assembly\+\_\+time}} ()
\begin{DoxyCompactList}\small\item\em Return vector of most-\/recent elemental assembly times (used for load balancing). Zero sized if no Jacobian has been computed since last re-\/assignment of equation numbers. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a07bad546a91f9d13936be6dc0590fcd0}{clear\+\_\+elemental\+\_\+assembly\+\_\+time}} ()
\begin{DoxyCompactList}\small\item\em Clear storage of most-\/recent elemental assembly times (used for load balancing). Next load balancing operation will be based on the number of elements associated with a tree root. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a3fe4edae6a97460405e7f667d7d4f406}{enable\+\_\+problem\+\_\+distributed}} ()
\begin{DoxyCompactList}\small\item\em Enable problem distributed. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a79752d23035158783ad19711027984dc}{disable\+\_\+problem\+\_\+distributed}} ()
\begin{DoxyCompactList}\small\item\em Disable problem distributed. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ab002dc7a6faf97a1bfcd9c098a04f840}{set\+\_\+default\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly}} ()
\begin{DoxyCompactList}\small\item\em Set default first and last elements for parallel assembly of non-\/distributed problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ac4dec80ab9a6834e10b2c2b0119e7133}{set\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{first\+\_\+el\+\_\+for\+\_\+assembly}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{last\+\_\+el\+\_\+for\+\_\+assembly}})
\begin{DoxyCompactList}\small\item\em Manually set first and last elements for parallel assembly of non-\/distributed problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a22b3818d62b66e5cb52d72dcccc037fa}{get\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{first\+\_\+el\+\_\+for\+\_\+assembly}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{last\+\_\+el\+\_\+for\+\_\+assembly}}) \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Get first and last elements for parallel assembly of non-\/distributed problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a6130d5c9a762cdd1569919a601620796}{actions\+\_\+before\+\_\+adapt}} ()
\begin{DoxyCompactList}\small\item\em Actions that are to be performed before a mesh adaptation. These might include removing any additional elements, such as traction boundary elements before the adaptation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ada40ec6730506c01109622c8383fe36e}{actions\+\_\+after\+\_\+adapt}} ()
\begin{DoxyCompactList}\small\item\em Actions that are to be performed after a mesh adaptation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1OomphCommunicator}{Oomph\+Communicator}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_a22e2521bc620ad0cc542213a24f31252}{communicator\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em access function to the oomph-\/lib communicator \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1OomphCommunicator}{Oomph\+Communicator}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_a48dfe9ec665e5d0b1e388dfb6ff1410d}{communicator\+\_\+pt}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em access function to the oomph-\/lib communicator, const version \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Problem_a3f071f2f8be895dbe0d39d12ca59acf4}{Problem}} ()
\begin{DoxyCompactList}\small\item\em Constructor\+: Allocate space for one time stepper and set all pointers to NULL and set defaults for all parameters. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Problem_a32f06ae01ba0bf2e827ccd9045c40183}{Problem}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{dummy}})=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{delete}}
\begin{DoxyCompactList}\small\item\em Broken copy constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ae015f3c07e2218748b347f42abe45da1}{operator=}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} \&)=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{delete}}
\begin{DoxyCompactList}\small\item\em Broken assignment operator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1Problem_ae2cd468ec03f7ede23c0dc8eea3be1cf}{\texorpdfstring{$\sim$}{\string~}\+Problem}} ()
\begin{DoxyCompactList}\small\item\em Virtual destructor to clean up memory. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} \texorpdfstring{$\ast$}{*}\& \mbox{\hyperlink{classoomph_1_1Problem_ae2e5559918832d0850b3631d004d0a37}{mesh\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the global mesh. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \& \mbox{\hyperlink{classoomph_1_1Problem_ae9d76749515ec4274cd3423525e99927}{mesh\+\_\+pt}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return a pointer to the global mesh (const version) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} \texorpdfstring{$\ast$}{*}\& \mbox{\hyperlink{classoomph_1_1Problem_a38b79f9b4eebfab308e76e8308c986f5}{mesh\+\_\+pt}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{imesh}})
\begin{DoxyCompactList}\small\item\em Return a pointer to the i-\/th submesh. If there are no submeshes, the 0-\/th submesh is the global mesh itself. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \& \mbox{\hyperlink{classoomph_1_1Problem_af190ef623ce39436c7c4b6763a040117}{mesh\+\_\+pt}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{imesh}}) \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return a pointer to the i-\/th submesh (const version) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_accc4e5a46953800933f07ae6bd67860e}{nsub\+\_\+mesh}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return number of submeshes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_a0cd05109bc2c003c5c0686e6aa55d847}{add\+\_\+sub\+\_\+mesh}} (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1Problem_ae2e5559918832d0850b3631d004d0a37}{mesh\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Add a submesh to the problem and return its number, i, by which it can be accessed via mesh\+\_\+pt(i). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a42b2b42a03f9de7d7a4d24edcfa20179}{flush\+\_\+sub\+\_\+meshes}} ()
\begin{DoxyCompactList}\small\item\em Flush the problem\textquotesingle{}s collection of sub-\/meshes. Must be followed by call to \doxylink{classoomph_1_1Problem_ac0a0e649f36b4a7ce992888c323d1571}{rebuild\+\_\+global\+\_\+mesh()}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a0faad6f705a6dc0ffe27229f9104ed7c}{build\+\_\+global\+\_\+mesh}} ()
\begin{DoxyCompactList}\small\item\em Build the global mesh by combining the all the submeshes. {\bfseries{Note\+:}} The nodes boundary information refers to the boundary numbers within the submesh! \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ac0a0e649f36b4a7ce992888c323d1571}{rebuild\+\_\+global\+\_\+mesh}} ()
\begin{DoxyCompactList}\small\item\em If one of the submeshes has changed (e.\+g. by mesh adaptation) we need to update the global mesh. {\bfseries{Note\+:}} The nodes boundary information refers to the boundary numbers within the submesh! \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a220816aebf8c74c6c524088e3da4d793}{build\+\_\+mesh}} ()
\begin{DoxyCompactList}\small\item\em Function to build the \doxylink{classoomph_1_1Problem}{Problem}\textquotesingle{}s base mesh; this must be supplied by the user if they wish to use the \doxylink{classoomph_1_1Problem_ad6309367fa379889012f25e3397ab425}{load\+\_\+balance()} functionality, which is only available to problems that have already been distributed. If the problem has multiple meshes, each mesh must be built, added as as a submesh, and a call to \doxylink{classoomph_1_1Problem_a0faad6f705a6dc0ffe27229f9104ed7c}{build\+\_\+global\+\_\+mesh()} must be made in this function. On return from this function all meshes must have been refined to the same level that they were in the when \doxylink{classoomph_1_1Problem_aa35e1adc0fdf14b217c7b608eb9cf20b}{Problem\+::distribute()} was first called. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ad6309367fa379889012f25e3397ab425}{load\+\_\+balance}} ()
\begin{DoxyCompactList}\small\item\em Balance the load of a (possibly non-\/uniformly refined) problem that has already been distributed, by re-\/distributing elements over processors. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a1d78ad991995dca1f71ae83ccaa83e25}{load\+\_\+balance}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{report\+\_\+stats}})
\begin{DoxyCompactList}\small\item\em Balance the load of a (possibly non-\/uniformly refined) problem that has already been distributed, by re-\/distributing elements over processors. Produce explicit stats of load balancing process if boolean, report\+\_\+stats, is set to true. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_abc2a02507c85322024b9859bfbd5b7bf}{load\+\_\+balance}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{report\+\_\+stats}})
\begin{DoxyCompactList}\small\item\em Balance the load of a (possibly non-\/uniformly refined) problem that has already been distributed, by re-\/distributing elements over processors. Produce explicit stats of load balancing process if boolean, report\+\_\+stats, is set to true. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a7492ddb5663552ce8f61f1ef73c86a9d}{load\+\_\+balance}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{report\+\_\+stats}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{input\+\_\+target\+\_\+domain\+\_\+for\+\_\+local\+\_\+non\+\_\+halo\+\_\+element}})
\begin{DoxyCompactList}\small\item\em Balance the load of a (possibly non-\/uniformly refined) problem that has already been distributed, by re-\/distributing elements over processors. Produce explicit stats of load balancing process if boolean, report\+\_\+stats, is set to true and doc various bits of data (mainly for debugging) in directory specified by \doxylink{classoomph_1_1DocInfo}{Doc\+Info} object. If final input vector is non-\/zero-\/sized it provides an imposed partitioning. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a23e641f64f436d4911c53c0f5c7ff239}{set\+\_\+default\+\_\+partition\+\_\+in\+\_\+load\+\_\+balance}} ()
\begin{DoxyCompactList}\small\item\em Set the use of the default partition in the load balance. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a1157876a05d112d523be03d9c30464de}{unset\+\_\+default\+\_\+partition\+\_\+in\+\_\+load\+\_\+balance}} ()
\begin{DoxyCompactList}\small\item\em Do not use the default partition in the load balance. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ac969abcf440b4f631061e74316391b3a}{refine\+\_\+distributed\+\_\+base\+\_\+mesh}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ $>$ $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{to\+\_\+be\+\_\+refined\+\_\+on\+\_\+each\+\_\+root}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{max\+\_\+level\+\_\+overall}})
\begin{DoxyCompactList}\small\item\em Load balance helper routine\+: refine each new base (sub)mesh based upon the elements to be refined within each tree at each root on the current processor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} \texorpdfstring{$\ast$}{*}\& \mbox{\hyperlink{classoomph_1_1Problem_ac7276ac27f16ea9b90cd6008b365c85a}{linear\+\_\+solver\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the linear solver object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \& \mbox{\hyperlink{classoomph_1_1Problem_a1d35caec836747fb49e7184958bb702b}{linear\+\_\+solver\+\_\+pt}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return a pointer to the linear solver object (const version) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} \texorpdfstring{$\ast$}{*}\& \mbox{\hyperlink{classoomph_1_1Problem_a9612322b1a2e4f297b450674ae7904d3}{mass\+\_\+matrix\+\_\+solver\+\_\+for\+\_\+explicit\+\_\+timestepper\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the linear solver object used for explicit time stepping. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_aff8f267124732ad95d961e25b9c27178}{mass\+\_\+matrix\+\_\+solver\+\_\+for\+\_\+explicit\+\_\+timestepper\+\_\+pt}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return a pointer to the linear solver object used for explicit time stepping (const version). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1EigenSolver}{Eigen\+Solver}} \texorpdfstring{$\ast$}{*}\& \mbox{\hyperlink{classoomph_1_1Problem_a42c2d53585a6d4c3d779c1f495770abc}{eigen\+\_\+solver\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the eigen solver object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1EigenSolver}{Eigen\+Solver}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \& \mbox{\hyperlink{classoomph_1_1Problem_a52ef488b05f0c8532f67aa69ac41d68a}{eigen\+\_\+solver\+\_\+pt}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return a pointer to the eigen solver object (const version) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Time}{Time}} \texorpdfstring{$\ast$}{*}\& \mbox{\hyperlink{classoomph_1_1Problem_ae87f0d17b929d9b6097e19c2507c87f9}{time\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the global time object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Time}{Time}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_adfa7a89cbbae5de1cb1aea1ce0264b48}{time\+\_\+pt}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return a pointer to the global time object (const version). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \& \mbox{\hyperlink{classoomph_1_1Problem_acd8c357349d20a28af70b2b7ea7f488d}{time}} ()
\begin{DoxyCompactList}\small\item\em Return the current value of continuous time. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_a925acb2e840deb4edc6305da8fced0e3}{time}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return the current value of continuous time (const version) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}} \texorpdfstring{$\ast$}{*}\& \mbox{\hyperlink{classoomph_1_1Problem_aa6bb90130ac5bb220493c40cddf520ba}{time\+\_\+stepper\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Access function for the pointer to the first (presumably only) timestepper. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_a477c959c3dcef58ba00b0bf0a47dbb0b}{time\+\_\+stepper\+\_\+pt}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Access function for the pointer to the first (presumably only) timestepper. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}} \texorpdfstring{$\ast$}{*}\& \mbox{\hyperlink{classoomph_1_1Problem_ae8f35140fd531b04d2cf10c60a19221b}{time\+\_\+stepper\+\_\+pt}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Return a pointer to the i-\/th timestepper. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1ExplicitTimeStepper}{Explicit\+Time\+Stepper}} \texorpdfstring{$\ast$}{*}\& \mbox{\hyperlink{classoomph_1_1Problem_ab69ae6020f1886e7b288180b6130b7ed}{explicit\+\_\+time\+\_\+stepper\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the explicit timestepper. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{long}} \mbox{\hyperlink{classoomph_1_1Problem_a7be66e9917b39eaea90b91389f5a72fb}{set\+\_\+timestepper\+\_\+for\+\_\+all\+\_\+data}} (\mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1Problem_aa6bb90130ac5bb220493c40cddf520ba}{time\+\_\+stepper\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{preserve\+\_\+existing\+\_\+data}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{false}})
\begin{DoxyCompactList}\small\item\em Set all problem data to have the same timestepper (timestepper\+\_\+pt) Return the new number of dofs in the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_aab27bdd1968e57cb3dffe78c1d63f762}{shift\+\_\+time\+\_\+values}} ()
\begin{DoxyCompactList}\small\item\em Shift all values along to prepare for next timestep. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}} \texorpdfstring{$\ast$}{*}\& \mbox{\hyperlink{classoomph_1_1Problem_ae9bdfd163f7e94e89bfcdc1f229e3743}{assembly\+\_\+handler\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the assembly handler object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \& \mbox{\hyperlink{classoomph_1_1Problem_a342271aa063b5356ac966b86eb0a6a67}{assembly\+\_\+handler\+\_\+pt}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return a pointer to the assembly handler object (const version) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \& \mbox{\hyperlink{classoomph_1_1Problem_a4eb917646edc32ebe51437a4a4588bdf}{minimum\+\_\+dt}} ()
\begin{DoxyCompactList}\small\item\em Access function to min timestep in adaptive timestepping. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \& \mbox{\hyperlink{classoomph_1_1Problem_a7e639985add8cb1627f45fc2a0b9580e}{maximum\+\_\+dt}} ()
\begin{DoxyCompactList}\small\item\em Access function to max timestep in adaptive timestepping. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \& \mbox{\hyperlink{classoomph_1_1Problem_a59740d6fa1e2a7c0808f805e8f44bc45}{max\+\_\+newton\+\_\+iterations}} ()
\begin{DoxyCompactList}\small\item\em Access function to max Newton iterations before giving up. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a92acc3c193a38f321fc318fafd142f7a}{problem\+\_\+is\+\_\+nonlinear}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{prob\+\_\+lin}})
\begin{DoxyCompactList}\small\item\em Access function to Problem\+\_\+is\+\_\+nonlinear. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \& \mbox{\hyperlink{classoomph_1_1Problem_af403c426a15f0cb4140588af379d01a5}{max\+\_\+residuals}} ()
\begin{DoxyCompactList}\small\item\em Access function to max residuals in Newton iterations before giving up. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \& \mbox{\hyperlink{classoomph_1_1Problem_a2dee4cc7ff12b86b393b66ffa2896e99}{time\+\_\+adaptive\+\_\+newton\+\_\+crash\+\_\+on\+\_\+solve\+\_\+fail}} ()
\begin{DoxyCompactList}\small\item\em Access function for Time\+\_\+adaptive\+\_\+newton\+\_\+crash\+\_\+on\+\_\+solve\+\_\+fail. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \& \mbox{\hyperlink{classoomph_1_1Problem_ae627e96507990c2aca681abaea60b53d}{newton\+\_\+solver\+\_\+tolerance}} ()
\begin{DoxyCompactList}\small\item\em Access function to tolererance of the Newton solver, i.\+e. the maximum value of the residuals that will be accepted. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a8856eae2daa9cea05e99bfcd4ef340a4}{add\+\_\+time\+\_\+stepper\+\_\+pt}} (\mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1Problem_aa6bb90130ac5bb220493c40cddf520ba}{time\+\_\+stepper\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Add a timestepper to the problem. The function will automatically create or resize the \doxylink{classoomph_1_1Time}{Time} object so that it contains the appropriate number of levels of storage. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a4cf44478e6f6abe95063b7bb2dd530a0}{set\+\_\+explicit\+\_\+time\+\_\+stepper\+\_\+pt}} (\mbox{\hyperlink{classoomph_1_1ExplicitTimeStepper}{Explicit\+Time\+Stepper}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1Problem_ab69ae6020f1886e7b288180b6130b7ed}{explicit\+\_\+time\+\_\+stepper\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Set the explicit timestepper for the problem. The function will automatically create or resize the \doxylink{classoomph_1_1Time}{Time} object so that it contains the appropriate number of levels of storage. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a342b9bd9c4bc142f514907ee1d23d613}{initialise\+\_\+dt}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&dt)
\begin{DoxyCompactList}\small\item\em Set all timesteps to the same value, dt, and assign weights for all timesteppers in the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a48137f1c7b297de56078f6bc0c83b675}{initialise\+\_\+dt}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ \&dt)
\begin{DoxyCompactList}\small\item\em Set the value of the timesteps to be equal to the values passed in a vector and assign weights for all timesteppers in the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Data}{Data}} \texorpdfstring{$\ast$}{*}\& \mbox{\hyperlink{classoomph_1_1Problem_a91a255f86e3af72ba1f27d9dee363927}{global\+\_\+data\+\_\+pt}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Return a pointer to the the i-\/th global data object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a6f0c24728351d390d4f0a86d07bd8678}{add\+\_\+global\+\_\+data}} (\mbox{\hyperlink{classoomph_1_1Data}{Data}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1Problem_a91a255f86e3af72ba1f27d9dee363927}{global\+\_\+data\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Add \doxylink{classoomph_1_1Data}{Data} to the \doxylink{classoomph_1_1Problem}{Problem}\textquotesingle{}s global data -- the \doxylink{classoomph_1_1Problem}{Problem} will perform equation numbering etc. for such \doxylink{classoomph_1_1Data}{Data}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_aa8df5552c706bd949b29f5601f8c941e}{flush\+\_\+global\+\_\+data}} ()
\begin{DoxyCompactList}\small\item\em Flush the \doxylink{classoomph_1_1Problem}{Problem}\textquotesingle{}s global data -- resizes container to zero. \doxylink{classoomph_1_1Data}{Data} objects are not deleted! \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a9af22a1cfead13bcad14c1b78d1cf273}{create\+\_\+new\+\_\+linear\+\_\+algebra\+\_\+distribution}} (\mbox{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution}} \texorpdfstring{$\ast$}{*}\&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{dist\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Get new linear algebra distribution (you\textquotesingle{}re in charge of deleting it!) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \& \mbox{\hyperlink{classoomph_1_1Problem_a8bb8d8763e755fac464c836c1427c412}{dof\+\_\+distribution\+\_\+pt}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return the pointer to the dof distribution (read-\/only) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{long}} \mbox{\hyperlink{classoomph_1_1Problem_a218d4dfff74bc14f3f5dc8416236e01d}{ndof}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return the number of dofs. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_ace3cdf55009c3bff21d2b7d3706d522a}{ntime\+\_\+stepper}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return the number of time steppers. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_a60a9b6861928cf9115110b5bfc7d11a7}{nglobal\+\_\+data}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return the number of global data values. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_acdb76c0b94aa3cc5470ce862d70a8017}{self\+\_\+test}} ()
\begin{DoxyCompactList}\small\item\em Self-\/test\+: Check meshes and global data. Return 0 for OK. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a31ba79405993ec52e3017d6ff3a42c8c}{enable\+\_\+store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements}} ()
\begin{DoxyCompactList}\small\item\em Insist that local dof pointers are set up in each element when equation numbering takes place. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ac23468bc4101d3038e6b537b6fc87aa6}{disable\+\_\+store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements}} ()
\begin{DoxyCompactList}\small\item\em Insist that local dof pointers are NOT set up in each element when equation numbering takes place (the default) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{long}} \mbox{\hyperlink{classoomph_1_1Problem_a0df501c6aed60c4938861df776b10119}{assign\+\_\+eqn\+\_\+numbers}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&assign\+\_\+local\+\_\+eqn\+\_\+numbers=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Assign all equation numbers for problem\+: Deals with global data (= data that isn\textquotesingle{}t attached to any elements) and then does the equation numbering for the elements. Virtual so it can be overloaded in MPI problems. Bool argument can be set to false to ignore assigning local equation numbers (found to be necessary in the parallel implementation of locate\+\_\+zeta between multiple meshes). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a0563ae60b5c372087398fc3c45af757d}{describe\+\_\+dofs}} (std\+::ostream \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{out}}= \texorpdfstring{$\ast$}{*}(oomph\+\_\+info.\+stream\+\_\+pt())) \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Function to describe the dofs in terms of the global equation number, i.\+e. what type of value (nodal value of a \doxylink{classoomph_1_1Node}{Node}; value in a \doxylink{classoomph_1_1Data}{Data} object; value of internal \doxylink{classoomph_1_1Data}{Data} in an element; etc) is the unknown with a certain global equation number. Output stream defaults to oomph\+\_\+info. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_af4fbd755b3ce6b86fa0f1b1f29bd08f0}{enable\+\_\+discontinuous\+\_\+formulation}} ()
\begin{DoxyCompactList}\small\item\em Indicate that the problem involves discontinuous elements This allows for a more efficiently assembly and inversion of the mass matrix. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_afa64d728ceff0dd772bbbc8f2adcddfb}{disable\+\_\+discontinuous\+\_\+formulation}} ()
\begin{DoxyCompactList}\small\item\em Disable the use of a discontinuous-\/element formulation. Note that the methods will all still work even if the elements are discontinuous, we will just be assembling a larger system matrix than necessary. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ae2ef66732d76053dba15001818c0605c}{get\+\_\+dofs}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{dofs}}) \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return the vector of dofs, i.\+e. a vector containing the current values of all unknowns. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_abb56c404b0dd6df75bcadab797d9a24e}{get\+\_\+dofs}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}}, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{dofs}}) \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return vector of the t\textquotesingle{}th history value of all dofs. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ab51480d18550c107c9f13629102f6b08}{set\+\_\+dofs}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{dofs}})
\begin{DoxyCompactList}\small\item\em Set the values of the dofs. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a62d7dbbf49388e6383e3b93e50351e89}{set\+\_\+dofs}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}}, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{dofs}})
\begin{DoxyCompactList}\small\item\em Set the history values of the dofs. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a4b01ea8bfa914f1c9f40f9a2a7aa8ad5}{set\+\_\+dofs}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{classoomph_1_1Problem_a8f48134fe83371d3cc3605772e76d043}{dof\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Set history values of dofs from the type of vector stored in problem\+::\+Dof\+\_\+pt. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a352210408b3eed3e7a834b8b9a33a99a}{add\+\_\+to\+\_\+dofs}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&lambda, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{increment\+\_\+dofs}})
\begin{DoxyCompactList}\small\item\em Add lambda x incremenet\+\_\+dofs\mbox{[}l\mbox{]} to the l-\/th dof. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_a07460d9854a692ffda3d6e318e5ad395}{global\+\_\+dof\+\_\+pt}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Return a pointer to the dof, indexed by global equation number which may be haloed or stored locally. If it is haloed, a local copy must have been requested on this processor in the Halo\+\_\+scheme\+\_\+pt. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \& \mbox{\hyperlink{classoomph_1_1Problem_a2c025f1ba8a9f67bd7ee2dc70462b49a}{dof}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em i-\/th dof in the problem \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_a200cbd03828632d448c3525e9a921f27}{dof}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}}) \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em i-\/th dof in the problem (const version) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\& \mbox{\hyperlink{classoomph_1_1Problem_a8f48134fe83371d3cc3605772e76d043}{dof\+\_\+pt}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Pointer to i-\/th dof in the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_aadc3c0c13920df62cfa5e232d8797e0e}{dof\+\_\+pt}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}}) \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Pointer to i-\/th dof in the problem (const version) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a8d7cc317f4900e076dec400ce2493c19}{get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{Mres}})
\begin{DoxyCompactList}\small\item\em Return the residual vector multiplied by the inverse mass matrix Virtual so that it can be overloaded for mpi problems. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a2d456362f4408556e879871ae34e57f1}{get\+\_\+dvaluesdt}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&f)
\begin{DoxyCompactList}\small\item\em Get the time derivative of all values (using get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals(..) with all time steppers set to steady) e.\+g. for use in explicit time steps. The approach used is slighty hacky, beware if you have a residual which is non-\/linear or implicit in the derivative or if you have overloaded get\+\_\+jacobian(...). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a7300386d91390e3e5be993aca7459498}{get\+\_\+residuals}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{residuals}})
\begin{DoxyCompactList}\small\item\em Return the fully-\/assembled residuals \doxylink{classoomph_1_1Vector}{Vector} for the problem\+: Virtual so it can be overloaded in for mpi problems. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a4ba83bbea19db3a530539f3e9f88a7e4}{get\+\_\+jacobian}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{residuals}}, \mbox{\hyperlink{classoomph_1_1DenseDoubleMatrix}{Dense\+Double\+Matrix}} \&jacobian)
\begin{DoxyCompactList}\small\item\em Return the fully-\/assembled Jacobian and residuals for the problem Interface for the case when the Jacobian matrix is dense. This is virtual so, if we feel like it (e.\+g. for testing iterative solvers with specific test matrices, we can bypass the default assembly procedure for the Jacobian and the residual vector. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a1369827c6970abfd41deae4ef185822c}{get\+\_\+jacobian}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{residuals}}, \mbox{\hyperlink{classoomph_1_1CRDoubleMatrix}{CRDouble\+Matrix}} \&jacobian)
\begin{DoxyCompactList}\small\item\em Return the fully-\/assembled Jacobian and residuals for the problem. Interface for the case when the Jacobian is in row-\/compressed storage format. This is virtual so, if we feel like it (e.\+g. for testing iterative solvers with specific test matrices), we can bypass the default assembly procedure for the Jacobian and the residual vector. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a9e6c6d71f95d96943a1a8487b6131e89}{get\+\_\+jacobian}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{residuals}}, \mbox{\hyperlink{classoomph_1_1CCDoubleMatrix}{CCDouble\+Matrix}} \&jacobian)
\begin{DoxyCompactList}\small\item\em Return the fully-\/assembled Jacobian and residuals for the problem. Interface for the case when the Jacobian is in column-\/compressed storage format. This is virtual so, if we feel like it (e.\+g. for testing iterative solvers with specific test matrices), we can bypass the default assembly procedure for the Jacobian and the residual vector. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a0db16f9bcac7af964d0fecc8b6a5ea63}{get\+\_\+jacobian}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{residuals}}, \mbox{\hyperlink{classoomph_1_1SumOfMatrices}{Sum\+Of\+Matrices}} \&jacobian)
\begin{DoxyCompactList}\small\item\em Dummy virtual function that must be overloaded by the problem to specify which matrices should be summed to give the final Jacobian. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a74f6540dc7228b21f5bc07c0477dfbe7}{get\+\_\+fd\+\_\+jacobian}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{residuals}}, \mbox{\hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ \&jacobian)
\begin{DoxyCompactList}\small\item\em Return the fully-\/assembled Jacobian and residuals, generated by finite differences. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_af4d959a47ef6a8d50b394a6761dfab5a}{get\+\_\+derivative\+\_\+wrt\+\_\+global\+\_\+parameter}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{result}})
\begin{DoxyCompactList}\small\item\em Get the derivative of the entire residuals vector wrt a global parameter, used in continuation problems. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ac65cbe00a72cfc91ccaea10818f1a507}{get\+\_\+hessian\+\_\+vector\+\_\+products}} (\mbox{\hyperlink{classoomph_1_1DoubleVectorWithHaloEntries}{Double\+Vector\+With\+Halo\+Entries}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&Y, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVectorWithHaloEntries}{Double\+Vector\+With\+Halo\+Entries}} $>$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&C, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVectorWithHaloEntries}{Double\+Vector\+With\+Halo\+Entries}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{product}})
\begin{DoxyCompactList}\small\item\em Return the product of the global hessian (derivative of Jacobian matrix with respect to all variables) with an eigenvector, Y, and any number of other specified vectors C (d(J\+\_\+\{ij\})/d u\+\_\+\{k\}) Y\+\_\+\{j\} C\+\_\+\{k\}. This function is used in assembling and solving the augmented systems associated with bifurcation tracking. The default implementation is to use finite differences at the global level. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a98de327e3fe008a4938b0811f68d3d37}{solve\+\_\+eigenproblem\+\_\+legacy}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+eval}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ $>$ \&eigenvalue, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{eigenvector}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{steady}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Get derivative of an element in the problem wrt a global parameter, used in continuation problems. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ac7268c8577c77998039bc9212c7a74cf}{solve\+\_\+eigenproblem\+\_\+legacy}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+eval}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ $>$ \&eigenvalue, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{steady}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Solve an eigenproblem as assembled by the \doxylink{classoomph_1_1Problem}{Problem}\textquotesingle{}s constituent elements. Calculate (at least) n\+\_\+eval eigenvalues. The boolean flag (default true) specifies whether the steady jacobian should be assembled. If the flag is false then the weighted mass-\/matrix terms from the timestepper will be included in the jacobian --- this is almost certainly never wanted. Legacy version. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_aed5cddb2d3f536dbe9e499f228ba6e5c}{solve\+\_\+eigenproblem}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+eval}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ $>$ \&alpha, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ \&beta, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{eigenvector\+\_\+real}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{eigenvector\+\_\+imag}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{steady}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Solve an eigenproblem as assembled by the \doxylink{classoomph_1_1Problem}{Problem}\textquotesingle{}s constituent elements. Calculate (at least) n\+\_\+eval eigenvalues and return the corresponding eigenvectors. The boolean flag (default true) specifies whether the steady jacobian should be assembled. If the flag is false then the weighted mass-\/matrix terms from the timestepper will be included in the jacobian --- this is almost certainly never wanted. The eigenvalues and eigenvectors are, in general, complex. Eigenvalues may be infinite and are therefore returned as $ \lambda_i = \alpha_i / \beta_i $ where $ \alpha_i $ is complex while $ \beta_i $ is real. The actual eigenvalues may then be computed by doing the division, checking for zero betas to avoid Na\+Ns. There\textquotesingle{}s a convenience wrapper to this function that simply computes these eigenvalues regardless. That version may die in NaN checking is enabled (via the fenv.\+h header and the associated feenable function). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ab8d83ff2aa9849080af09bebd8701d1c}{solve\+\_\+eigenproblem}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+eval}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ $>$ \&eigenvalue, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{eigenvector\+\_\+real}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{eigenvector\+\_\+imag}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{steady}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Solve an eigenproblem as assembled by the \doxylink{classoomph_1_1Problem}{Problem}\textquotesingle{}s constituent elements. Calculate (at least) n\+\_\+eval eigenvalues and return the corresponding eigenvectors. The boolean flag (default true) specifies whether the steady jacobian should be assembled. If the flag is false then the weighted mass-\/matrix terms from the timestepper will be included in the jacobian --- this is almost certainly never wanted. Note that the eigenvalues and eigenvectors are, in general, complex and the eigenvalues may be infinite. In this case it\textquotesingle{}s safer to use the other version of this function which returns the eigenvalues in terms of a fractional representation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a26fc480802aa2182327a7362b9cf37a6}{solve\+\_\+eigenproblem}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+eval}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ $>$ \&eigenvalue, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{make\+\_\+timesteppers\+\_\+steady}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Solve an eigenproblem as assembled by the \doxylink{classoomph_1_1Problem}{Problem}\textquotesingle{}s constituent elements but only return the eigenvalues, not the eigenvectors. At least n\+\_\+eval eigenvalues are computed. The boolean flag (default true) is used to specify whether the weighted mass-\/matrix terms from the timestepping scheme should be included in the jacobian --- this is almost certainly never wanted. Note that the eigenvalues may be infinite. In this case it\textquotesingle{}s safer to use the other version of this function which returns the eigenvalues in terms of a fractional representation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ad728fd2cc379675af7eb40ca387d3258}{solve\+\_\+eigenproblem}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+eval}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ $>$ \&alpha, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ \&beta, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{steady}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Solve an eigenproblem as assembled by the \doxylink{classoomph_1_1Problem}{Problem}\textquotesingle{}s constituent elements but only return the eigenvalues, not the eigenvectors. At least n\+\_\+eval eigenvalues are computed. The boolean flag (default true) is used to specify whether the weighted mass-\/matrix terms from the timestepping scheme should be included in the jacobian --- this is almost certainly never wanted. Note that the eigenvalues may be infinite and are therefore returned as $ \lambda_i = \alpha_i / \beta_i $ where $ \alpha_i $ is complex while $ \beta_i $ is real. The actual eigenvalues may then be computed by doing the division, checking for zero betas to avoid Na\+Ns. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ac196c23b3dc825524f23676951d5273d}{solve\+\_\+adjoint\+\_\+eigenproblem\+\_\+legacy}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+eval}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ $>$ \&eigenvalue, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{eigenvector}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{make\+\_\+timesteppers\+\_\+steady}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Solve an adjoint eigenvalue problem using the same procedure as solve\+\_\+eigenproblem. See the documentation on that function for more details. Note\+: this is a legacy version of this function that stores re \& imag parts of eigenvectors in some solver-\/specific collection of real vectors. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ac1714b0637f4aefe5278c2b6f4667b24}{solve\+\_\+adjoint\+\_\+eigenproblem}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+eval}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ $>$ \&eigenvalue, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{eigenvector\+\_\+real}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{eigenvector\+\_\+imag}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{steady}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Solve an adjoint eigenvalue problem using the same procedure as solve\+\_\+eigenproblem. See the documentation on that function for more details. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ae056621a3e6cb72c47d4839b85a6e382}{solve\+\_\+adjoint\+\_\+eigenproblem}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+eval}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ $>$ \&eigenvalue, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{steady}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Solve an adjoint eigenvalue problem using the same procedure as solve\+\_\+eigenproblem but only return the eigenvalues, not the eigenvectors. At least n\+\_\+eval eigenvalues are computed. See the documentation on that function for more details. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a17e2d84700ac43c1db1d68143790ae5c}{get\+\_\+eigenproblem\+\_\+matrices}} (\mbox{\hyperlink{classoomph_1_1CRDoubleMatrix}{CRDouble\+Matrix}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{mass\+\_\+matrix}}, \mbox{\hyperlink{classoomph_1_1CRDoubleMatrix}{CRDouble\+Matrix}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{main\+\_\+matrix}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{shift}}=0.\+0)
\begin{DoxyCompactList}\small\item\em Get the matrices required by a eigensolver. If the shift parameter is non-\/zero the second matrix will be shifted. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a8f93315e1076dd9672167ed0a845ea34}{assign\+\_\+eigenvector\+\_\+to\+\_\+dofs}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{eigenvector}})
\begin{DoxyCompactList}\small\item\em Assign the eigenvector passed to the function to the dofs in the problem so that it can be output by the usual routines. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_aa803fbccb2c8c70702b2c39837e7ad2e}{add\+\_\+eigenvector\+\_\+to\+\_\+dofs}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&epsilon, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{eigenvector}})
\begin{DoxyCompactList}\small\item\em Add the eigenvector passed to the function scaled by the constat epsilon to the dofs in the problem so that it can be output by the usual routines. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a5a2906b9a6a22445d1dbb8aebbce9fa7}{store\+\_\+current\+\_\+dof\+\_\+values}} ()
\begin{DoxyCompactList}\small\item\em Store the current values of the degrees of freedom. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ad19fe0723fe6356776cfbe28e46ea64b}{restore\+\_\+dof\+\_\+values}} ()
\begin{DoxyCompactList}\small\item\em Restore the stored values of the degrees of freedom. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a8eb2fedc3f64411cfbe1627a516447f9}{enable\+\_\+jacobian\+\_\+reuse}} ()
\begin{DoxyCompactList}\small\item\em Enable recycling of Jacobian in Newton iteration (if the linear solver allows it). Useful for linear problems with constant Jacobians or nonlinear problems where you\textquotesingle{}re willing to risk the trade-\/off between faster solve times and degraded Newton convergence rate. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a52489fed5942629199e4f720a7a86549}{disable\+\_\+jacobian\+\_\+reuse}} ()
\begin{DoxyCompactList}\small\item\em Disable recycling of Jacobian in Newton iteration. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a5c864f0dfc4f0ff33e07935944b7b435}{jacobian\+\_\+reuse\+\_\+is\+\_\+enabled}} ()
\begin{DoxyCompactList}\small\item\em Is recycling of Jacobian in Newton iteration enabled? \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \& \mbox{\hyperlink{classoomph_1_1Problem_a45a100cc92214810b545b9bd7e56336c}{use\+\_\+predictor\+\_\+values\+\_\+as\+\_\+initial\+\_\+guess}} ()
\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a62a989ae9a9169b9d905f844db59787f}{newton\+\_\+solve}} ()
\begin{DoxyCompactList}\small\item\em Use Newton method to solve the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ac7c7711978f7c02becb4005414f945be}{enable\+\_\+globally\+\_\+convergent\+\_\+newton\+\_\+method}} ()
\begin{DoxyCompactList}\small\item\em enable globally convergent Newton method \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a927d35230db6fc5021b68eadaedac9a6}{disable\+\_\+globally\+\_\+convergent\+\_\+newton\+\_\+method}} ()
\begin{DoxyCompactList}\small\item\em disable globally convergent Newton method \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a4a5a30c124a14f32368f9607b7c8bf34}{newton\+\_\+solve}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{max\+\_\+adapt}})
\begin{DoxyCompactList}\small\item\em Adaptive Newton solve\+: up to max\+\_\+adapt adaptations of all refineable submeshes are performed to achieve the the error targets specified in the refineable submeshes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a6de9b126bf5c8fce5d8e9602fa151090}{steady\+\_\+newton\+\_\+solve}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{max\+\_\+adapt}}=0)
\begin{DoxyCompactList}\small\item\em Solve a steady problem using adaptive Newton\textquotesingle{}s method, but in the context of an overall unstady problem, perhaps to determine an initial condition. This is achieved by setting the weights in the timesteppers to be zero which has the effect of rendering them steady timesteppers. The optional argument max\+\_\+adapt specifies the max. number of adaptations of all refineable submeshes are performed to achieve the the error targets specified in the refineable submeshes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a4ac828f337a2d4e77e566ff95d01bad0}{copy}} (\mbox{\hyperlink{classoomph_1_1Problem}{Problem}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{orig\+\_\+problem\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Copy \doxylink{classoomph_1_1Data}{Data} values, nodal positions etc from specified problem. Note\+: This is not a copy constructor. We assume that the current and the "{}original"{} problem have both been created by calling the same problem constructor so that all \doxylink{classoomph_1_1Data}{Data} objects, time steppers etc. in the two problems are completely independent. This function copies the nodal, internal and global values, and the time parameters from the original problem into "{}this"{} one. This functionality is required, e.\+g. for multigrid computations. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_a78ac2b1d2483f49198203e192d3b2871}{make\+\_\+copy}} ()
\begin{DoxyCompactList}\small\item\em Make and return a pointer to the copy of the problem. A virtual function that must be filled in by the user is they wish to perform adaptive refinement in bifurcation tracking or in multigrid problems. ALH\+: WILL NOT BE NECESSARY IN BIFURCATION TRACKING IN LONG RUN... \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ae27a3057515ddaa60d2ecc684d517e8f}{read}} (std\+::ifstream \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{restart\+\_\+file}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsteady\+\_\+restart}})
\begin{DoxyCompactList}\small\item\em Read refinement pattern of all refineable meshes and refine them accordingly, then read all \doxylink{classoomph_1_1Data}{Data} and nodal position info from file for restart. Return flag to indicate if the restart was from steady or unsteady solution. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a561320c1b8deb3540d260c6c2c5f4fb4}{read}} (std\+::ifstream \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{restart\+\_\+file}})
\begin{DoxyCompactList}\small\item\em Read refinement pattern of all refineable meshes and refine them accordingly, then read all \doxylink{classoomph_1_1Data}{Data} and nodal position info from file for restart. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a804050357ac754151b86c2aec4dabc2d}{dump}} (std\+::ofstream \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{dump\+\_\+file}}) \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Dump refinement pattern of all refineable meshes and all generic \doxylink{classoomph_1_1Problem}{Problem} data to file for restart. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_af94771cdd9de79c17c9cf168f4a67a92}{dump}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} std\+::string \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{dump\+\_\+file\+\_\+name}}) \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Dump refinement pattern of all refineable meshes and all generic \doxylink{classoomph_1_1Problem}{Problem} data to file for restart. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ad5c302721bf6699ecf8c8760e49d47d8}{get\+\_\+all\+\_\+halo\+\_\+data}} (std\+::map$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{map\+\_\+of\+\_\+halo\+\_\+data}})
\begin{DoxyCompactList}\small\item\em Get pointers to all possible halo data indexed by global equation number in a map. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{long}} \mbox{\hyperlink{classoomph_1_1Problem_a9a9ce9ee869ff79ee5596e434309f379}{synchronise\+\_\+eqn\+\_\+numbers}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&assign\+\_\+local\+\_\+eqn\+\_\+numbers=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Classify any non-\/classified nodes into halo/haloed and synchronise equation numbers. Return the total number of degrees of freedom in the overall problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a1ccef4e26a7788424780da7555cdc772}{synchronise\+\_\+dofs}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{do\+\_\+halos}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{do\+\_\+external\+\_\+halos}})
\begin{DoxyCompactList}\small\item\em Synchronise the degrees of freedom by overwriting the haloed values with their non-\/halo counterparts held on other processors. Bools control if we deal with data associated with external halo/ed elements/nodes or the "{}normal"{} halo/ed ones. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a5d9a3ba5696a7bcd275223ff16b7392e}{synchronise\+\_\+all\+\_\+dofs}} ()
\begin{DoxyCompactList}\small\item\em Perform all required synchronisation in solvers. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a93dde63729e7cd332edc1f8904a80649}{check\+\_\+halo\+\_\+schemes}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Check the halo/haloed node/element schemes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a8dd5cb241ce6218fb476931e0879d7c8}{check\+\_\+halo\+\_\+schemes}} ()
\begin{DoxyCompactList}\small\item\em Check the halo/haloed node/element schemes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \mbox{\hyperlink{classoomph_1_1Problem_aa35e1adc0fdf14b217c7b608eb9cf20b}{distribute}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{element\+\_\+partition}}, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{report\+\_\+stats}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{false}})
\begin{DoxyCompactList}\small\item\em Distribute the problem and doc, using the specified partition; returns a vector which details the partitioning. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \mbox{\hyperlink{classoomph_1_1Problem_a9bab7c41bf5d6d053259ff10920d7303}{distribute}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{report\+\_\+stats}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{false}})
\begin{DoxyCompactList}\small\item\em Distribute the problem; returns a vector which details the partitioning. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \mbox{\hyperlink{classoomph_1_1Problem_aa35f7ff2b0075cfd4dda519858a65d6c}{distribute}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{element\+\_\+partition}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{report\+\_\+stats}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{false}})
\begin{DoxyCompactList}\small\item\em Distribute the problem using the specified partition; returns a vector which details the partitioning. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \mbox{\hyperlink{classoomph_1_1Problem_af0365ddbe425b730ece6a575db1cd7dd}{distribute}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{report\+\_\+stats}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{false}})
\begin{DoxyCompactList}\small\item\em Distribute the problem; returns a vector which details the partitioning. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ad29fc4bc4d4bead472059765fbbd3b11}{partition\+\_\+global\+\_\+mesh}} (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} \texorpdfstring{$\ast$}{*}\&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{global\+\_\+mesh\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{element\+\_\+domain}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{report\+\_\+stats}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{false}})
\begin{DoxyCompactList}\small\item\em Partition the global mesh, return vector specifying the processor number for each element. Virtual so that it can be overloaded by any user; the default is to use \doxylink{namespaceoomph_1_1METIS}{METIS} to perform the partitioning (with a bit of cleaning up afterwards to sort out "{}special cases"{}). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a8c5982a9323392e31a166e23a0c7f0a3}{prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{report\+\_\+stats}})
\begin{DoxyCompactList}\small\item\em (Irreversibly) prune halo(ed) elements and nodes, usually after another round of refinement, to get rid of excessively wide halo layers. Note that the current mesh will be now regarded as the base mesh and no unrefinement relative to it will be possible once this function has been called. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a977f74f132157959d30e82cfcad41a97}{prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{report\+\_\+stats}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{false}})
\begin{DoxyCompactList}\small\item\em (Irreversibly) prune halo(ed) elements and nodes, usually after another round of refinement, to get rid of excessively wide halo layers. Note that the current mesh will be now regarded as the base mesh and no unrefinement relative to it will be possible once this function has been called. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_aa44439175e6899a1a6c125f08b786301}{problem\+\_\+has\+\_\+been\+\_\+distributed}} ()
\begin{DoxyCompactList}\small\item\em Access to Problem\+\_\+has\+\_\+been\+\_\+distributed flag. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ab8eb3782046c64ea0e46205917440452}{delete\+\_\+all\+\_\+external\+\_\+storage}} ()
\begin{DoxyCompactList}\small\item\em Wrapper function to delete external storage for each submesh of the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_abbcf4965b6052758e49cf511947fd3f0}{symmetrise\+\_\+eigenfunction\+\_\+for\+\_\+adaptive\+\_\+pitchfork\+\_\+tracking}} ()
\begin{DoxyCompactList}\small\item\em Virtual function that is used to symmetrise the problem so that the current solution exactly satisfies any symmetries within the system. Used when adpativly solving pitchfork detection problems when small asymmetries in the coarse solution can be magnified leading to very inaccurate answers on the fine mesh. This is always problem-\/specific and must be filled in by the user The default issues a warning. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_a3cf79b3067d1d794062ebb27e414dea9}{bifurcation\+\_\+parameter\+\_\+pt}} () \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}}
\begin{DoxyCompactList}\small\item\em Return pointer to the parameter that is used in the bifurcation detection. If we are not tracking a bifurcation then an error will be thrown by the \doxylink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a85b240c17750bdc32afafee35b50225a}{get\+\_\+bifurcation\+\_\+eigenfunction}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{eigenfunction}})
\begin{DoxyCompactList}\small\item\em Return the eigenfunction calculated as part of a bifurcation tracking process. If we are not tracking a bifurcation then an error will be thrown by the \doxylink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_acf20e92281911dfbb423ea82542c0485}{activate\+\_\+fold\+\_\+tracking}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{block\+\_\+solve}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Turn on fold tracking using the augmented system specified in the \doxylink{classoomph_1_1FoldHandler}{Fold\+Handler} class. After a call to this function subsequent calls of the standard solution methods will converge to a fold (limit) point at a particular value of the variable addressed by parameter\+\_\+pt. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. If the boolean flag block\+\_\+solver is true (the default) then a block factorisation is used to solve the augmented system which is both faster and uses less memory. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a95359def89a0ee3d3df8976ab54c6591}{activate\+\_\+bifurcation\+\_\+tracking}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{eigenvector}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{block\+\_\+solve}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Activate generic bifurcation tracking for a single (real) eigenvalue where the initial guess for the eigenvector can be specified. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a4610ef4c4f4d7c1d7001fabf074c930c}{activate\+\_\+bifurcation\+\_\+tracking}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{eigenvector}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{normalisation}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{block\+\_\+solve}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Activate generic bifurcation tracking for a single (real) eigenvalue where the initial guess for the eigenvector can be specified and the normalisation condition can also be specified. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a7f5eb1f88a957cb3d8a11b558002d484}{activate\+\_\+pitchfork\+\_\+tracking}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{symmetry\+\_\+vector}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{block\+\_\+solve}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Turn on pitchfork tracking using the augmented system specified in the \doxylink{classoomph_1_1PitchForkHandler}{Pitch\+Fork\+Handler} class. After a call to this function subsequent calls of the standard solution methods will converge to a pitchfork bifurcation at a particular value of the variable addressed by parameter\+\_\+pt. The symmetry that is to be broken must be specified by supplying a symmetry\+\_\+vector(ndof). The easiest way to determine such a vector is to solve the associated eigenproblem $ Jx = \lambda M x$ and pass in the eigenvector. This is not always necessary however, if the symmetry is easy to construct. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. If the boolean flag block\+\_\+solver is true (the default) then a block factorisation is used to solve the augmented system which is both faster and requires less memory. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ac5966d1a184e722195f96d797b52e64c}{activate\+\_\+hopf\+\_\+tracking}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{block\+\_\+solve}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Turn on Hopf bifurcation tracking using the augmented system specified in the \doxylink{classoomph_1_1HopfHandler}{Hopf\+Handler} class. After a call to this function subsequent calls of the standard solution methods will converge to a Hopf bifuraction at a particular value of the variable addressed by parameter\+\_\+pt. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_aa0e2d0e105da6b676262d75481bcc8e3}{activate\+\_\+hopf\+\_\+tracking}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&omega, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{null\+\_\+real}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{null\+\_\+imag}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{block\+\_\+solve}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Turn on Hopf bifurcation tracking using the augmented system specified in the \doxylink{classoomph_1_1HopfHandler}{Hopf\+Handler} class. After a call to this function subsequent calls of the standard solution methods will converge to a Hopf bifuraction at a particular value of the variable addressed by parameter\+\_\+pt. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. This interface allows specification of an inital guess for the frequency and real and imaginary parts of the null vector, such as might be obtained from an eigensolve. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ac5b47ae12ed6445e52c65596dfa97c6d}{deactivate\+\_\+bifurcation\+\_\+tracking}} ()
\begin{DoxyCompactList}\small\item\em Deactivate all bifuraction tracking, by reseting the assembly handler to the default. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_aecb590c73e64b0a85f7bec0053e2c51d}{reset\+\_\+assembly\+\_\+handler\+\_\+to\+\_\+default}} ()
\begin{DoxyCompactList}\small\item\em Reset the system to the standard non-\/augemented state. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_ad8414efbd8099d3e6cf3f4daea06cc8f}{arc\+\_\+length\+\_\+step\+\_\+solve}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{ds}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{max\+\_\+adapt}}=0)
\begin{DoxyCompactList}\small\item\em Solve a steady problem using arc-\/length continuation, when the parameter that becomes a variable corresponding to the arc-\/length constraint equation is an external double\+: parameter\+\_\+pt is a pointer to that double, ds is the desired arc\+\_\+length and max\+\_\+adapt is the maximum number of spatial adaptations (default zero, no adaptation). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_aefb723728ed26abe410b61ec38d42688}{arc\+\_\+length\+\_\+step\+\_\+solve}} (\mbox{\hyperlink{classoomph_1_1Data}{Data}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{data\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{data\+\_\+index}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{ds}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{max\+\_\+adapt}}=0)
\begin{DoxyCompactList}\small\item\em Solve a steady problem using arc-\/length continuation, when the variable corresponding to the arc-\/length constraint equation is already stored in data used in the problem\+: data\+\_\+pt is a pointer to the appropriate data object, data\+\_\+index is the index of the value that will be traded for the constriant, ds is the desired arc\+\_\+length and max\+\_\+adapt is the maximum number of spatial adaptations (default zero, no adaptation). Note that the value must be pinned in order for this formulation to work. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a6477df6e8184dc78e9d9ff82c7627cef}{reset\+\_\+arc\+\_\+length\+\_\+parameters}} ()
\begin{DoxyCompactList}\small\item\em Reset the "{}internal"{} arc-\/length continuation parameters, so as to allow continuation in another parameter. N.\+B. The parameters that are reset are the "{}minimum"{} that are required, others should perhaps be reset, depending upon the application. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{int}} \& \mbox{\hyperlink{classoomph_1_1Problem_af45e04e4e24b02e92eb16b911cdc2466}{sign\+\_\+of\+\_\+jacobian}} ()
\begin{DoxyCompactList}\small\item\em Access function for the sign of the global jacobian matrix. This will be set by the linear solver, if possible (direct solver). If not alternative methods must be used to detect bifurcations (solving the associated eigenproblem). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ab8b74c5b1499b2d712a8545cccbd97c2}{explicit\+\_\+timestep}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&dt, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{shift\+\_\+values}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Take an explicit timestep of size dt and optionally shift any stored values of the time history. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_aef22157aadc15a512cca93e4c423ff73}{unsteady\+\_\+newton\+\_\+solve}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&dt)
\begin{DoxyCompactList}\small\item\em Advance time by dt and solve by Newton\textquotesingle{}s method. This version always shifts time values. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_abf8b8c9ee09df0ba8934382740a588de}{unsteady\+\_\+newton\+\_\+solve}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&dt, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{shift\+\_\+values}})
\begin{DoxyCompactList}\small\item\em Advance time by dt and solve the system, using Newton\textquotesingle{}s method. The boolean flag is used to control whether the time values should be shifted. If it is true the current data values will be shifted (copied to the locations where there are stored as previous timesteps) before solution. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_af26bd71c24ba99c9391d6e932b68e5e8}{unsteady\+\_\+newton\+\_\+solve}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&dt, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{max\+\_\+adapt}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{first}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{shift}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Unsteady adaptive Newton solve\+: up to max\+\_\+adapt adaptations of all refineable submeshes are performed to achieve the the error targets specified in the refineable submeshes. If first==true, the initial conditions are re-\/assigned after the mesh adaptations. Shifting of time can be suppressed by overwriting the default value of shift (true). \mbox{[}Shifting must be done if first\+\_\+timestep==true because we\textquotesingle{}re constantly re-\/assigning the initial conditions; if first\+\_\+timestep==true and shift==false shifting is performed anyway and a warning is issued. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_a7561d4f82e1fa625210c58a78294a301}{doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&dt, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&epsilon, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{max\+\_\+adapt}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{first}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{shift}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Unsteady "{}doubly"{} adaptive Newton solve\+: Does temporal adaptation first, i.\+e. we try to do a timestep with an increment of dt, and adjusting dt until the solution on the given mesh satisfies the temporal error measure with tolerance epsilon. Following this, we do up to max\+\_\+adapt spatial adaptions (without re-\/examining the temporal error). If first==true, the initial conditions are re-\/assigned after the mesh adaptations. Shifting of time can be suppressed by overwriting the default value of shift (true). \mbox{[}Shifting must be done if first\+\_\+timestep==true because we\textquotesingle{}re constantly re-\/assigning the initial conditions; if first\+\_\+timestep==true and shift==false shifting is performed anyway and a warning is issued. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_ae6c326bce8647c2a59cf62288ce4902e}{doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&dt, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&epsilon, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{max\+\_\+adapt}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{suppress\+\_\+resolve\+\_\+after\+\_\+spatial\+\_\+adapt\+\_\+flag}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{first}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{shift}}=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{true}})
\begin{DoxyCompactList}\small\item\em Unsteady "{}doubly"{} adaptive Newton solve\+: Does temporal adaptation first, i.\+e. we try to do a timestep with an increment of dt, and adjusting dt until the solution on the given mesh satisfies the temporal error measure with tolerance epsilon. Following this, we do up to max\+\_\+adapt spatial adaptions (without re-\/examining the temporal error). If first==true, the initial conditions are re-\/assigned after the mesh adaptations. Shifting of time can be suppressed by overwriting the default value of shift (true). \mbox{[}Shifting must be done if first\+\_\+timestep==true because we\textquotesingle{}re constantly re-\/assigning the initial conditions; if first\+\_\+timestep==true and shift==false shifting is performed anyway and a warning is issued. Pseudo-\/\+Boolean flag suppress\+\_\+resolve\+\_\+after\+\_\+spatial\+\_\+adapt \mbox{[}0\+: false; 1\+: true\mbox{]} does what it says.\mbox{]}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_abf6681f21f614ed7f15cc675ed6f692a}{adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{dt\+\_\+desired}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&epsilon)
\begin{DoxyCompactList}\small\item\em Attempt to advance timestep by dt\+\_\+desired. If the solution fails the timestep will be halved until convergence is achieved, or the timestep falls below Newton\+Solver\+Parameters\+::\+Minimum\+\_\+time\+\_\+step. The error control parameter epsilon represents the (approximate) desired magnitude of the global error at each timestep. The routine returns a double that is the suggested next timestep and should be passed as dt\+\_\+desired the next time the routine is called. This version always shifts the time values. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_a3f5bde6d7fa8972e01a20c522b5fb2ef}{adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{dt\+\_\+desired}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&epsilon, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{shift\+\_\+values}})
\begin{DoxyCompactList}\small\item\em Attempt to advance timestep by dt\+\_\+desired. If the solution fails the timestep will be halved until convergence is achieved, or the timestep falls below Newton\+Solver\+Parameters\+::\+Minimum\+\_\+time\+\_\+step. The error control parameter epsilon represents the (approximate) desired magnitude of the global error at each timestep. The routine returns a double that is the suggested next timestep and should be passed as dt\+\_\+desired the next time the routine is called. Once again the boolean flag, shift\+\_\+values, is used to control whether the time values are shifted. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a10e5dc4d944dfb2b141918e18e5e3de8}{assign\+\_\+initial\+\_\+values\+\_\+impulsive}} ()
\begin{DoxyCompactList}\small\item\em Initialise data and nodal positions to simulate impulsive start from initial configuration/solution. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a296bd0ba13bd51a96bb7057845e5a800}{assign\+\_\+initial\+\_\+values\+\_\+impulsive}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \&dt)
\begin{DoxyCompactList}\small\item\em Initialise data and nodal positions to simulate an impulsive start and also set the initial and previous values of dt. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a474deeb0947b767566fa1d4630ad8b4a}{calculate\+\_\+predictions}} ()
\begin{DoxyCompactList}\small\item\em Calculate predictions. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a6a9e63d6e585eabe4e3e551f01f658ae}{enable\+\_\+mass\+\_\+matrix\+\_\+reuse}} ()
\begin{DoxyCompactList}\small\item\em Enable recycling of the mass matrix in explicit timestepping schemes. Useful for timestepping on fixed meshes when you want to avoid the linear solve phase. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a399ca4ccf551f9bf5621f9855e899af6}{disable\+\_\+mass\+\_\+matrix\+\_\+reuse}} ()
\begin{DoxyCompactList}\small\item\em Turn off recyling of the mass matrix in explicit timestepping schemes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_afa46c693258868c126503cce3a663a85}{mass\+\_\+matrix\+\_\+reuse\+\_\+is\+\_\+enabled}} ()
\begin{DoxyCompactList}\small\item\em Return whether the mass matrix is being reused. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a181fa92838f77bd6b12b531dca222c41}{refine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{nrefine\+\_\+for\+\_\+mesh}})
\begin{DoxyCompactList}\small\item\em Refine refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a14ca1d18e9aa569a6417c45eef70d3ff}{refine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{nrefine\+\_\+for\+\_\+mesh}}, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Refine refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem; doc refinement process. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a3930fc0977bdc33f52100e53f5d878d7}{refine\+\_\+uniformly\+\_\+and\+\_\+prune}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{nrefine\+\_\+for\+\_\+mesh}})
\begin{DoxyCompactList}\small\item\em Refine refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem. Prune after refinements. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_adea5168244acebb539fa29e36182ced3}{refine\+\_\+uniformly\+\_\+and\+\_\+prune}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{nrefine\+\_\+for\+\_\+mesh}}, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Refine refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem; doc refinement process. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ae4ccf79fde59556d93af947618b6c80b}{refine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ac0495df29dde90577e4702fcac496684}{refine\+\_\+uniformly\+\_\+and\+\_\+prune}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ade208b7d7d8e866d5ba896f03edb1f9a}{refine\+\_\+uniformly}} ()
\begin{DoxyCompactList}\small\item\em Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a74d1904dd72eaf71c015470a23caef5f}{refine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{i\+\_\+mesh}}, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Do uniform refinement for submesh i\+\_\+mesh with documentation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_afae401b74b58d6312da32f153b78047d}{refine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{i\+\_\+mesh}})
\begin{DoxyCompactList}\small\item\em Do uniform refinement for submesh i\+\_\+mesh without documentation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a3aaea4b1be43f5d4bb187a8c6d3ca16f}{p\+\_\+refine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{nrefine\+\_\+for\+\_\+mesh}})
\begin{DoxyCompactList}\small\item\em p-\/refine p-\/refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a0a980d9659db60b113b6d4e7431594b7}{p\+\_\+refine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{nrefine\+\_\+for\+\_\+mesh}}, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em p-\/refine p-\/refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem; doc refinement process \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a5155b2d5436a95b1ee27f914b4eb8f08}{p\+\_\+refine\+\_\+uniformly\+\_\+and\+\_\+prune}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{nrefine\+\_\+for\+\_\+mesh}})
\begin{DoxyCompactList}\small\item\em p-\/refine p-\/refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem. Prune after refinements \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_aabfa653ef203edf44cf9b6cf558865e1}{p\+\_\+refine\+\_\+uniformly\+\_\+and\+\_\+prune}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{nrefine\+\_\+for\+\_\+mesh}}, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em p-\/refine p-\/refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem; doc refinement process \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a355caf4c06c3b8b5d399115048453921}{p\+\_\+refine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em p-\/refine (all) p-\/refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a80ff24a4fc923660f2aabfaa763822bf}{p\+\_\+refine\+\_\+uniformly\+\_\+and\+\_\+prune}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em p-\/refine (all) p-\/refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ada439afd4d195644e53d6bdbc4b00587}{p\+\_\+refine\+\_\+uniformly}} ()
\begin{DoxyCompactList}\small\item\em p-\/refine (all) p-\/refineable (sub)mesh(es) uniformly and rebuild problem \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a04fed27f341b9eb68b5fb3e4673f26f9}{p\+\_\+refine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{i\+\_\+mesh}}, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Do uniform p-\/refinement for submesh i\+\_\+mesh with documentation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a33dbab01dfa53e4d005818a2940085b0}{p\+\_\+refine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{i\+\_\+mesh}})
\begin{DoxyCompactList}\small\item\em Do uniform p-\/refinement for submesh i\+\_\+mesh without documentation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a88bfce034f5b054e78a1c1a15d196aeb}{refine\+\_\+selected\+\_\+elements}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elements\+\_\+to\+\_\+be\+\_\+refined}})
\begin{DoxyCompactList}\small\item\em Refine (one and only!) mesh by splitting the elements identified by their numbers relative to the problems\textquotesingle{} only mesh, then rebuild the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_abd2274dbc96e0ae3caf20573152d19e7}{refine\+\_\+selected\+\_\+elements}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Refine (one and only!) mesh by splitting the elements identified by their pointers, then rebuild the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_af2bd42a9612a31041b9d607340c6d68c}{refine\+\_\+selected\+\_\+elements}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{i\+\_\+mesh}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elements\+\_\+to\+\_\+be\+\_\+refined}})
\begin{DoxyCompactList}\small\item\em Refine specified submesh by splitting the elements identified by their numbers relative to the submesh, then rebuild the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a77b480e2299c8526b27b09fa45ac20a9}{refine\+\_\+selected\+\_\+elements}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{i\+\_\+mesh}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Refine specified submesh by splitting the elements identified by their pointers, then rebuild the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a2f4ca0c03520c5c827f49ede74321684}{refine\+\_\+selected\+\_\+elements}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elements\+\_\+to\+\_\+be\+\_\+refined}})
\begin{DoxyCompactList}\small\item\em Refine all submeshes by splitting the elements identified by their numbers relative to each submesh in a \doxylink{classoomph_1_1Vector}{Vector} of Vectors, then rebuild the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ac82771428414dab6ddcbd115481173a0}{refine\+\_\+selected\+\_\+elements}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} \texorpdfstring{$\ast$}{*} $>$ $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Refine all submeshes by splitting the elements identified by their pointers within each submesh in a \doxylink{classoomph_1_1Vector}{Vector} of Vectors, then rebuild the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a2042cdd88af58eedc66bfaf29b370ff1}{p\+\_\+refine\+\_\+selected\+\_\+elements}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elements\+\_\+to\+\_\+be\+\_\+refined}})
\begin{DoxyCompactList}\small\item\em p-\/refine (one and only!) mesh by refining the elements identified by their numbers relative to the problems\textquotesingle{} only mesh, then rebuild the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_afd17da2aa90d68c4fb5120c90b2435d9}{p\+\_\+refine\+\_\+selected\+\_\+elements}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1PRefineableElement}{PRefineable\+Element}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em p-\/refine (one and only!) mesh by refining the elements identified by their pointers, then rebuild the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a86f7b013945049548f86377e489e23f1}{p\+\_\+refine\+\_\+selected\+\_\+elements}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{i\+\_\+mesh}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elements\+\_\+to\+\_\+be\+\_\+refined}})
\begin{DoxyCompactList}\small\item\em p-\/refine specified submesh by refining the elements identified by their numbers relative to the submesh, then rebuild the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a044b3cb5ffc2953c1990bd602567b99a}{p\+\_\+refine\+\_\+selected\+\_\+elements}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{i\+\_\+mesh}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1PRefineableElement}{PRefineable\+Element}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em p-\/refine specified submesh by refining the elements identified by their pointers, then rebuild the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a4be6e85e73cd5c7f61763efe78f9fa9e}{p\+\_\+refine\+\_\+selected\+\_\+elements}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elements\+\_\+to\+\_\+be\+\_\+refined}})
\begin{DoxyCompactList}\small\item\em p-\/refine all submeshes by refining the elements identified by their numbers relative to each submesh in a \doxylink{classoomph_1_1Vector}{Vector} of Vectors, then rebuild the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a1351a6db8cc6457ca8790e9b2acf4c8d}{p\+\_\+refine\+\_\+selected\+\_\+elements}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1PRefineableElement}{PRefineable\+Element}} \texorpdfstring{$\ast$}{*} $>$ $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em p-\/refine all submeshes by refining the elements identified by their pointers within each submesh in a \doxylink{classoomph_1_1Vector}{Vector} of Vectors, then rebuild the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_a10dae99dec2f8202887f4e49e175f39c}{unrefine\+\_\+uniformly}} ()
\begin{DoxyCompactList}\small\item\em Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem. Return 0 for success, 1 for failure (if unrefinement has reached the coarsest permitted level) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_aadd2996d4046e5a6176c92f4abc899d5}{unrefine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{i\+\_\+mesh}})
\begin{DoxyCompactList}\small\item\em Do uniform refinement for submesh i\+\_\+mesh without documentation. Return 0 for success, 1 for failure (if unrefinement has reached the coarsest permitted level) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a21d8f0ff6813b09f35acbc7a76232397}{p\+\_\+unrefine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em p-\/unrefine (all) p-\/refineable (sub)mesh(es) uniformly and rebuild problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a706a2845212ece5535260cca6301653d}{p\+\_\+unrefine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{i\+\_\+mesh}}, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Do uniform p-\/unrefinement for submesh i\+\_\+mesh without documentation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_afc4492ec2686c70467cb0cdb4638a45f}{adapt}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+refined}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+unrefined}})
\begin{DoxyCompactList}\small\item\em Adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. Return \# of refined/unrefined elements. On return from this function, \doxylink{classoomph_1_1Problem}{Problem} can immediately be solved again. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a0b9e09ddfa2411f14fc723c3207decd1}{adapt}} ()
\begin{DoxyCompactList}\small\item\em Adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. On return from this function, \doxylink{classoomph_1_1Problem}{Problem} can immediately be solved again. \mbox{[}Argument-\/free wrapper\mbox{]}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a1303b2fde2fe84b71519cadabc18f868}{p\+\_\+adapt}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+refined}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+unrefined}})
\begin{DoxyCompactList}\small\item\em p-\/adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. Return \# of refined/unrefined elements. On return from this function, \doxylink{classoomph_1_1Problem}{Problem} can immediately be solved again. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_aaad4443f87f3f3affe53fa9160802e7c}{p\+\_\+adapt}} ()
\begin{DoxyCompactList}\small\item\em p-\/adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. On return from this function, \doxylink{classoomph_1_1Problem}{Problem} can immediately be solved again. \mbox{[}Argument-\/free wrapper\mbox{]} \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a291f1a2b3cb65743355ec1e0cdcb7f48}{adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+refined}}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{n\+\_\+unrefined}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elemental\+\_\+error}})
\begin{DoxyCompactList}\small\item\em Adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on the error estimates in elemental\+\_\+error and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. Return \# of refined/unrefined elements. On return from this function, \doxylink{classoomph_1_1Problem}{Problem} can immediately be solved again. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a7bf1b55fe1bb0cc02fd0b7a868a58c3b}{adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elemental\+\_\+error}})
\begin{DoxyCompactList}\small\item\em Adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on the error estimates in elemental\+\_\+error and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. Return \# of refined/unrefined elements. On return from this function, \doxylink{classoomph_1_1Problem}{Problem} can immediately be solved again. \mbox{[}Wrapper without n\+\_\+refined and n\+\_\+unrefined arguments\mbox{]}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a5e58bd6dcb1ff9ef54cf504984fb5f9e}{get\+\_\+all\+\_\+error\+\_\+estimates}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elemental\+\_\+error}})
\begin{DoxyCompactList}\small\item\em Return the error estimates computed by (all) refineable (sub)mesh(es) in the elemental\+\_\+error structure, which consists of a vector of vectors of elemental errors, one vector for each (sub)mesh. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_af2a77519885ccb13e4644c89b19c37a7}{doc\+\_\+errors}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Get max and min error for all elements in submeshes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_af2a9dfdb7b4f95bb941d48411f955f55}{doc\+\_\+errors}} ()
\begin{DoxyCompactList}\small\item\em Get max and min error for all elements in submeshes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a3226bf49118c8a4f02dbe01d22428f20}{enable\+\_\+info\+\_\+in\+\_\+newton\+\_\+solve}} ()
\begin{DoxyCompactList}\small\item\em Enable the output of information when in the newton solver (Default) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_af00e3623681347439fe3dac650423bbe}{disable\+\_\+info\+\_\+in\+\_\+newton\+\_\+solve}} ()
\begin{DoxyCompactList}\small\item\em Disable the output of information when in the newton solver. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject}{oomph\+::\+Explicit\+Time\+Steppable\+Object}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_a07e82e7df9f289fc59fbf5ac438ad068}{Explicit\+Time\+Steppable\+Object}} ()
\begin{DoxyCompactList}\small\item\em Empty constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_af9e1d1c57792a5540f0d31f3b36b4d7b}{Explicit\+Time\+Steppable\+Object}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject}{Explicit\+Time\+Steppable\+Object}} \&)=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{delete}}
\begin{DoxyCompactList}\small\item\em Broken copy constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_a85c2f447b67a0afd64e910b558ac6f90}{operator=}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject}{Explicit\+Time\+Steppable\+Object}} \&)=\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{delete}}
\begin{DoxyCompactList}\small\item\em Broken assignment operator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_a0ed68ad4da79ddfdc5b545fa62292304}{\texorpdfstring{$\sim$}{\string~}\+Explicit\+Time\+Steppable\+Object}} ()
\begin{DoxyCompactList}\small\item\em Empty destructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_a74eb2ebff3fc3066edccdfe4d3b6bc07}{actions\+\_\+before\+\_\+explicit\+\_\+stage}} ()
\begin{DoxyCompactList}\small\item\em Empty virtual function to do anything needed before a stage of an explicit time step (Runge-\/\+Kutta steps contain multiple stages per time step, most others only contain one). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_ad1eb700abad36e868a84c475f9866b7d}{actions\+\_\+after\+\_\+explicit\+\_\+stage}} ()
\begin{DoxyCompactList}\small\item\em Empty virtual function that should be overloaded to update any dependent data or boundary conditions that should be advanced after each stage of an explicit time step (Runge-\/\+Kutta steps contain multiple stages per time step, most others only contain one). \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Types inherited from \mbox{\hyperlink{classoomph_1_1Problem}{oomph\+::\+Problem}}}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402}{Distributed\+\_\+problem\+\_\+matrix\+\_\+distribution}} \{ \mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402ad7503f3fef4bc3556497018171c820e6}{Default\+\_\+matrix\+\_\+distribution}}
, \mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402aed8521359adcaf514039424b29893796}{Problem\+\_\+matrix\+\_\+distribution}}
, \mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402a741cb51275fde6a02373b2ffacf1273f}{Uniform\+\_\+matrix\+\_\+distribution}}
 \}
\begin{DoxyCompactList}\small\item\em enum for distribution of distributed jacobians. 1 -\/ Automatic -\/ the \doxylink{classoomph_1_1Problem}{Problem} distribution is employed, unless any processor has number of rows equal to 110\% of N/P, in which case uniform distribution is employed. 2 -\/ \doxylink{classoomph_1_1Problem}{Problem} -\/ the jacobian on processor p only contains rows that correspond to equations that are on this processor. (minimises communication) 3 -\/ Uniform -\/ each processor holds as close to N/P matrix rows as possible. (very well load balanced) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{typedef}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}}(\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_a638b525d7cae45e56160e3c282c8ad09}{Spatial\+Error\+Estimator\+Fct\+Pt}}) (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} \texorpdfstring{$\ast$}{*}\&\mbox{\hyperlink{classoomph_1_1Problem_ae2e5559918832d0850b3631d004d0a37}{mesh\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elemental\+\_\+error}})
\begin{DoxyCompactList}\small\item\em Function pointer for spatial error estimator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{typedef}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}}(\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_a220abfde16b8b1b544b4127e0e4cc9e4}{Spatial\+Error\+Estimator\+With\+Doc\+Fct\+Pt}}) (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} \texorpdfstring{$\ast$}{*}\&\mbox{\hyperlink{classoomph_1_1Problem_ae2e5559918832d0850b3631d004d0a37}{mesh\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{elemental\+\_\+error}}, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Function pointer for spatial error estimator with doc. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes inherited from \mbox{\hyperlink{classoomph_1_1Problem}{oomph\+::\+Problem}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_aeadae1fc5f49e66223ee09c69a9e506d}{Max\+\_\+permitted\+\_\+error\+\_\+for\+\_\+halo\+\_\+check}}
\begin{DoxyCompactList}\small\item\em Threshold for error throwing in \doxylink{classoomph_1_1Problem_a8dd5cb241ce6218fb476931e0879d7c8}{Problem\+::check\+\_\+halo\+\_\+schemes()} \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_ab4a3743c23a2d1eed56981484636c958}{Shut\+\_\+up\+\_\+in\+\_\+newton\+\_\+solve}}
\begin{DoxyCompactList}\small\item\em Boolean to indicate if all output is suppressed in \doxylink{classoomph_1_1Problem_a62a989ae9a9169b9d905f844db59787f}{Problem\+::newton\+\_\+solve()}. Defaults to false. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes inherited from \mbox{\hyperlink{classoomph_1_1Problem}{oomph\+::\+Problem}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{static}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a223a45fe6b1c80ee0109037b63e162f9}{Suppress\+\_\+warning\+\_\+about\+\_\+actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes}}
\begin{DoxyCompactList}\small\item\em Flag to allow suppression of warning messages re reading in unstructured meshes during restart. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Types inherited from \mbox{\hyperlink{classoomph_1_1Problem}{oomph\+::\+Problem}}}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7}{Assembly\+\_\+method}} \{ \newline
\mbox{\hyperlink{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7aa00e1772bb5ccf1c837a2bad2f240241}{Perform\+\_\+assembly\+\_\+using\+\_\+vectors\+\_\+of\+\_\+pairs}}
, \mbox{\hyperlink{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7a6008d2b6aa449ee405313b49632d18ff}{Perform\+\_\+assembly\+\_\+using\+\_\+two\+\_\+vectors}}
, \mbox{\hyperlink{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7a406ad24599e1a59450acdd09bac1d717}{Perform\+\_\+assembly\+\_\+using\+\_\+maps}}
, \mbox{\hyperlink{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7ad73bb55e4e1f000cfd6930cb8b2a52f8}{Perform\+\_\+assembly\+\_\+using\+\_\+lists}}
, \newline
\mbox{\hyperlink{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7a1383f03857ad8602ba7edef43bd947f5}{Perform\+\_\+assembly\+\_\+using\+\_\+two\+\_\+arrays}}
 \}
\begin{DoxyCompactList}\small\item\em Enumerated flags to determine which sparse assembly method is used. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions inherited from \mbox{\hyperlink{classoomph_1_1Problem}{oomph\+::\+Problem}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_a919a5f4752362df6005d24e51b5780e0}{setup\+\_\+element\+\_\+count\+\_\+per\+\_\+dof}} ()
\begin{DoxyCompactList}\small\item\em Function that populates the Element\+\_\+counter\+\_\+per\+\_\+dof vector with the number of elements that contribute to each dof. For example, with linear elements in 1D each dof contains contributions from two elements apart from those on the boundary. Returns the total number of elements in the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a216679e2a976e0205165bbe7ab558579}{setup\+\_\+dof\+\_\+halo\+\_\+scheme}} ()
\begin{DoxyCompactList}\small\item\em Function that is used to setup the halo scheme. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a072f2894b20672be1a48783684c4a50b}{sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{int}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{column\+\_\+or\+\_\+row\+\_\+index}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{int}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{row\+\_\+or\+\_\+column\+\_\+start}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*} $>$ \&value, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ \&nnz, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*} $>$ \&residual, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{compressed\+\_\+row\+\_\+flag}})
\begin{DoxyCompactList}\small\item\em Protected helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a0c8d70891f7369bb4bf8412fa1a08ecb}{actions\+\_\+before\+\_\+newton\+\_\+solve}} ()
\begin{DoxyCompactList}\small\item\em Any actions that are to be performed before a complete Newton solve (e.\+g. adjust boundary conditions). CAREFUL\+: This step should (and if the FD-\/based \doxylink{classoomph_1_1LinearSolver}{Linear\+Solver} \doxylink{classoomph_1_1FD__LU}{FD\+\_\+\+LU} is used, must) only update values that are pinned! \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a033ec7301123deeb7e56d04c38f9f1da}{actions\+\_\+after\+\_\+newton\+\_\+solve}} ()
\begin{DoxyCompactList}\small\item\em Any actions that are to be performed after a complete Newton solve, e.\+g. post processing. CAREFUL\+: This step should (and if the FD-\/based \doxylink{classoomph_1_1LinearSolver}{Linear\+Solver} \doxylink{classoomph_1_1FD__LU}{FD\+\_\+\+LU} is used, must) only update values that are pinned! \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ae6ad96ddf5d48b517b89c9a9b879bc4b}{actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check}} ()
\begin{DoxyCompactList}\small\item\em Any actions that are to be performed before the residual is checked in the Newton method, e.\+g. update any boundary conditions that depend upon variables of the problem; update any `dependent' variables; or perform an update of the nodal positions in Spine\+Meshes etc. CAREFUL\+: This step should (and if the FD-\/based \doxylink{classoomph_1_1LinearSolver}{Linear\+Solver} \doxylink{classoomph_1_1FD__LU}{FD\+\_\+\+LU} is used, must) only update values that are pinned! \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a07fc81781c74b25c8a426ec18295b0d0}{actions\+\_\+before\+\_\+newton\+\_\+step}} ()
\begin{DoxyCompactList}\small\item\em Any actions that are to be performed before each individual Newton step. Most likely to be used for diagnostic purposes to doc the solution during a non-\/converging iteration, say. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_aed8bc6e7b0bb45b86d5b44737b554d50}{actions\+\_\+after\+\_\+newton\+\_\+step}} ()
\begin{DoxyCompactList}\small\item\em Any actions that are to be performed after each individual Newton step. Most likely to be used for diagnostic purposes to doc the solution during a non-\/converging iteration, say. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a4f19896906d2c0274ad6798cd3ac38dc}{actions\+\_\+before\+\_\+implicit\+\_\+timestep}} ()
\begin{DoxyCompactList}\small\item\em Actions that should be performed before each implicit time step. This is needed when one wants to solve a steady problem before timestepping and needs to distinguish between the two cases. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a012692496c968960f4ea27db4e89cc7d}{actions\+\_\+after\+\_\+implicit\+\_\+timestep}} ()
\begin{DoxyCompactList}\small\item\em Actions that should be performed after each implicit time step. This is needed when one wants to solve a steady problem before timestepping and needs to distinguish between the two cases. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a38d914a74e7998ddc74c205884d36d57}{actions\+\_\+after\+\_\+implicit\+\_\+timestep\+\_\+and\+\_\+error\+\_\+estimation}} ()
\begin{DoxyCompactList}\small\item\em Actions that should be performed after each implicit time step. This is needed if your \doxylink{classoomph_1_1Problem_a012692496c968960f4ea27db4e89cc7d}{actions\+\_\+after\+\_\+implicit\+\_\+timestep()} modify the solution in a way that affects the error estimate. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a6ae06bc0ecba349ebdf76220c1a17546}{actions\+\_\+before\+\_\+explicit\+\_\+timestep}} ()
\begin{DoxyCompactList}\small\item\em Actions that should be performed before each explicit time step. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a51bfd872c45467a65ce977f3753a6d1d}{actions\+\_\+after\+\_\+explicit\+\_\+timestep}} ()
\begin{DoxyCompactList}\small\item\em Actions that should be performed after each explicit time step. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_af10662119a7a0c3a47879fa0d0644452}{actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes}} ()
\begin{DoxyCompactList}\small\item\em Actions that are to be performed before reading in restart data for problems involving unstructured bulk meshes. If the problem contains such meshes we need to strip out any face elements that are attached to them because restart of unstructured meshes re-\/creates their elements and nodes from scratch, leading to dangling pointers from the face elements to the old elements and nodes. This function is virtual and (practically) empty but toggles a flag to indicate that it has been called. This is used to issue a warning, prompting the user to consider overloading it if the problem is found to contain unstructured bulk meshes during restarts. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a498317b3e390eddf2169ab989ee8d6b4}{actions\+\_\+after\+\_\+read\+\_\+unstructured\+\_\+meshes}} ()
\begin{DoxyCompactList}\small\item\em Actions that are to be performed before reading in restart data for problems involving unstructured bulk meshes. Typically used to re-\/attach Face\+Elements, say, that were stripped out in \doxylink{classoomph_1_1Problem_af10662119a7a0c3a47879fa0d0644452}{actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes()}. This function is virtual and (practically) empty but toggles a flag to indicate that it has been called. This is used to issue a warning, prompting the user to consider overloading it if the problem is found to contain unstructured bulk meshes during restarts. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a1d1280f442f9352a614bada21324456d}{actions\+\_\+before\+\_\+distribute}} ()
\begin{DoxyCompactList}\small\item\em Actions to be performed before a (mesh) distribution. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a4d3e3bd312518ca5afef94e169f81c39}{actions\+\_\+after\+\_\+distribute}} ()
\begin{DoxyCompactList}\small\item\em Actions to be performed after a (mesh) distribution. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a1e90bbe5d279295b97ae704487259bcc}{actions\+\_\+after\+\_\+change\+\_\+in\+\_\+global\+\_\+parameter}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Actions that are to be performed when the global parameter addressed by parameter\+\_\+pt has been changed in the function \doxylink{classoomph_1_1Problem_af4d959a47ef6a8d50b394a6761dfab5a}{get\+\_\+derivative\+\_\+wrt\+\_\+global\+\_\+parameter()} The default is to call \doxylink{classoomph_1_1Problem_a0c8d70891f7369bb4bf8412fa1a08ecb}{actions\+\_\+before\+\_\+newton\+\_\+solve()}, \doxylink{classoomph_1_1Problem_ae6ad96ddf5d48b517b89c9a9b879bc4b}{actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} and \doxylink{classoomph_1_1Problem_a033ec7301123deeb7e56d04c38f9f1da}{actions\+\_\+after\+\_\+newton\+\_\+solve()}. This could be amazingly inefficient in certain problems and should be overloaded in such cases. An example would be when a remesh is required in general, but the global parameter does not affect the mesh directly. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a5f08629e3c9c72b441ec7f19f175b2c7}{actions\+\_\+after\+\_\+change\+\_\+in\+\_\+bifurcation\+\_\+parameter}} ()
\begin{DoxyCompactList}\small\item\em Actions that are to be performed after a change in the parameter that is being varied as part of the solution of a bifurcation detection problem. The default is to call \doxylink{classoomph_1_1Problem_a0c8d70891f7369bb4bf8412fa1a08ecb}{actions\+\_\+before\+\_\+newton\+\_\+solve()}, \doxylink{classoomph_1_1Problem_ae6ad96ddf5d48b517b89c9a9b879bc4b}{actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} and \doxylink{classoomph_1_1Problem_a033ec7301123deeb7e56d04c38f9f1da}{actions\+\_\+after\+\_\+newton\+\_\+solve()}. This could be amazingly inefficient in certain problems and should be overloaded in such cases. An example would be when a remesh is required in general, but the global parameter does not affect the mesh directly. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a54e18ddf6073f9debd478f6b21a717de}{actions\+\_\+after\+\_\+parameter\+\_\+increase}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Empty virtual function; provides hook to perform actions after the increase in the arclength parameter (during continuation) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \& \mbox{\hyperlink{classoomph_1_1Problem_a5aa9936836b7e342c61ac0daba155ec5}{dof\+\_\+derivative}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Access function to the derivative of the i-\/th (local) dof with respect to the arc length, used in continuation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \& \mbox{\hyperlink{classoomph_1_1Problem_a187fca413da164551f4d3344c7baf861}{dof\+\_\+current}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Access function to the current value of the i-\/th (local) dof at the start of a continuation step. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_ad48be6d67071f7da5f6feb7c4fc918f0}{set\+\_\+initial\+\_\+condition}} ()
\begin{DoxyCompactList}\small\item\em Set initial condition (incl previous timesteps). We need to establish this interface because I.\+C. needs to be reset when problem is adapted during the first timestep. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_ac7667864b71a3889c95c29307422ac8e}{global\+\_\+temporal\+\_\+error\+\_\+norm}} ()
\begin{DoxyCompactList}\small\item\em Function to calculate a global error norm, used in adaptive timestepping to control the change in timestep. Individual errors for each data object can be obtained via the data timestepper\textquotesingle{}s temporal\+\_\+error\+\_\+in\+\_\+value or temporal\+\_\+error\+\_\+in\+\_\+position functions and should be combined to construct a global norm. For example, in fluids problems a suitable norm is usually the weighted sum of the errors in the velocities; for moving mesh problems is it usually better to use the weighted sum of the errors in position. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_aea0efdeb4814de433fa2ffb3065831ce}{newton\+\_\+solve\+\_\+continuation}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Perform a basic arc-\/length continuation step using Newton\textquotesingle{}s method. Returns number of Newton steps taken. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_aa539429593ad9ffe3a400a72db2063bd}{newton\+\_\+solve\+\_\+continuation}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&z)
\begin{DoxyCompactList}\small\item\em This function performs a basic continuation step using the Newton method. The number of Newton steps taken is returned, to be used in any external step-\/size control routines. The governing parameter of the problem is passed as a pointer to the routine, as is a vector in which to store the derivatives wrt the parameter, if required. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a58f16ae8f6da042d40fddf01ee3ebd31}{calculate\+\_\+continuation\+\_\+derivatives}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em A function to calculate the derivatives wrt the arc-\/length. This version of the function actually does a linear solve so that the derivatives are calculated "{}exactly"{} rather than using the values at the Newton step just before convergence. This is necessary in spatially adaptive problems, in which the number of degrees of freedom changes and so the appropriate derivatives must be calculated for the new variables. This function is called if no Newton steps were taken in the continuation routine ... i.\+e. the initial residuals were sufficiently small. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a58edae16dc24830521b0df67452db1f7}{calculate\+\_\+continuation\+\_\+derivatives}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&z)
\begin{DoxyCompactList}\small\item\em A function to calculate the derivatives with respect to the arc-\/length required for continuation. The arguments is the solution of the linear system, Jz = d\+R/dparameter, that gives du/dparameter and the direction output from the newton\+\_\+solve\+\_\+continuation function. The derivatives are stored in the Continuation\+Parameters namespace. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_addc838287129a35ef60e38ea854b939c}{calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em A function to calculate the derivatives with respect to the arc-\/length required for continuation by finite differences, using the previous values of the solution. The derivatives are stored in the Continuation\+Parameters namespace. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_af7a83b109e7662abd52ea552d89163cc}{does\+\_\+pointer\+\_\+correspond\+\_\+to\+\_\+problem\+\_\+data}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{parameter\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Return a boolean flag to indicate whether the pointer parameter\+\_\+pt refers to values stored in a \doxylink{classoomph_1_1Data}{Data} object that is contained within the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{classoomph_1_1Problem_a9494223b38728ea186a68d6c70b7ebd4}{set\+\_\+consistent\+\_\+pinned\+\_\+values\+\_\+for\+\_\+continuation}} ()
\begin{DoxyCompactList}\small\item\em Private helper function that is used to set the appropriate pinned values for continuation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \mbox{\hyperlink{classoomph_1_1Problem}{oomph\+::\+Problem}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{classoomph_1_1Problem_aa2e04de221f29c13067e2fe4cf4c70f9}{Copy\+\_\+of\+\_\+problem\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em \doxylink{classoomph_1_1Vector}{Vector} of pointers to copies of the problem used in adaptive bifurcation tracking problems (ALH\+: TEMPORARY HACK, WILL BE FIXED) \end{DoxyCompactList}\item 
std\+::map$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*}, \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} $>$ \mbox{\hyperlink{classoomph_1_1Problem_ae22f10c348ef8afeb1bfd8609cd6a319}{Calculate\+\_\+dparameter\+\_\+analytic}}
\begin{DoxyCompactList}\small\item\em Map used to determine whether the derivatives with respect to a parameter should be finite differenced. The default is that finite differences should be used. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_ac353f1325a3b411b30fbc19314cc18ce}{Calculate\+\_\+hessian\+\_\+products\+\_\+analytic}}
\begin{DoxyCompactList}\small\item\em Map used to determine whether the hessian products should be computed using finite differences. The default is that finite differences will be used. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_ade01b88db08dcec1706fe44eaa0090a3}{Dof\+\_\+distribution\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em The distribution of the DOFs in this problem. This object is created in the \doxylink{classoomph_1_1Problem}{Problem} constructor and setup when assign\+\_\+eqn\+\_\+numbers(...) is called. If this problem is distributed then this distribution will match the distribution of the equation numbers. If this problem is not distributed then this distribution will be uniform over all processors. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{classoomph_1_1Problem_aa9e4cfff7e1dc295036b0e58bc11ae75}{Dof\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em \doxylink{classoomph_1_1Vector}{Vector} of pointers to dofs. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1DoubleVectorWithHaloEntries}{Double\+Vector\+With\+Halo\+Entries}} \mbox{\hyperlink{classoomph_1_1Problem_ae4177b73a790b80d541b416d1e83c6c3}{Element\+\_\+count\+\_\+per\+\_\+dof}}
\begin{DoxyCompactList}\small\item\em Counter that records how many elements contribute to each dof. Used to determine the (discrete) arc-\/length automatically. It really should be an integer, but is a double so that the distribution information can be used for distributed problems. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ \mbox{\hyperlink{classoomph_1_1Problem_a2b2bcde2b051f47278ccf8446699bbfb}{Elemental\+\_\+assembly\+\_\+time}}
\begin{DoxyCompactList}\small\item\em Storage for assembly times (used for load balancing) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1DoubleVectorHaloScheme}{Double\+Vector\+Halo\+Scheme}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_a1dcaa04975d69c616ab294cbfaf53d55}{Halo\+\_\+scheme\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to the halo scheme for any global vectors that have the Dof\+\_\+distribution. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{classoomph_1_1Problem_ac59d9163cc5d008a2ade4de8da06dbf6}{Halo\+\_\+dof\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Storage for the halo degrees of freedom (only required) when accessing via the global equation number in distributed problems. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_a86c4feb98ec982a08dc84fb664f53abc}{Relaxation\+\_\+factor}}
\begin{DoxyCompactList}\small\item\em Relaxation fator for Newton method (only a fractional Newton correction is applied if this is less than 1; default 1). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_a94536b381e949edf5bb4d44434e08925}{Newton\+\_\+solver\+\_\+tolerance}}
\begin{DoxyCompactList}\small\item\em The Tolerance below which the Newton Method is deemed to have converged. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_a52a58a98c3e2e7dbaefcfb1ee7830c35}{Max\+\_\+newton\+\_\+iterations}}
\begin{DoxyCompactList}\small\item\em Maximum number of Newton iterations. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_a3c05eefd6891808a1ef01e51288e0108}{Nnewton\+\_\+iter\+\_\+taken}}
\begin{DoxyCompactList}\small\item\em Actual number of Newton iterations taken during the most recent iteration. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ \mbox{\hyperlink{classoomph_1_1Problem_ab6f510bea9bdfcaf229415440a0a1c98}{Max\+\_\+res}}
\begin{DoxyCompactList}\small\item\em Maximum residuals at start and after each newton iteration. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_accb8811cdf32f14be497917e922c623e}{Max\+\_\+residuals}}
\begin{DoxyCompactList}\small\item\em Maximum desired residual\+: if the maximum residual exceeds this value, the program will exit. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a3e9aecf88bde320bc2d169b5f3c99fee}{Time\+\_\+adaptive\+\_\+newton\+\_\+crash\+\_\+on\+\_\+solve\+\_\+fail}}
\begin{DoxyCompactList}\small\item\em Bool to specify what to do if a Newton solve fails within a time adaptive solve. Default (false) is to half the step and try again. If true then crash instead. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a022796f2c96f2dff6ed1db2338c93aaf}{Jacobian\+\_\+reuse\+\_\+is\+\_\+enabled}}
\begin{DoxyCompactList}\small\item\em Is re-\/use of Jacobian in Newton iteration enabled? Default\+: false. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a2c4702c75739c967ed582dbd0a7ba56f}{Jacobian\+\_\+has\+\_\+been\+\_\+computed}}
\begin{DoxyCompactList}\small\item\em Has a Jacobian been computed (and can therefore be re-\/used if required)? Default\+: false. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_ade2d3efba34f69aafaefc076ddb3b8d4}{Problem\+\_\+is\+\_\+nonlinear}}
\begin{DoxyCompactList}\small\item\em Boolean flag indicating if we\textquotesingle{}re dealing with a linear or nonlinear \doxylink{classoomph_1_1Problem}{Problem} -- if set to false the Newton solver will not check the residual before or after the linear solve. Set to true by default; can be over-\/written in specific \doxylink{classoomph_1_1Problem}{Problem} class. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_aedefa8337ace6043c2fdfd5a2d19afd3}{Pause\+\_\+at\+\_\+end\+\_\+of\+\_\+sparse\+\_\+assembly}}
\begin{DoxyCompactList}\small\item\em Protected boolean flag to halt program execution during sparse assemble process to assess peak memory usage. Initialised to false (obviously!) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a524b68efcaae084ad7144f944cb39c69}{Doc\+\_\+time\+\_\+in\+\_\+distribute}}
\begin{DoxyCompactList}\small\item\em Protected boolean flag to provide comprehensive timimings during problem distribution. Initialised to false. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_a447f9d42b248f6c394581ff1a0b02513}{Sparse\+\_\+assembly\+\_\+method}}
\begin{DoxyCompactList}\small\item\em Flag to determine which sparse assembly method to use By default we use assembly by vectors of pairs. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_ad2d5f8e18619fafcff11727b1c55b3eb}{Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+initial\+\_\+allocation}}
\begin{DoxyCompactList}\small\item\em the number of elements to initially allocate for a matrix row within the sparse\+\_\+assembly\+\_\+with\+\_\+two\+\_\+arrays(...) method (if a matrix of this size has not been assembled already). If a matrix of this size has been assembled then the number of elements in each row in that matrix is used as the initial allocation \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_aeb58a3cead4d10697c4471523f705130}{Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+allocation\+\_\+increment}}
\begin{DoxyCompactList}\small\item\em the number of elements to add to a matrix row when the initial allocation is exceeded within the sparse\+\_\+assemble\+\_\+with\+\_\+two\+\_\+arrays(...) method. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} $>$ $>$ \mbox{\hyperlink{classoomph_1_1Problem_a547c85bfa6a2eb3effc4db1b46ebcdde}{Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+previous\+\_\+allocation}}
\begin{DoxyCompactList}\small\item\em the number of elements in each row of a compressed matrix in the previous matrix assembly. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_ad1a1ffc2bd685377ce7213452876b127}{Numerical\+\_\+zero\+\_\+for\+\_\+sparse\+\_\+assembly}}
\begin{DoxyCompactList}\small\item\em A tolerance used to determine whether the entry in a sparse matrix is zero. If it is then storage need not be allocated. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_ad26c62f5aab816943144ac61fbf7725e}{FD\+\_\+step\+\_\+used\+\_\+in\+\_\+get\+\_\+hessian\+\_\+vector\+\_\+products}}
\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_af4d25809ac090102a4d4a398e4ad0e26}{Mass\+\_\+matrix\+\_\+reuse\+\_\+is\+\_\+enabled}}
\begin{DoxyCompactList}\small\item\em Is re-\/use of the mass matrix in explicit timestepping enabled Default\+:false. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a6067c6d344363a073fb8d02a99fb7ed0}{Mass\+\_\+matrix\+\_\+has\+\_\+been\+\_\+computed}}
\begin{DoxyCompactList}\small\item\em Has the mass matrix been computed (and can therefore be reused) Default\+: false. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a97ca0078fff6adca318835c11503dc2d}{Discontinuous\+\_\+element\+\_\+formulation}}
\begin{DoxyCompactList}\small\item\em Is the problem a discontinuous one, i.\+e. can the elemental contributions be treated independently. Default\+: false. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_ad7456318933aa01114dc78498bfd6d79}{Minimum\+\_\+dt}}
\begin{DoxyCompactList}\small\item\em Minimum desired dt\+: if dt falls below this value, exit. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_a7b5fde48b00a7fdc5f1fbbee138d0414}{Maximum\+\_\+dt}}
\begin{DoxyCompactList}\small\item\em Maximum desired dt. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_aaaeab9469b342a3b849ee5f2ef7051f3}{DTSF\+\_\+max\+\_\+increase}}
\begin{DoxyCompactList}\small\item\em Maximum possible increase of dt between time-\/steps in adaptive schemes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_abbb93979ed99d40eb845ba7296355965}{DTSF\+\_\+min\+\_\+decrease}}
\begin{DoxyCompactList}\small\item\em Minimum allowed decrease of dt between time-\/steps in adaptive schemes. Lower scaling values will reject the time-\/step (and retry with a smaller dt). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_abdee700b2cec37540cf1e7e1462df6c3}{Minimum\+\_\+dt\+\_\+but\+\_\+still\+\_\+proceed}}
\begin{DoxyCompactList}\small\item\em If Minimum\+\_\+dt\+\_\+but\+\_\+still\+\_\+proceed positive, then dt will not be reduced below this value during adaptive timestepping and the computation will continue with this value, accepting the larger errors that this will incur). Note\+: This option is disabled by default as this value is initialised to -\/1.\+0. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a708322baf423e373970384006c2ca4db}{Scale\+\_\+arc\+\_\+length}}
\begin{DoxyCompactList}\small\item\em Boolean to control whether arc-\/length should be scaled. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_a37fb791188428c8186ffd5c52b6cf576}{Desired\+\_\+proportion\+\_\+of\+\_\+arc\+\_\+length}}
\begin{DoxyCompactList}\small\item\em Proportion of the arc-\/length to taken by the parameter. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_a123843ca2ed6384342939ef2b19477ef}{Theta\+\_\+squared}}
\begin{DoxyCompactList}\small\item\em Value of the scaling parameter required so that the parameter occupies the desired proportion of the arc length. NOTE\+: If you wish to change this then make sure to set the value of Scale\+\_\+arc\+\_\+length to false to ensure the value of this isn\textquotesingle{}t overwritten during the arc-\/length process. Instead of changing this variable, it\textquotesingle{}s better to actually update the Desired\+\_\+proportion\+\_\+of\+\_\+arc\+\_\+length value. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{int}} \mbox{\hyperlink{classoomph_1_1Problem_aca97d61840e46edc914e3cb4b98fd437}{Sign\+\_\+of\+\_\+jacobian}}
\begin{DoxyCompactList}\small\item\em Storage for the sign of the global Jacobian. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_a6904003416e9a9257db70c009bdc69ed}{Continuation\+\_\+direction}}
\begin{DoxyCompactList}\small\item\em The direction of the change in parameter that will ensure that a branch is followed in one direction only. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_aa5082325ca4cafe5a9ec03ef79c67a6f}{Parameter\+\_\+derivative}}
\begin{DoxyCompactList}\small\item\em Storage for the derivative of the global parameter wrt arc-\/length. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_a8e29673eb80559888d1c6148c4f11e57}{Parameter\+\_\+current}}
\begin{DoxyCompactList}\small\item\em Storage for the present value of the global parameter. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_adbecce0cb1bd7b6b21285568e41ee3eb}{Use\+\_\+continuation\+\_\+timestepper}}
\begin{DoxyCompactList}\small\item\em Boolean to control original or new storage of dof stuff. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_af0372f742b90bb402c6edc720ceeb421}{Dof\+\_\+derivative\+\_\+offset}}
\begin{DoxyCompactList}\small\item\em Storage for the offset for the continuation derivatives from the original dofs (default is 1, but this will be differnet when continuing bifurcations and periodic orbits) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_a57825be8c76db9e23e6a9aa0d73973b2}{Dof\+\_\+current\+\_\+offset}}
\begin{DoxyCompactList}\small\item\em Storage for the offset for the current values of dofs from the original dofs (default is 2, but this will be differnet when continuing bifurcations and periodic orbits) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ \mbox{\hyperlink{classoomph_1_1Problem_a1861321b2d129707935bf1191238daca}{Dof\+\_\+derivative}}
\begin{DoxyCompactList}\small\item\em Storage for the derivative of the problem variables wrt arc-\/length. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} $>$ \mbox{\hyperlink{classoomph_1_1Problem_a366b50c490e9fd3ddafa05b2fbd0b883}{Dof\+\_\+current}}
\begin{DoxyCompactList}\small\item\em Storage for the present values of the variables. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_ad412d49617d0b0998e5eb440c7a20f3f}{Ds\+\_\+current}}
\begin{DoxyCompactList}\small\item\em Storage for the current step value. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{unsigned}} \mbox{\hyperlink{classoomph_1_1Problem_abfe8db162a0bda98add0062a45f41cbf}{Desired\+\_\+newton\+\_\+iterations\+\_\+ds}}
\begin{DoxyCompactList}\small\item\em The desired number of Newton Steps to reach convergence at each step along the arc. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_ad0f8bb126a4f5ddeb559c23a8d451d8d}{Minimum\+\_\+ds}}
\begin{DoxyCompactList}\small\item\em Minimum desired value of arc-\/length. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a08dfc704030bb65cea3d9784c5271af0}{Bifurcation\+\_\+detection}}
\begin{DoxyCompactList}\small\item\em Boolean to control bifurcation detection via determinant of Jacobian. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_ab805e5e5fb94f941cc7ff1b850d83269}{Bisect\+\_\+to\+\_\+find\+\_\+bifurcation}}
\begin{DoxyCompactList}\small\item\em Boolean to control wheter bisection is used to located bifurcation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a643f61299463a3bbf7be3f6a112aa130}{First\+\_\+jacobian\+\_\+sign\+\_\+change}}
\begin{DoxyCompactList}\small\item\em Boolean to indicate whether a sign change has occured in the Jacobian. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a8109bf56e9203d248ae30a50bb9cfe90}{Arc\+\_\+length\+\_\+step\+\_\+taken}}
\begin{DoxyCompactList}\small\item\em Boolean to indicate whether an arc-\/length step has been taken. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a80dac9f70c77302805bb782cc6f1ad0f}{Use\+\_\+finite\+\_\+differences\+\_\+for\+\_\+continuation\+\_\+derivatives}}
\begin{DoxyCompactList}\small\item\em Boolean to specify which scheme to use to calculate the continuation derivatievs. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a5c6bd262be3544343a30767da278d846}{Problem\+\_\+has\+\_\+been\+\_\+distributed}}
\begin{DoxyCompactList}\small\item\em Has the problem been distributed amongst multiple processors? \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a2cee2eaaf1ac49020fc76b3b6adb9bba}{Bypass\+\_\+increase\+\_\+in\+\_\+dof\+\_\+check\+\_\+during\+\_\+pruning}}
\begin{DoxyCompactList}\small\item\em Boolean to bypass check of increase in dofs during pruning. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1OomphCommunicator}{Oomph\+Communicator}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classoomph_1_1Problem_a937afdd0d5a039943482f8be9b24c82e}{Communicator\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em The communicator for this problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_a01d7376ab9cc06e4d5619b34fd39dee2}{Always\+\_\+take\+\_\+one\+\_\+newton\+\_\+step}}
\begin{DoxyCompactList}\small\item\em Boolean to indicate whether a Newton step should be taken even if the initial residuals are below the required tolerance. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{double}} \mbox{\hyperlink{classoomph_1_1Problem_a359d1936bc2146e0a0ce697776efcf91}{Timestep\+\_\+reduction\+\_\+factor\+\_\+after\+\_\+nonconvergence}}
\begin{DoxyCompactList}\small\item\em What it says\+: If temporally adaptive Newton solver fails to to converge, reduce timestep by this factor and try again; defaults to 1/2; can be over-\/written by user in derived problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{bool}} \mbox{\hyperlink{classoomph_1_1Problem_ab27af4a444de9f59125ee50ac778d97a}{Keep\+\_\+temporal\+\_\+error\+\_\+below\+\_\+tolerance}}
\begin{DoxyCompactList}\small\item\em Boolean to decide if a timestep is to be rejected if the error estimate post-\/solve (computed by \doxylink{classoomph_1_1Problem_ac7667864b71a3889c95c29307422ac8e}{global\+\_\+temporal\+\_\+error\+\_\+norm()}) exceeds the tolerance required in the call to adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(...). Defaults to true. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Protected Attributes inherited from \mbox{\hyperlink{classoomph_1_1Problem}{oomph\+::\+Problem}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{static}} \mbox{\hyperlink{classoomph_1_1ContinuationStorageScheme}{Continuation\+Storage\+Scheme}} \mbox{\hyperlink{classoomph_1_1Problem_ade29c0a82218d50136b4b3860055ad30}{Continuation\+\_\+time\+\_\+stepper}}
\begin{DoxyCompactList}\small\item\em Storage for the single static continuation timestorage object. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\doxylink{classoomph_1_1HelmholtzMGProblem}{Helmholtz\+MGProblem} class; subclass of \doxylink{classoomph_1_1Problem}{Problem}. 

Definition at line \mbox{\hyperlink{helmholtz__geometric__multigrid_8h_source_l00049}{49}} of file \mbox{\hyperlink{helmholtz__geometric__multigrid_8h_source}{helmholtz\+\_\+geometric\+\_\+multigrid.\+h}}.



\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classoomph_1_1HelmholtzMGProblem_ab74fba72dcdfc8f448a992944764cd4c}\label{classoomph_1_1HelmholtzMGProblem_ab74fba72dcdfc8f448a992944764cd4c} 
\index{oomph::HelmholtzMGProblem@{oomph::HelmholtzMGProblem}!HelmholtzMGProblem@{HelmholtzMGProblem}}
\index{HelmholtzMGProblem@{HelmholtzMGProblem}!oomph::HelmholtzMGProblem@{oomph::HelmholtzMGProblem}}
\doxysubsubsection{\texorpdfstring{HelmholtzMGProblem()}{HelmholtzMGProblem()}}
{\footnotesize\ttfamily oomph\+::\+Helmholtz\+MGProblem\+::\+Helmholtz\+MGProblem (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructor. Initialise pointers to coarser and finer levels. 



Definition at line \mbox{\hyperlink{helmholtz__geometric__multigrid_8h_source_l00053}{53}} of file \mbox{\hyperlink{helmholtz__geometric__multigrid_8h_source}{helmholtz\+\_\+geometric\+\_\+multigrid.\+h}}.

\Hypertarget{classoomph_1_1HelmholtzMGProblem_a0cc940bfc51d6e95e420b60938640e54}\label{classoomph_1_1HelmholtzMGProblem_a0cc940bfc51d6e95e420b60938640e54} 
\index{oomph::HelmholtzMGProblem@{oomph::HelmholtzMGProblem}!````~HelmholtzMGProblem@{\texorpdfstring{$\sim$}{\string~}HelmholtzMGProblem}}
\index{````~HelmholtzMGProblem@{\texorpdfstring{$\sim$}{\string~}HelmholtzMGProblem}!oomph::HelmholtzMGProblem@{oomph::HelmholtzMGProblem}}
\doxysubsubsection{\texorpdfstring{\texorpdfstring{$\sim$}{\string~}HelmholtzMGProblem()}{\string~HelmholtzMGProblem()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} oomph\+::\+Helmholtz\+MGProblem\+::\texorpdfstring{$\sim$}{\string~}\+Helmholtz\+MGProblem (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Destructor (empty) 



Definition at line \mbox{\hyperlink{helmholtz__geometric__multigrid_8h_source_l00056}{56}} of file \mbox{\hyperlink{helmholtz__geometric__multigrid_8h_source}{helmholtz\+\_\+geometric\+\_\+multigrid.\+h}}.



\doxysubsection{Member Function Documentation}
\Hypertarget{classoomph_1_1HelmholtzMGProblem_a174dfbef9a1f46e103e50046c47138e6}\label{classoomph_1_1HelmholtzMGProblem_a174dfbef9a1f46e103e50046c47138e6} 
\index{oomph::HelmholtzMGProblem@{oomph::HelmholtzMGProblem}!make\_new\_problem@{make\_new\_problem}}
\index{make\_new\_problem@{make\_new\_problem}!oomph::HelmholtzMGProblem@{oomph::HelmholtzMGProblem}}
\doxysubsubsection{\texorpdfstring{make\_new\_problem()}{make\_new\_problem()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1HelmholtzMGProblem}{Helmholtz\+MGProblem}} \texorpdfstring{$\ast$}{*} oomph\+::\+Helmholtz\+MGProblem\+::make\+\_\+new\+\_\+problem (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



This function needs to be implemented in the derived problem\+: Returns a pointer to a new object of the same type as the derived problem. 

\Hypertarget{classoomph_1_1HelmholtzMGProblem_a647ea79cc9e3e032158aa8416419af8c}\label{classoomph_1_1HelmholtzMGProblem_a647ea79cc9e3e032158aa8416419af8c} 
\index{oomph::HelmholtzMGProblem@{oomph::HelmholtzMGProblem}!mg\_bulk\_mesh\_pt@{mg\_bulk\_mesh\_pt}}
\index{mg\_bulk\_mesh\_pt@{mg\_bulk\_mesh\_pt}!oomph::HelmholtzMGProblem@{oomph::HelmholtzMGProblem}}
\doxysubsubsection{\texorpdfstring{mg\_bulk\_mesh\_pt()}{mg\_bulk\_mesh\_pt()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{virtual}} \mbox{\hyperlink{classoomph_1_1TreeBasedRefineableMeshBase}{Tree\+Based\+Refineable\+Mesh\+Base}} \texorpdfstring{$\ast$}{*} oomph\+::\+Helmholtz\+MGProblem\+::mg\+\_\+bulk\+\_\+mesh\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Function to get a pointer to the mesh we will be working with. If there are flux elements present in the mesh this will be overloaded to return a pointer to the bulk mesh otherwise it can be overloaded to point to the global mesh but it must be of type \doxylink{classoomph_1_1RefineableMeshBase}{Refineable\+Mesh\+Base}. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{helmholtz__geometric__multigrid_8h}{helmholtz\+\_\+geometric\+\_\+multigrid.\+h}}\end{DoxyCompactItemize}
