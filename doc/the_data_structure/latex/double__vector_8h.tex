\doxysection{double\+\_\+vector.\+h File Reference}
\hypertarget{double__vector_8h}{}\label{double__vector_8h}\index{double\_vector.h@{double\_vector.h}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classoomph_1_1DoubleVector}{oomph\+::\+Double\+Vector}}
\begin{DoxyCompactList}\small\item\em A vector in the mathematical sense, initially developed for linear algebra type applications. If MPI then this vector can be distributed -\/ its distribution is described by the \doxylink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} object at Distribution\+\_\+pt. \doxylink{classoomph_1_1Data}{Data} is stored in a C-\/style pointer vector (double\texorpdfstring{$\ast$}{*}) \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespaceoomph}{oomph}}
\begin{DoxyCompactList}\small\item\em //////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////// \end{DoxyCompactList}\item 
namespace \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers}{oomph\+::\+Double\+Vector\+Helpers}}
\begin{DoxyCompactList}\small\item\em Namespace for helper functions for Double\+Vectors. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_acf43b80ace3f8a4633190ab36136083b}{oomph\+::\+Double\+Vector\+Helpers\+::concatenate}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{in\+\_\+vector\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{out\+\_\+vector}})
\begin{DoxyCompactList}\small\item\em Concatenate Double\+Vectors. Takes a \doxylink{classoomph_1_1Vector}{Vector} of Double\+Vectors. If the out vector is built, we will not build a new distribution. Otherwise we build a uniform distribution. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_ae2e2b5728675ea85a48158f5d93f6593}{oomph\+::\+Double\+Vector\+Helpers\+::concatenate}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{in\+\_\+vector}}, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{out\+\_\+vector}})
\begin{DoxyCompactList}\small\item\em Wrapper around the other concatenate(...) function. Be careful with \doxylink{classoomph_1_1Vector}{Vector} of vectors. If the Double\+Vectors are resized, there could be reallocation of memory. If we wanted to use the function which takes a \doxylink{classoomph_1_1Vector}{Vector} of pointers to Double\+Vectors, we would either have to invoke new and remember to delete, or create a temporary \doxylink{classoomph_1_1Vector}{Vector} to store pointers to the \doxylink{classoomph_1_1DoubleVector}{Double\+Vector} objects. This wrapper is meant to make life easier for the user by avoiding calls to new/delete AND without creating a temporary vector of pointers to Double\+Vectors. If we had C++ 11, this would be so much nicer since we can use smart pointers which will delete themselves, so we do not have to remember to delete! \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_a3c0fa6de2c35301c556b9530c9ab2bc4}{oomph\+::\+Double\+Vector\+Helpers\+::split}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{in\+\_\+vector}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{out\+\_\+vector\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Split a \doxylink{classoomph_1_1DoubleVector}{Double\+Vector} into the out Double\+Vectors. Let vec\+\_\+A be the in \doxylink{classoomph_1_1Vector}{Vector}, and let vec\+\_\+B and vec\+\_\+C be the out vectors. Then the splitting of vec\+\_\+A is depicted below\+: vec\+\_\+A\+: \mbox{[}a0 (on p0) a1\mbox{]} (on p0) \mbox{[}a2 (on p1) a3\mbox{]} (on p1) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_a111654d0a7b7bfaae9cdd8101c8005ca}{oomph\+::\+Double\+Vector\+Helpers\+::split}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{in\+\_\+vector}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{out\+\_\+vector}})
\begin{DoxyCompactList}\small\item\em Wrapper around the other split(...) function. Be careful with \doxylink{classoomph_1_1Vector}{Vector} of vectors. If the Double\+Vectors are resized, there could be reallocation of memory. If we wanted to use the function which takes a \doxylink{classoomph_1_1Vector}{Vector} of pointers to Double\+Vectors, we would either have to invoke new and remember to delete, or create a temporary \doxylink{classoomph_1_1Vector}{Vector} to store pointers to the \doxylink{classoomph_1_1DoubleVector}{Double\+Vector} objects. This wrapper is meant to make life easier for the user by avoiding calls to new/delete AND without creating a temporary vector of pointers to Double\+Vectors. If we had C++ 11, this would be so much nicer since we can use smart pointers which will delete themselves, so we do not have to remember to delete! \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_a3ea9f7c40548e1a88402312e6f15d1fc}{oomph\+::\+Double\+Vector\+Helpers\+::concatenate\+\_\+without\+\_\+communication}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{in\+\_\+vector\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{out\+\_\+vector}})
\begin{DoxyCompactList}\small\item\em Concatenate Double\+Vectors. Takes a \doxylink{classoomph_1_1Vector}{Vector} of Double\+Vectors. If the out vector is built, we will not build a new distribution. Otherwise a new distribution will be built using Linear\+Algebra\+Distribution\+::concatenate(...). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_a568db46f65c1d234ac6f96ab54fafe60}{oomph\+::\+Double\+Vector\+Helpers\+::concatenate\+\_\+without\+\_\+communication}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{in\+\_\+vector}}, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{out\+\_\+vector}})
\begin{DoxyCompactList}\small\item\em Wrapper around the other concatenate\+\_\+without\+\_\+communication(...) function. Be careful with \doxylink{classoomph_1_1Vector}{Vector} of vectors. If the Double\+Vectors are resized, there could be reallocation of memory. If we wanted to use the function which takes a \doxylink{classoomph_1_1Vector}{Vector} of pointers to Double\+Vectors, we would either have to invoke new and remember to delete, or create a temporary \doxylink{classoomph_1_1Vector}{Vector} to store pointers to the \doxylink{classoomph_1_1DoubleVector}{Double\+Vector} objects. This wrapper is meant to make life easier for the user by avoiding calls to new/delete AND without creating a temporary vector of pointers to Double\+Vectors. If we had C++ 11, this would be so much nicer since we can use smart pointers which will delete themselves, so we do not have to remember to delete! \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_aa87594da930b3eed12a27838972f10f8}{oomph\+::\+Double\+Vector\+Helpers\+::split\+\_\+without\+\_\+communication}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{in\+\_\+vector}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{out\+\_\+vector\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Split a \doxylink{classoomph_1_1DoubleVector}{Double\+Vector} into the out Double\+Vectors. \doxylink{classoomph_1_1Data}{Data} stays on its current processor, no data is sent between processors. This results in our vectors which are a permutation of the in vector. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{void}} \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_a66afcc493558424fb89f26bc23dd5bf2}{oomph\+::\+Double\+Vector\+Helpers\+::split\+\_\+without\+\_\+communication}} (\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{const}} \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{in\+\_\+vector}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&\mbox{\hyperlink{classoomph_1_1TAdvectionDiffusionReactionElement}{out\+\_\+vector}})
\begin{DoxyCompactList}\small\item\em Wrapper around the other split\+\_\+without\+\_\+communication(...) function. Be careful with \doxylink{classoomph_1_1Vector}{Vector} of vectors. If the Double\+Vectors are resized, there could be reallocation of memory. If we wanted to use the function which takes a \doxylink{classoomph_1_1Vector}{Vector} of pointers to Double\+Vectors, we would either have to invoke new and remember to delete, or create a temporary \doxylink{classoomph_1_1Vector}{Vector} to store pointers to the \doxylink{classoomph_1_1DoubleVector}{Double\+Vector} objects. This wrapper is meant to make life easier for the user by avoiding calls to new/delete AND without creating a temporary vector of pointers to Double\+Vectors. If we had C++ 11, this would be so much nicer since we can use smart pointers which will delete themselves, so we do not have to remember to delete! \end{DoxyCompactList}\end{DoxyCompactItemize}
