\chapter{The data structure}
\hypertarget{index}{}\label{index}\index{The data structure@{The data structure}}
\hypertarget{index_intro}{}\doxysection{\texorpdfstring{Introduction}{Introduction}}\label{index_intro}
{\ttfamily oomph-\/lib} is big! This document gives a "{}bottom up"{} overview of the library\textquotesingle{}s data structure and discusses how the various objects interact. In addition to the detailed discussion provided below, the following doxygen-\/generated lists/indices provide quick access to the documentation of {\ttfamily oomph-\/lib\textquotesingle{}s} classes\+: clicking on the hyperlinks associated with a class takes you directly to a detailed description of its inheritance structure and its members.


\begin{DoxyItemize}
\item \href{../../the_data_structure/html/classes.html}{\texttt{ Class index }}


\item \href{../../the_data_structure/html/functions.html}{\texttt{ Class member index }}


\end{DoxyItemize}

This rest of this document provides a "{}bottom up"{} overview of the data structure in {\ttfamily oomph-\/lib} and discusses how the various objects interact. For brevity, we usually replace the list of arguments to functions by `(...)' and explain the main input and output parameters in words. The full specifications of the interfaces may be found in the individual class documentation, accessible via the links at the top of this page.\hypertarget{index_technical_terms}{}\doxysubsection{\texorpdfstring{Technical terms}{Technical terms}}\label{index_technical_terms}
Throughout this document, certain commonly used terms have a specific technical meaning\+:
\begin{DoxyItemize}
\item {\bfseries{Value\+:}} A {\itshape value} is a (double precision) number (e.\+g. a "{}nodal     value"{}). A value can either be an {\itshape unknown} in the problem or be determined by a boundary condition.
\item {\bfseries{Unknown\+:}} An {\itshape unknown} is a {\itshape value} that is not determined by a boundary condition.
\item {\bfseries{Degree}} {\bfseries{of}} {\bfseries{freedom\+:}} Synonym for {\itshape unknown}; often abbreviated as "{}dof"{}.
\item {\bfseries{History}} {\bfseries{value\+:}} {\itshape History} {\itshape values} are (double precision) numbers that are used by {\ttfamily Time\+Steppers} to calculate time-\/derivatives of values. For instance, history values are often, but {\bfseries{not}} {\bfseries{always}}, the values at previous timesteps.
\item {\bfseries{Pinned/free}}\+: {\itshape Values} that are (are not) determined by boundary conditions are known as pinned (free) values.
\item {\bfseries{Adapt\+:}} {\itshape Mesh} {\itshape adaptation} refines/un-\/refines meshes by adding or deleting selected nodes and elements.
\end{DoxyItemize}\hypertarget{index_general_data_structure}{}\doxysection{\texorpdfstring{Overview of the basic data structure}{Overview of the basic data structure}}\label{index_general_data_structure}
The main components of {\ttfamily oomph-\/lib} are {\ttfamily Data}, {\ttfamily Node}, {\ttfamily Generalised\+Element}, {\ttfamily Mesh} and {\ttfamily Problem}.\hypertarget{index_data}{}\doxysubsection{\texorpdfstring{Data}{Data}}\label{index_data}
The most elementary data structure in {\ttfamily oomph-\/lib} is {\ttfamily Data} (ha!).

Consider the solution of a scalar PDE (e.\+g. a Poisson equation) with certain boundary conditions. The numerical solution of this problem requires the computation of the function values (double precision numbers) at a finite number of spatial positions (the {\ttfamily Nodes}). Typically, these values fall into two categories\+: those that are known {\itshape a} {\itshape priori} (i.\+e. are enforced by boundary conditions), and those that must be determined as part of the solution.

{\ttfamily Data} stores a value --- a double precision number. Typically, the values of the unknowns are determined by the solution of a system of algebraic equations. The solution of this system usually requires a (linear) numbering of the unknowns and associated equations. Hence, {\ttfamily Data} also stores a (long) integer that represents the number of the unknown in the global numbering scheme. {\bfseries{Convention\+:}} If the {\ttfamily Data} value is pinned, we set the equation number to the static member data {\ttfamily Data\+::\+Is\+\_\+pinned}, a negative number.

The number of an unknown is related to the number of the equation that `determines its value', so we use the terms `equation number' and `number of the unknown' interchangeably. In fact, because the term `number of the unknown' is rather tedious, we {\itshape only} use the term `equation number'.

Two observations motivate a straightforward extension of this basic data structure\+:


\begin{DoxyItemize}
\item In time-\/dependent problems, the approximation of time-\/derivatives requires the storage of a certain number of auxiliary values (e.\+g. the values of the unknowns at a number of previous timesteps).
\item In many problems, we are not dealing with scalars (i.\+e. individual doubles) but with vector-\/valued unknowns; for instance, in a 3D fluids problem, we need to store three velocity components at every node.
\end{DoxyItemize}

Therefore, {\ttfamily Data} allows the storage of multiple values (all of which can either be pinned or free, and all of which have their own global equation number); {\ttfamily Data} can also store a certain number of auxiliary (history) values used for timestepping. Finally, {\ttfamily Data} stores a pointer to a {\ttfamily Time\+Stepper} whose member functions relate the history values to the values\textquotesingle{} time-\/derivatives.

Direct, pointer-\/based read/write access to the {\ttfamily Data} values is provided by the functions 
\begin{DoxyCode}{0}
\DoxyCodeLine{Data::value\_pt(\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})\ }

\end{DoxyCode}
 which returns a pointer to the i-\/th value at the present time, and by 
\begin{DoxyCode}{0}
\DoxyCodeLine{Data::value\_pt(\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}},\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})\ }

\end{DoxyCode}
 which returns a pointer to the {\ttfamily t} -\/th history value associated with value {\ttfamily i}. Read-\/only access is also provided by the functions 
\begin{DoxyCode}{0}
\DoxyCodeLine{Data::value(\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})}

\end{DoxyCode}
 and its time-\/dependent counterpart 
\begin{DoxyCode}{0}
\DoxyCodeLine{Data::value(\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}},\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})}

\end{DoxyCode}
 We recommend using these functions instead of the pointer-\/based access functions for read access because the two {\ttfamily Data\+::value(...)} functions are overloaded in the {\ttfamily Node} class (discussed below) so that they return suitably constrained nodal values if a {\ttfamily Node} is hanging. The {\ttfamily Data\+::value(...)} functions cannot be used to set {\ttfamily Data} values. For this purpose we provide the functions 
\begin{DoxyCode}{0}
\DoxyCodeLine{Data::set\_value(\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}},val)}

\end{DoxyCode}
 which sets the {\ttfamily i} -\/th {\ttfamily Data} value to the double precision number {\ttfamily val}; and its time-\/dependent counterpart 
\begin{DoxyCode}{0}
\DoxyCodeLine{Data::set\_value(\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}},\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}},val)}

\end{DoxyCode}
 which sets the {\ttfamily t} -\/th history value associated with the {\ttfamily i} -\/th {\ttfamily Data} value to the double precision number {\ttfamily val}.

The general convention for all time-\/dependent data is that the index t=0 refers to values at the present time, whereas the values associated with t\texorpdfstring{$>$}{>}0 correspond to history values. In many cases (e.\+g. BDF schemes) these history values are simply the values at previous timesteps, but this is not guaranteed. See the section \doxysectlink{index_timestepping}{Time-\/stepping}{1} for further details.\hypertarget{index_nodes}{}\doxysubsection{\texorpdfstring{Nodes}{Nodes}}\label{index_nodes}
In FE computations, most (but not all; see below) {\ttfamily Data} are associated with nodal points. Conversely, all {\ttfamily Nodes} in a finite element mesh have {\ttfamily Data} associated with them. {\ttfamily Nodes} are therefore derived from {\ttfamily Data}, but also store a spatial position, specified by a certain number of spatial (Eulerian) coordinates.

The nodal positions are accessed by the member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Node::x(\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})\ }

\end{DoxyCode}
 which returns the current value of i-\/th nodal coordinate or 
\begin{DoxyCode}{0}
\DoxyCodeLine{Node::x(\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}},\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})\ }

\end{DoxyCode}
 which returns the value of i-\/th nodal coordinate at the present (t=0) timestep or a history value, if (t\texorpdfstring{$>$}{>}0); again, note that the history values are not necessarily positions at previous timesteps.\hypertarget{index_advanced_features_of_nodes}{}\doxysubsubsection{\texorpdfstring{Advanced features\+:}{Advanced features:}}\label{index_advanced_features_of_nodes}
{\ttfamily Nodes} have the following additional features\+:


\begin{DoxyItemize}
\item In moving-\/mesh problems, we must evaluate mesh velocities, which requires the storage of the nodal position at a number of previous timesteps. Storage for the positional history values is allocated by the {\ttfamily Node} constructor. A different {\ttfamily Time\+Stepper} may be used to represent time-\/derivatives of nodal position, so {\ttfamily Nodes} store a separate pointer to a positional {\ttfamily Time\+Stepper}. \mbox{[}Note\+: By default, we allocate the same amount of storage for the history of the nodal positions as we do for the history of the nodal values; e.\+g. if a {\ttfamily BDF$<$2$>$} scheme is used to evaluate the time-\/derivatives of the fluid velocities, we assume that the same timestepping scheme is used (and the same amount of storage required) to determine the mesh velocities from the nodal positions.\mbox{]}
\item For finite elements in which the global position of a point in an element is determined by interpolation from the position of the element\textquotesingle{}s {\ttfamily Nodes} (Lagrange-\/type elements), we need only store the spatial position of the {\ttfamily Nodes}. In many other elements (e.\+g. Hermite-\/type elements), the interpolation of the geometry requires additional quantities, representing, e.\+g. the derivative of the mapping between local and global coordinates. Therefore, we allow the storage of additional positional variables at each {\ttfamily Node}, so that, in general, every {\ttfamily Node} has a number of {\itshape generalised} coordinates for each spatial coordinate direction. For instance, for nodes in 1D Hermite elements, the nodal coordinate of type \textquotesingle{}0\textquotesingle{} stores the global position at the node; the nodal coordinate of type \textquotesingle{}1\textquotesingle{} stores the derivative of the global position w.\+r.\+t. to the element\textquotesingle{}s local coordinate. The member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Node::x\_gen(k,\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})\ }

\end{DoxyCode}
 returns the {\ttfamily i} -\/th coordinate of the {\ttfamily k} -\/th coordinate type.
\item In the context of mesh refinement, nodes can become hanging nodes (i.\+e. nodes on an element\textquotesingle{}s edge/face that are not shared by the adjacent element). The "{}hanging"{} status of a {\ttfamily Node} is indicated by the pointer to its {\ttfamily Hang\+Info} object. For ordinary (non-\/hanging) {\ttfamily Nodes} this pointer is NULL, the default setting; see the section \doxysectlink{index_Hanging_Nodes}{Hanging Nodes}{3} for a more detailed discussion of hanging nodes; in particular, the role of the member functions {\ttfamily Node\+::position()} and {\ttfamily Node\+::value()} 
\item Mesh unrefinement can render nodes obsolete and we use a boolean flag to indicate this status. By default, {\ttfamily Nodes} are not obsolete.
\item {\bfseries{Boundary\+Nodes\+:}} {\ttfamily Nodes} "{}know"{} the domain/mesh boundaries on which they are located. A {\ttfamily Node} can be located on none, one or multiple boundaries; the latter case arises if the {\ttfamily Node} is located on edges and corners of the mesh. ~\newline
 Storage of this information facilitates the automatic determination of boundary conditions for new {\ttfamily Nodes} that are created during mesh refinement.~\newline
 The majority of the {\ttfamily Nodes} will {\bfseries{not}} be located on boundaries, however, and providing storage for the boundary information in every {\ttfamily Node} object is rather wasteful. The derived class {\ttfamily Boundary\+Node} adds the required additional storage to the {\ttfamily Node} class and it follows that ~\newline
 all {\ttfamily Nodes} that could lie on boundaries must be {\ttfamily Boundary\+Nodes}; see \doxysectlink{index_meshes}{Meshes}{2} for further details.
\item {\bfseries{Solid\+Nodes\+:}} Many solid mechanics problems are formulated in Lagrangian coordinates. In this case, the governing equations are discretised in a fixed Lagrangian domain; the nodal coordinates represent the {\ttfamily Nodes\textquotesingle{}} fixed positions in this domain. When the elastic body deforms, material points (and hence the {\ttfamily Nodes}) are displaced to new Eulerian positions. The {\ttfamily Solid\+Node} class is derived from {\ttfamily Node} and contains storage for the {\ttfamily Nodes\textquotesingle{}} {\bfseries{fixed}} positions (i.\+e. the Lagrangian coordinates) AND their {\bfseries{variable}} positions (i.\+e. the Eulerian coordinates), which can be unknowns in the problem. To avoid confusion between the two, the access function for the nodal position, 
\begin{DoxyCode}{0}
\DoxyCodeLine{Node::x(...)\ }

\end{DoxyCode}
 {\bfseries{always}} refers to a {\ttfamily Node\textquotesingle{}s} Eulerian position/coordinate. In {\ttfamily Solid\+Nodes}, we provide a wrapper 
\begin{DoxyCode}{0}
\DoxyCodeLine{SolidNode::xi(..)\ }

\end{DoxyCode}
 that provides access to the Lagrangian coordinates. Similarly, in the case of generalised coordinates 
\begin{DoxyCode}{0}
\DoxyCodeLine{Node::x\_gen(...)\ }

\end{DoxyCode}
 always refers to the generalised Eulerian position and 
\begin{DoxyCode}{0}
\DoxyCodeLine{SolidNode::xi\_gen(...)}

\end{DoxyCode}
 refers to the generalised Lagrangian position.
\end{DoxyItemize}\hypertarget{index_elements}{}\doxysubsection{\texorpdfstring{Elements}{Elements}}\label{index_elements}
\hypertarget{index_Overview}{}\doxysubsubsection{\texorpdfstring{Overview}{Overview}}\label{index_Overview}
Most (finite-\/)elements in {\ttfamily oomph-\/lib} have a four-\/level inheritance structure which separates\+:
\begin{DoxyEnumerate}
\item the basic functionality that is shared by all (generalised) elements.
\item the functionality that is shared by all finite elements.
\item the implementation of the finite element geometry (i.\+e. the shape-\/function-\/based mapping between local and global coordinates).
\item the representation of the mathematics that describes a specific problem.
\end{DoxyEnumerate}The distinction between geometry and `maths' greatly facilitates code-\/reuse as a (geometric) quad-\/element, say, can form the basis for elements that solve a variety of equations (e.\+g. Poisson, Advection--Diffusion, Navier--Stokes, ...). We shall now discuss the four levels of the element hierarchy in more detail.\hypertarget{index_Generalised_Element}{}\doxysubsubsection{\texorpdfstring{Level 0\+: Generalised\+Element}{Level 0: GeneralisedElement}}\label{index_Generalised_Element}
The class {\ttfamily Generalised\+Element} forms the base class for all elements in {\ttfamily oomph-\/lib}. It incorporates the basic functionality that all {\bfseries{elements}} must have. The interfaces at this level are so general that a {\ttfamily Generalised\+Element} can represent discrete algebraic constraints (or even finite-\/difference stencils).

The main role of elements is to provide contributions to a global residual vector and to the global Jacobian matrix. The two virtual functions 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{virtual}\ \textcolor{keywordtype}{void}\ GeneralisedElement::get\_residuals(...)\ }

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{virtual}\ \textcolor{keywordtype}{void}\ GeneralisedElement::get\_jacobian(...)\ }

\end{DoxyCode}
 specify the appropriate interfaces.

In multi-\/physics problems, the elemental residuals and Jacobian will be a combination of the residuals vectors and Jacobian matrices of the constituent single-\/physics elements. An obvious implementation is to use multiple inheritance and function overloading 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }MultiPhysicsElement\ :\ \textcolor{keyword}{public}\ \textcolor{keyword}{virtual}\ SinglePhysicsOneElement,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{virtual}\ SinglePhysicsTwoElement}
\DoxyCodeLine{\ \{\ \ \ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \ [...]}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \textcolor{keywordtype}{void}\ get\_residuals(...)\ }
\DoxyCodeLine{\ \ \ \{}
\DoxyCodeLine{\ \ \ \ SinglePhysicsOneElement::get\_residuals(...);}
\DoxyCodeLine{\ \ \ \ SinglePhysicsTwoElement::get\_residuals(...);}
\DoxyCodeLine{\ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ [...]}
\DoxyCodeLine{}
\DoxyCodeLine{\ \};}

\end{DoxyCode}
 where the {\ttfamily Multi\+Physics\+Element} inherits from {\ttfamily Single\+Physics\+One\+Element} and {\ttfamily Single\+Physics\+Two\+Element}.

A problem with this implementation arises when we consider where to initialise the residuals vector. If the second single-\/physics {\ttfamily get\+\_\+residuals(...)} function initialises the residuals vector, then the contribution of the first single-\/physics element will be negated. When writing a single-\/physics element, however, we cannot know whether it will ever be used as part of a multi-\/physics element and, if so, in which order the {\ttfamily get\+\_\+residuals(...)} functions will be called. The solution adopted in {\ttfamily oomph-\/lib} is to provide the two additional virtual functions 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{virtual}\ \textcolor{keywordtype}{void}\ GeneralisedElement::fill\_in\_contribution\_to\_residuals(...)}

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{virtual}\ \textcolor{keywordtype}{void}\ GeneralisedElement::fill\_in\_contribution\_to\_jacobian(...)}

\end{DoxyCode}
 which {\bfseries{must}} {\bfseries{not}} initialise the residuals or Jacobian, but merely add the contribution of the element to the vector or matrix.

We then use the default implementation 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{virtual}\ \textcolor{keywordtype}{void}\ GeneralisedElement::get\_residuals(Vector<double>\ \&residuals)\ }
\DoxyCodeLine{\ \{}
\DoxyCodeLine{\ \ \textcolor{comment}{//Zero\ the\ residuals\ vector}}
\DoxyCodeLine{\ \ residuals.initialise(0.0);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//Add\ the\ elemental\ contribution\ to\ the\ residuals\ vector}}
\DoxyCodeLine{\ \ fill\_in\_contribution\_to\_residuals(residuals);}
\DoxyCodeLine{\ \ \}}

\end{DoxyCode}
 which permits a simple multi-\/physics re-\/implementation 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }MultiPhysicsElement\ :\ \textcolor{keyword}{public}\ \textcolor{keyword}{virtual}\ SinglePhysicsOneElement,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{virtual}\ SinglePhysicsTwoElement}
\DoxyCodeLine{\ \{\ \ \ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \ [...]}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{keywordtype}{void}\ get\_residuals(Vector<double>\ \&residuals)\ }
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Zero\ the\ residuals\ vector}}
\DoxyCodeLine{\ \ \ residuals.initialise(0.0);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Add\ the\ first\ elemental\ contribution\ to\ the\ residuals\ vector}}
\DoxyCodeLine{\ \ \ SinglePhysicsOneElement::fill\_in\_contribution\_to\_residuals(residuals);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Add\ the\ second\ elemental\ contribution\ to\ the\ residuals\ vector\ \ \ }}
\DoxyCodeLine{\ \ \ SinglePhysicsTwoElement::fill\_in\_contribution\_to\_residuals(residuals);\ }
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ [...]}
\DoxyCodeLine{}
\DoxyCodeLine{\};}

\end{DoxyCode}


The default implementation of {\ttfamily fill\+\_\+in\+\_\+contribution\+\_\+to\+\_\+jacobian(...)} uses finite differences to calculate the Jacobian matrix. Hence, the simplest possible implementation of a new element requires only the specification of {\ttfamily fill\+\_\+in\+\_\+contribution\+\_\+to\+\_\+residuals(...)}.


\begin{DoxyItemize}
\item When computing element residuals and Jacobian matrices, we need to know which {\ttfamily Data} affects the residuals (and hence the Jacobian matrix). For a {\ttfamily Generalised\+Element} such {\ttfamily Data} exists in two forms, accessed via pointers\+:
\begin{DoxyItemize}
\item {\ttfamily Data} that is internal to each element is accessed via pointers to `Internal {\ttfamily Data'}. For instance, in fluid (finite) elements with discontinuous pressure interpolations, the pressure degrees of freedom are local to each element and are stored in the element\textquotesingle{}s \textquotesingle{}Internal {\ttfamily Data\textquotesingle{}}.
\item {\ttfamily Data} that is external to the element. An example is a load parameter such as the external pressure that acts on a shell structure. Such {\ttfamily Data} is accessed via pointers to `External {\ttfamily Data'}. ~\newline

\item As discussed above, all {\ttfamily Data} contains values that are either free (i.\+e. unknown) or pinned (i.\+e. prescribed by boundary conditions). Free/unknown values have a non-\/negative global (equation) number. When assembling an element\textquotesingle{}s local contribution to the global residual vector and the Jacobian matrix, we refer to the unknowns by their local (equation) numbers. In order to add the elemental contribution to the appropriate global degree of freedom, every element has a lookup table that establishes the relation between local and global equation numbers. This lookup table is automatically generated by the element\textquotesingle{}s member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{GeneralisedElement::assign\_local\_eqn\_numbers()\ }

\end{DoxyCode}
 Access to the lookup scheme is provided by the member function {\ttfamily eqn\+\_\+number(...)} so that 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{unsigned}\ i\_local;}
\DoxyCodeLine{GeneralisedElement\ el;}
\DoxyCodeLine{}
\DoxyCodeLine{[...]}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{unsigned}\ i\_global=el.eqn\_number(i\_local);\ }

\end{DoxyCode}
 returns the global equation number {\ttfamily i\+\_\+global} corresponding to the local equation number {\ttfamily i\+\_\+local}. The local equation numbers of the internal and external {\ttfamily Data} are stored in the private arrays {\ttfamily Internal\+\_\+local\+\_\+eqn} and {\ttfamily External\+\_\+local\+\_\+eqn}, accessed by the functions {\ttfamily Generalised\+Element\+::internal\+\_\+local\+\_\+eqn(...)} and {\ttfamily Generalised\+Element\+::external\+\_\+local\+\_\+eqn(...)}, respectively. Thus, {\ttfamily Generalised\+Element\+::internal\+\_\+local\+\_\+eqn(i\+\_\+internal,i\+\_\+value)} returns the local equation number of the {\ttfamily i\+\_\+value} -\/th value stored in the {\ttfamily i\+\_\+internal} -\/th internal {\ttfamily Data} object.
\item All elements have a pointer to a global {\ttfamily Time} object which allows the evaluation of time-\/dependent coefficients.
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{index_Finite_Element}{}\doxysubsubsection{\texorpdfstring{Level 1\+: Finite\+Element}{Level 1: FiniteElement}}\label{index_Finite_Element}
The class {\ttfamily Finite\+Element} is derived from {\ttfamily Generalised\+Element} and incorporates the basic functionality that all {\bfseries{finite}} elements must have.


\begin{DoxyItemize}
\item All {\ttfamily Finite\+Elements} have a certain number of {\ttfamily Nodes}. We access the {\ttfamily Nodes} (and their associated values) via pointers and identify them via their (local) node numbers so that 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::Node\_pt[n]\ }

\end{DoxyCode}
 or the access function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::node\_pt(n)\ }

\end{DoxyCode}
 returns a pointer to the element\textquotesingle{}s {\ttfamily n} -\/th local {\ttfamily Node}.
\begin{DoxyItemize}
\item The {\ttfamily Finite\+Element} class provides wrapper functions that give direct access to an element\textquotesingle{}s (possibly generalised) nodal positions at the present timestep or, where appropriate, its positional history values, so that rather than 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::Node\_pt[n]-\/>x(\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})\ }

\end{DoxyCode}
 we can write 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::nodal\_position(n,\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})\ }

\end{DoxyCode}
 Not only does this make the code more readable but also allows us to formulate the "{}mathematics"{} in general terms.~\newline
 \mbox{[}Furthermore, the function {\ttfamily Finite\+Element\+::nodal\+\_\+position(n,i)} accesses the nodal positions indirectly via {\ttfamily Node\+::position(...)} which ensures that the nodal position is consistent with any constraints associated with the {\ttfamily Node\textquotesingle{}s} hanging status; see section \doxysectlink{index_Hanging_Nodes}{Hanging Nodes}{3} for further details.\mbox{]}
\item When {\ttfamily Nodes} are created in a (templated) finite element mesh, it is important that {\ttfamily Nodes} of the correct type with the appropriate amount of storage are created. For instance, Poisson elements require {\ttfamily Nodes} that provide storage for a single value at each {\ttfamily Node}, whereas 2D Taylor-\/\+Hood, Navier-\/\+Stokes elements require storage for three values (two velocities and one pressure) at the corner {\ttfamily Nodes}, but only two values (the two velocities) at all others. The member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::construct\_node(...)\ }

\end{DoxyCode}
 creates a {\ttfamily Node}, stores a pointer to the {\ttfamily Node} in the {\ttfamily Finite\+Element\+::\+Node\+\_\+pt} vector and returns a pointer to the newly created {\ttfamily Node}. The function is overloaded in elements that require a different type of {\ttfamily Node}, for example {\ttfamily Solid\+Element\+::construct\+\_\+node(...)} creates a {\ttfamily Solid\+Node} rather than a {\ttfamily Node}. ~\newline
 The function {\ttfamily Finite\+Element\+::construct\+\_\+node(...)} determines the necessary parameters for the node construction from virtual functions or internal data that must have been set during construction of the particular element. \label{index_set_commands}%
\Hypertarget{index_set_commands}%
 The spatial dimension of the {\ttfamily Node} and the number of generalised coordinates must be set in the constructor of a geometric {\ttfamily Finite\+Element} (level 2 in the element hierarchy) by using the appropriate protected member functions. The only function that {\bfseries{must}} be called is 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::set\_dimension(dim),\ }

\end{DoxyCode}
 which sets the spatial dimension of the element; by default the spatial dimension of the {\ttfamily Finite\+Element\textquotesingle{}s} {\ttfamily Nodes} is assumed to be the same. For example, 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::set\_dimension(2)\ }

\end{DoxyCode}
 sets both the spatial dimension of the element and the spatial dimension of its {\ttfamily Nodes} to be two. If the nodal dimension is not the same as the dimension of the element the member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::set\_nodal\_dimension(dim\_node)\ }

\end{DoxyCode}
 should be used to change the value of the nodal dimension. By default, {\ttfamily Finite\+Elements} interpolate a single position type, the position itself. If generalised coordinates are used, the number of generalised coordinates should be set using the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::set\_n\_nodal\_position\_type(n\_pos\_type).\ }

\end{DoxyCode}
 The number of values stored at each {\ttfamily Node} is determined from the virtual member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::required\_nvalue(...)\ \ }

\end{DoxyCode}
 In its default implementation this function returns zero so the function must be overloaded in specific derived {\ttfamily Finite\+Elements} that require storage for some values at its {\ttfamily Nodes}.

See section \doxysectlink{index_meshes}{Meshes}{2} for a full explanation of how and when {\ttfamily Nodes} are created.
\item The {\ttfamily Finite\+Element} class also defines standard interfaces for member functions that compute the shape functions and their derivatives with respect to the local and global (Eulerian) coordinates, 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::shape(...)\ }

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::dshape\_local(...)\ }

\end{DoxyCode}
 The mappings from local to global Eulerian coordinates are implemented in complete generality in the class. The function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::interpolated\_x(...)\ }

\end{DoxyCode}
 returns the interpolated Eulerian position within the element; 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::dshape\_eulerian(...),\ }

\end{DoxyCode}
 returns the derivative of the shape functions with respect to the Eulerian coordinates; and 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::J\_eulerian(...)\ }

\end{DoxyCode}
 returns the Jacobian of the mapping from Eulerian coordinates to local coordinates.
\item The function {\ttfamily Generalised\+Element\+::assign\+\_\+local\+\_\+eqn\+\_\+numbers()} is overloaded in the {\ttfamily Finite\+Element} class to ensure that local equation numbers are also assigned to the nodal {\ttfamily Data} (which does not necessarily exist in all {\ttfamily Generalised\+Elements}). These local equation numbers are stored in the private array {\ttfamily Finite\+Element\+::\+Nodal\+\_\+local\+\_\+eqn}, accessed by the function {\ttfamily {\ttfamily Finite\+Element\+::nodal\+\_\+local\+\_\+eqn(...)}.} 
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{index_Geometric_Element}{}\doxysubsubsection{\texorpdfstring{Level 2\+: Geometric Elements}{Level 2: Geometric Elements}}\label{index_Geometric_Element}
At this level, we specify the element geometry and the mapping between local and global coordinates. Wherever possible, templating has been (and, for any newly developed elements, should be) used to formulate the elements in a dimension-\/independent way. For instance, Lagrange-\/type 1D line, 2D quad and 3D brick elements are implemented in the doubly-\/templated {\ttfamily QElement$<$\+DIM,\+NNODE\+\_\+1\+D$>$} class. The template parameters indicate the spatial dimension of the element and the number of nodes along the element\textquotesingle{}s one-\/dimensional edges. Hence, {\ttfamily \doxylink{classoomph_1_1QElement}{QElement$<$1,3$>$}} is a three-\/node line element with a quadratic mapping between local and global coordinates; {\ttfamily \doxylink{classoomph_1_1QElement}{QElement$<$3,2$>$}} is an 8 node brick element with a trilinear mapping between local and global coordinates. The dimension and the number of {\ttfamily Nodes} must be set by calling the appropriate {\ttfamily set\+\_\+} functions in the constructor, see \doxylink{index_set_commands}{above}.

The most important member functions implemented at this level include
\begin{DoxyItemize}
\item Functions that evaluate the shape functions (and their derivatives) at given values of the local coordinates.
\item Functions that specify the position of each {\ttfamily Node} inside its {\ttfamily Finite\+Element}, in terms of the {\ttfamily Finite\+Element\textquotesingle{}s} local coordinates and, conversely, functions that determine whether a {\ttfamily Node} is located at a particular local coordinate.
\item Output functions that allow the element shapes to be plotted.
\end{DoxyItemize}Finally, we specify a pointer to a spatial integration scheme (usually a Gauss rule). The order of the integration scheme is based on the order of the interpolation in the isoparametric mapping. If this is inappropriate for an element that is derived from a given geometric element, the default assignment can be over-\/written at a higher level. This is discussed in more detail in a \href{../../optimisation/html/index.html}{\texttt{ separate document.}}\hypertarget{index_Maths_Element}{}\doxysubsubsection{\texorpdfstring{Level 3\+: ‘\+The Maths’}{Level 3: ‘The Maths’}}\label{index_Maths_Element}
At this level, we implement the equations that are represented by the specific element. We implement the interpolation(s) for the unknown function(s), employing either the geometric shape functions that already exist on level 2, or employing additional shape functions defined at this level. This allows us to write further member functions such as {\ttfamily interpolated\+\_\+u(...)}, say, which compute the i-\/th velocity component at the local coordinate {\ttfamily s} like this 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Create\ fluid\ element}}
\DoxyCodeLine{SomeFluidElement\ fluid\_element;}
\DoxyCodeLine{}
\DoxyCodeLine{[...]}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Vector\ of\ local\ coordinates}}
\DoxyCodeLine{Vector<double>\ \mbox{\hyperlink{cfortran_8h_ab7123126e4885ef647dd9c6e3807a21c}{s}}(3);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Vector\ of\ velocity\ components}}
\DoxyCodeLine{Vector<double>\ u(3);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Compute\ the\ velocity\ at\ local\ coordinate\ s}}
\DoxyCodeLine{fluid\_element.interpolated\_u(\mbox{\hyperlink{cfortran_8h_ab7123126e4885ef647dd9c6e3807a21c}{s}},u);}

\end{DoxyCode}
 We introduce wrapper functions to access function values, so that we can formulate "{}\+The Maths"{} in generic terms. Rather than referring to the pressure at node {\ttfamily n}, via 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{unsigned}\ n;}
\DoxyCodeLine{\textcolor{keywordtype}{double}\ press\ =\ Node\_pt[n]-\/>value(3);}

\end{DoxyCode}
 (which forces us to remember that in this particular 3D fluid element, the pressure is stored as the fourth value at all nodes...), say, we provide an access function {\ttfamily p\+\_\+fluid(...)} which allows us to write 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{unsigned}\ n;}
\DoxyCodeLine{\textcolor{keywordtype}{double}\ press\ =\ fluid\_element.p\_fluid(n);}

\end{DoxyCode}
 When writing these wrapper functions, direct access to the nodal values should be avoided to ensure that the element remains functional in the presence of hanging nodes. Hence, the wrapper functions should make use of the {\ttfamily Node\+::value(...)} functions as in this example 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double}\ SomeFluidElement::p\_fluid(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ n)}
\DoxyCodeLine{\ \{\ \textcolor{keywordflow}{return}\ Node\_pt[n]-\/>value(3);\}}

\end{DoxyCode}
 \mbox{[}See section \doxysectlink{index_Hanging_Nodes}{Hanging Nodes}{3} for a full description of hanging nodes.\mbox{]}

The functions 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::assign\_additional\_local\_eqn\_numbers()\ \ }

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::get\_residuals(...)\ }

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::get\_jacobian(...)\ }

\end{DoxyCode}


that were defined (as virtual functions) in {\ttfamily Finite\+Element} can now be implemented for the specific system of equations that are represented by this element. The function {\ttfamily assign\+\_\+additional\+\_\+local\+\_\+eqn\+\_\+numbers()} is called by {\ttfamily Finite\+Element\+::assign\+\_\+local\+\_\+eqn\+\_\+numbers()} and may be used to assign local equation numbers that correspond to particular physical variables. For example, in QCrouzeix\+Raviart "{}fluid"{} elements, the pressure is stored as \textquotesingle{}internal {\ttfamily Data\textquotesingle{}}, so an internal array {\ttfamily P\+\_\+local\+\_\+eqn} could be defined by 
\begin{DoxyCode}{0}
\DoxyCodeLine{P\_local\_eqn[\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}}]\ =\ internal\_local\_eqn(0,\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})\ }

\end{DoxyCode}
 but in QTaylor\+Hood "{}fluid"{} elements, the pressure is stored as nodal {\ttfamily Data}, so that 
\begin{DoxyCode}{0}
\DoxyCodeLine{P\_local\_eqn[\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}}]\ =\ nodal\_local\_eqn(Pconv[\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}}],DIM+1)\ }

\end{DoxyCode}
 In the above, {\ttfamily Pconv}\mbox{[}i\mbox{]} is an array that returns the local node number at which the {\ttfamily i} -\/th pressure freedom is stored and {\ttfamily DIM} is the dimension of the element. The use of such an array introduces a memory overhead, however, because each element must permanently store these additional integers. In general, we prefer to use member functions for this purpose. In QCrouzeix\+Raviart elements, for example, 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ p\_local\_eqn(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \&n)\ }
\DoxyCodeLine{\ \{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ internal\_local\_eqn(0,n);}
\DoxyCodeLine{\ \}}

\end{DoxyCode}
 Thus, in our standard equations the function {\ttfamily assign\+\_\+additional\+\_\+local\+\_\+eqn\+\_\+numbers()} is not used.

Finally, the virtual function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::required\_nvalue(...)\ \ }

\end{DoxyCode}
 should be implemented to specify the number of values that are stored at each of the element\textquotesingle{}s local {\ttfamily Nodes}. The default number of values stored at a {\ttfamily Node} is zero.\hypertarget{index_advanced_features_of_elements}{}\doxysubsubsection{\texorpdfstring{‘\+Advanced’ features for the ‘\+Maths’ level\+:}{‘Advanced’ features for the ‘Maths’ level:}}\label{index_advanced_features_of_elements}
It often makes sense to subdivide the `Maths' level further into
\begin{DoxyEnumerate}
\item A class that contains the abstract FE formulation of the mathematical problem.
\item A class that combines the mathematical formulation with a specific geometrical element.
\end{DoxyEnumerate}

An example is given by the {\ttfamily QPoisson\+Elements} which inherit their maths from {\ttfamily Poisson\+Equations} (templated by the spatial dimension) and their geometry from {\ttfamily QElement} (templated by the spatial dimension and the number of nodes). {\ttfamily Poisson\+Equations} specifies the weak form of the Poisson equation in terms of (virtual) shape and test functions. The {\ttfamily QPoisson\+Elements} turn this abstract formulation into a specific (isoparametric) element, by specifying both test and shape functions as the geometric shape functions defined in {\ttfamily QElement}.\hypertarget{index_no_args_for_element_constructors}{}\doxysubsubsection{\texorpdfstring{Important convention regarding element constructors}{Important convention regarding element constructors}}\label{index_no_args_for_element_constructors}
To facilitate mesh generation and adaptation it is important that element constructors should {\bfseries{not}} have {\bfseries{any}} arguments! If arguments must be passed to an element (e.\+g. function pointers to source functions, etc.), this should be done {\bfseries{after}} the mesh generation, usually in the {\ttfamily Problem} constructor. In adaptive mesh refinement procedures any function/data pointers in newly created elements are set to be the same as those of the father element. If this is not the desired behaviour, arguments should be passed to the elements in the function {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()}.\hypertarget{index_meshes}{}\doxysubsection{\texorpdfstring{Meshes}{Meshes}}\label{index_meshes}
At its most basic level, a {\ttfamily Mesh} is simply a collection of elements and {\ttfamily Nodes}, accessed by the vectors of pointers, {\ttfamily Mesh\+::\+Element\+\_\+pt} and {\ttfamily Mesh\+::\+Node\+\_\+pt}, respectively. To facilitate the application of boundary conditions, we also store vectors of pointers to the ({\ttfamily Boundary}){\ttfamily Nodes} that lie on the boundaries of the mesh. They are accessible via the member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Mesh::boundary\_node\_pt(\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}},j)\ }

\end{DoxyCode}
 which returns a pointer to the {\ttfamily j} -\/th node on the {\ttfamily i} -\/th boundary of the mesh.\hypertarget{index_Mesh_generation}{}\doxysubsubsection{\texorpdfstring{Mesh generation}{Mesh generation}}\label{index_Mesh_generation}
The {\ttfamily oomph-\/lib} data structure is designed to make the mesh generation process generic so that meshes developed for one particular problem can easily be re-\/used in others. For this reason, it is generally assumed that a {\ttfamily Mesh} contains only elements of a single type and that this element type is passed to the {\ttfamily Mesh} constructor as a template parameter. Problems that require multiple element types should use multiple meshes, which are discussed in more detail below. It is possible to mix types of elements within a single {\ttfamily Mesh}, if desired; this can be advantageous when the element types are very closely related, for example "{}free surface"{} elements in a mesh of "{}\+Fluid"{} elements.

Mesh generation (usually performed in the {\ttfamily Mesh} \textquotesingle{}s constructor) then works as follows\+:
\begin{DoxyEnumerate}
\item Create the first element and add the pointer to it to the {\ttfamily Mesh\+::\+Element\+\_\+pt} vector. (We know which element to build because we have passed its type as a template parameter.) Since element constructors do not take any arguments, this step is completely generic and ensures that a {\ttfamily Mesh} that was originally created to solve a Poisson equation, say, can also be used to solve Navier-\/\+Stokes equations (provided the element topology is the same, i.\+e. provided the elements are derived from the same type of geometric element (e.\+g. quad or triangle). The element now exists but does not know anything about its {\ttfamily Nodes} etc.
\item Loop over the element\textquotesingle{}s {\ttfamily Nodes} and for each Node\+:
\begin{DoxyEnumerate}
\item Create the {\ttfamily Node} using the element\textquotesingle{}s 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::construct\_node(...)\ }

\end{DoxyCode}
 member function. As discussed above, this function creates {\ttfamily Nodes} of exactly the right type and fills in the element\textquotesingle{}s own {\ttfamily Node\+\_\+pt} vector.
\item {\ttfamily Finite\+Element\+::construct\+\_\+node(...)} returns a pointer to the newly created {\ttfamily Node}; add this to the {\ttfamily Mesh\+::\+Node\+\_\+pt} vector.
\item Assign the nodal coordinates.
\end{DoxyEnumerate}The {\ttfamily Node} is now fully functional and (by default) all values that are stored with it are free (i.\+e. not pinned).
\item If the {\ttfamily Node} is located on a mesh boundary then it must be a {\ttfamily Boundary\+Node}. {\ttfamily Boundary\+Nodes} can be created using the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::construct\_boundary\_node(...)\ }

\end{DoxyCode}
 in place of {\ttfamily Finite\+Element\+::construct\+\_\+node(...)}. Alternatively, if the {\ttfamily Node} has already been created, it can be upgraded to a {\ttfamily Boundary\+Node} by using the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Mesh::convert\_to\_boundary\_node(...)\ }

\end{DoxyCode}
 The function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Mesh::add\_boundary\_node(\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}},\&node)\ }

\end{DoxyCode}
 should then be used to add (a pointer to) the {\ttfamily Boundary\+Node} to the {\ttfamily Mesh\textquotesingle{}s} boundary-\/storage scheme. In addition, the function {\ttfamily Mesh\+::add\+\_\+boundary\+\_\+node()} passes boundary information to the {\ttfamily Node} itself.
\item Create the next element and loop over its {\ttfamily Nodes}. Some {\ttfamily Nodes} will already exist (because they have been created by the first element). For such {\ttfamily Nodes}, we merely add the pointer to the existing {\ttfamily Nodes} to the element\textquotesingle{}s {\ttfamily Node\+\_\+pt} vector. If a {\ttfamily Node} does not exist yet, we create it, as discussed above.
\item Keep going until all the elements and {\ttfamily Nodes} have been built.
\end{DoxyEnumerate}\hypertarget{index_Node_DOF_numbering}{}\doxysubsubsection{\texorpdfstring{Equation/\+DOF numbering at the mesh level}{Equation/DOF numbering at the mesh level}}\label{index_Node_DOF_numbering}
Now that the {\ttfamily Mesh} is assembled, we can set up the numbering scheme for the unknowns that are associated with the {\ttfamily Nodes} and with the elements\textquotesingle{} `internal {\ttfamily Data} '. (For problems that involve `external {\ttfamily Data} ', i.\+e. {\ttfamily Data} that is not associated with {\ttfamily Nodes} and elements, a further step is required; see section \doxysectlink{index_problems}{Problems}{2} below). As discussed above, whenever a {\ttfamily Data} object is created (either as part of a {\ttfamily Node} in the mesh or as `internal {\ttfamily Data} ' inside an element), its values are assumed to be free (i.\+e. not pinned). Before we can set up the equation numbering scheme, we must pin all those {\ttfamily Data} values that are prescribed by boundary conditions. This is generally done at the {\ttfamily Problem} level (see below) and for the subsequent discussion, we assume that this step has already taken place.

The equation numbering scheme must achieve two things\+:
\begin{DoxyItemize}
\item Every unknown value needs to be associated with a unique, non-\/negative global equation number.
\item All elements need to set up the lookup tables that establish the relation between local and global equation numbers.
\end{DoxyItemize}

These tasks are performed in two steps. The function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Mesh::assign\_global\_eqn\_numbers(...)\ }

\end{DoxyCode}
 whose argument is a vector of pointers to doubles, {\ttfamily dof\+\_\+pt}, assigns the (global) equation numbers for the element\textquotesingle{}s internal {\ttfamily Data} and for all {\ttfamily Data} associated with the {\ttfamily Mesh\textquotesingle{}s} {\ttfamily Nodes}. On return from this function, {\ttfamily dof\+\_\+pt}\mbox{[}i\mbox{]} points to the value of the i-\/th global degree of freedom. ~\newline
 The setup scheme (which is fully implemented in {\ttfamily oomph-\/lib}) works as follows\+:
\begin{DoxyEnumerate}
\item Loop over all {\ttfamily Nodes} in the {\ttfamily Mesh}.
\begin{DoxyItemize}
\item Loop over all values that are stored at that {\ttfamily Node}.
\begin{DoxyItemize}
\item If the value is free (i.\+e. not pinned), add the pointer to the value to the {\ttfamily dof\+\_\+pt} vector.
\end{DoxyItemize}
\end{DoxyItemize}
\item Loop over all elements.
\begin{DoxyItemize}
\item In every element, loop over the `internal {\ttfamily Data} '
\begin{DoxyItemize}
\item For every instance of `internal {\ttfamily Data} ', loop over its values.
\begin{DoxyItemize}
\item If the value is free (i.\+e. not pinned), add pointer to the value to the {\ttfamily dof\+\_\+pt} vector.
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyEnumerate}Once this has been done (for all {\ttfamily Meshes}, if there are multiple ones), the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Mesh::assign\_local\_eqn\_numbers(...)\ }

\end{DoxyCode}
 loops over all elements and executes their 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::assign\_local\_eqn\_numbers();\ }

\end{DoxyCode}
 member function to set up the elements\textquotesingle{} lookup table that translates between local and global equation numbers.\hypertarget{index_problems}{}\doxysubsection{\texorpdfstring{Problems}{Problems}}\label{index_problems}
Finally, we reach the highest level of the {\ttfamily oomph-\/lib} hierarchy, the {\ttfamily Problem} itself. The generic components of {\ttfamily Problem}, provided in the base class of that name, are\+:
\begin{DoxyItemize}
\item A pointer to the global {\ttfamily Mesh} (which can represent a number of submeshes, see below).
\item A pointer to the (discrete) {\ttfamily Time} (see section on \doxysectlink{index_timestepping}{Time-\/stepping}{1}).
\item A vector of pointers to (possibly multiple) {\ttfamily Time\+Steppers}.
\item A vector that holds pointers to any `global {\ttfamily Data} ', i.\+e. {\ttfamily Data} that is not associated with elements or {\ttfamily Nodes}.
\item A vector {\ttfamily Dof\+\_\+pt} that stores the pointers to all the unknown values (the degrees of freedom) in the problem.
\end{DoxyItemize}

{\bfseries{Multiple}} {\bfseries{Meshes}} 

The mesh generation process previously described was for meshes that contain only elements of a single type. The process could easily be generalised to meshes that contain multiple element types by providing multiple template parameters. ~\newline
 When solving a fluid-\/structure interaction (FSI) problem we could, therefore, create a single mesh that discretises both the fluid and the solid domains with appropriate elements. However, to facilitate code re-\/use it is desirable to keep meshes as simple as possible so that a mesh that was originally developed for a pure fluids problem can also be used in an FSI context. For this reason, the {\ttfamily Problem} class allows a problem to have multiple (sub-\/)meshes. Pointers to each sub-\/mesh must be stored in Problem\textquotesingle{}s {\ttfamily Sub\+\_\+mesh\+\_\+pt} vector by using the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::add\_sub\_mesh(Mesh*\ \textcolor{keyword}{const}\ \&mesh\_pt)\ }

\end{DoxyCode}
 However, many of the generic operations within {\ttfamily oomph-\/lib} (equation numbering, solving, output of solutions,...) involve looping over {\bfseries{all}} elements and {\ttfamily Nodes} in the problem. Therefore, if a {\ttfamily Problem} contains multiple (sub-\/)meshes, the sub-\/meshes must be combined into a single global {\ttfamily Mesh} whose {\ttfamily Element\+\_\+pt} and {\ttfamily Node\+\_\+pt} vectors provide ordered access to the elements and {\ttfamily Nodes} in {\bfseries{all}} submeshes. The function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::build\_global\_mesh()\ }

\end{DoxyCode}
 combines the sub-\/meshes into the global {\ttfamily Mesh} and must be called once all the sub-\/meshes have been constructed and "{}added"{} to the {\ttfamily Problem}.

{\bfseries{Important\+:}} Many operations (such as the shifting of history values in time-\/stepping) must be performed exactly once for each {\ttfamily Node} (or {\ttfamily Data}). Therefore, the vector of (pointers to) nodes in the global {\ttfamily Mesh} must not contain any duplicate entries. When copying (pointer to) {\ttfamily Nodes} from the submeshes into the global {\ttfamily Mesh}, the function {\ttfamily Problem\+::build\+\_\+global\+\_\+mesh()} ignores any {\ttfamily Nodes} that have already been copied from a previous submesh. \mbox{[}The {\ttfamily Mesh\+::self\+\_\+test()} function checks for duplicates in the {\ttfamily Mesh\+::\+Node\+\_\+pt} vector.\mbox{]}

{\bfseries{Convention\+:}} Recall that ({\ttfamily Boundary})Nodes are `told' about the number of the boundary they live on when the (sub-\/)meshes are constructed. In the context of multiple meshes, this raises the question if this number should continue to refer to the boundary number within the submesh or be updated to a boundary number within the global {\ttfamily Mesh}. We adopt the convention that boundary numbers remain those that were originally assigned when the submeshes were constructed.

{\bfseries{Multiple}} {\bfseries{meshes}} {\bfseries{and}} {\bfseries{adaptivity\+:}} Mesh adaptation is performed separately for each submesh. Following the adaptation of one or more submeshes (in the process of which various {\ttfamily Nodes/elements} will have been created/deleted), we must also update the global {\ttfamily Mesh}. This is done by calling 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::rebuild\_global\_mesh();\ }

\end{DoxyCode}
 and this function is executed automatically if the mesh adaptation/refinement is performed by 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::refine\_uniformly();\ }

\end{DoxyCode}
 or 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::adapt();\ }

\end{DoxyCode}
\hypertarget{index_prob_setup}{}\doxysubsubsection{\texorpdfstring{Problem Construction}{Problem Construction}}\label{index_prob_setup}
Here\textquotesingle{}s an overview of how {\ttfamily Problems} are set up and solved in {\ttfamily oomph-\/lib}. For simplicity, we illustrate the process for a problem with a single {\ttfamily Mesh} that contains elements of a single type.
\begin{DoxyEnumerate}
\item Define the element type and the {\ttfamily Time\+Stepper} (if the problem is time-\/dependent).
\item Build the {\ttfamily Mesh}, passing the element type as a template parameter and the {\ttfamily Time\+Stepper} as an argument to the Mesh constructor. (Typically {\ttfamily Mesh} constructors take a pointer to a {\ttfamily Time\+Stepper} as an argument since the {\ttfamily Time\+Stepper} needs to be passed to the element\textquotesingle{}s {\ttfamily Finite\+Element\+::construct\+\_\+node(...)} function. If the {\ttfamily Problem} has no time-\/dependence, we can pass a pointer to the static {\ttfamily Mesh\+::\+Steady} timestepper; many {\ttfamily Mesh} constructors use a pointer to this {\ttfamily Time\+Stepper} as the default argument).
\item Create the {\ttfamily Problem} \textquotesingle{}s global {\ttfamily Data} (if it has any).
\item Apply the essential boundary conditions by pinning the appropriate values; all other values remain free.
\item We now have a fully assembled {\ttfamily Mesh} and all elements know their constituent {\ttfamily Nodes}. However, because element constructors are not allowed to have any arguments, all but the simplest of elements will now have to be provided with additional information. For instance, we might need to set pointers to source functions, etc.
\item Assign the equation numbers to all unknowns in the problem. This is accomplished in a two-\/stage process by 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::assign\_eqn\_numbers(...)\ }

\end{DoxyCode}
 which
\begin{DoxyEnumerate}
\item Assigns the equation numbers for all global {\ttfamily Data} (if any)
\item Loops over the submeshes to perform the global equation numbering for all values associated with the {\ttfamily Meshes} (i.\+e. {\ttfamily Nodes} and elements), using ~\newline
 
\begin{DoxyCode}{0}
\DoxyCodeLine{Mesh::assign\_global\_eqn\_numbers(...)\ }

\end{DoxyCode}

\item Loops over the submeshes again to perform the local equation numbering for all elements associated with the meshes using ~\newline
 
\begin{DoxyCode}{0}
\DoxyCodeLine{Mesh::assign\_local\_eqn\_numbers(...)\ }

\end{DoxyCode}

\end{DoxyEnumerate}\mbox{[}Note that we have to assign the global equation numbers for all meshes before we assign any local equation numbers. This is because the external {\ttfamily Data} of elements in one mesh might be nodal {\ttfamily Data} in another mesh -- think of fluid-\/structure interaction problems\mbox{]}. At the end of this step, we will have filled in the {\ttfamily Problem\textquotesingle{}s} {\ttfamily Dof\+\_\+pt} vector which holds the pointers to the unknowns. \mbox{[}Note\+: The equation numbering scheme that is generated by the above procedure is unlikely to be optimal; it can (and in the interest of efficiency probably should) be changed afterwards by a problem-\/specific renumbering function.\mbox{]}
\item Before we can solve the {\ttfamily Problem} we will usually have to perform a few additional (problem-\/dependent) initialisation steps. For instance, we might want to assign initial and/or boundary conditions and provide initial guesses for the unknowns. For time-\/dependent problems, the {\ttfamily Problem} class provides a member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::assign\_initial\_values\_impulsive()\ }

\end{DoxyCode}
 which creates a past history for all time-\/dependent unknowns, assuming an impulsive start. If you want a `smooth' start from a given previous time-\/history, you will have to implement this yourself; in this case, consult the section \doxysectlink{index_timestepping}{Time-\/stepping}{1} which outlines the time-\/stepping procedures in {\ttfamily oomph-\/lib}.
\item Now we can solve the {\ttfamily Problem} by calling 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::newton\_solve()\ }

\end{DoxyCode}
 which employs the Newton-\/\+Raphson method to solve the nonlinear system of equations that is specified (formally) by the global Jacobian matrix and the global residual vectors. The function {\ttfamily Problem\+::newton\+\_\+solve()} employs a linear solver which may be specified by {\ttfamily Problem\+::linear\+\_\+solver\+\_\+pt()}. The default linear solver is \href{http://crd.lbl.gov/~xiaoye/SuperLU/}{\texttt{ Super\+LU }}. The Newton iteration proceeds until the maximum residual falls below {\ttfamily Problem\+::\+Newton\+\_\+solver\+\_\+tolerance}. \mbox{[}If the number of iterations exceeds {\ttfamily Problem\+::\+Max\+\_\+newton\+\_\+iterations} or if the the maximum residual exceeds {\ttfamily Problem\+::\+Max\+\_\+residuals}, the Newton solver throws an error\mbox{]}. When a solution has been found, all unknowns in the problem (which are accessible to the {\ttfamily Problem} via its {\ttfamily Dof\+\_\+pt} vector) are up-\/to-\/date. The {\ttfamily Problem} class also provides the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::unsteady\_newton\_solve(...)\ }

\end{DoxyCode}
 for time-\/dependent problems. Given the current values of the unknowns (at time {\ttfamily t} = {\ttfamily Problem\+::\+Time\+\_\+pt-\/\texorpdfstring{$>$}{>}time()} ) and their past histories, this function determines the solution at the advanced time {\ttfamily t+dt}. See section \doxysectlink{index_timestepping}{Time-\/stepping}{1} for more details on the conventions used in timestepping.
\end{DoxyEnumerate}The {\ttfamily Problem} class also has member functions which assemble the global residual vector and the global Jacobian matrix.

{\bfseries{Important\+:}} ~\newline
 ~\newline
 Since the unknowns in the {\ttfamily Problem} are accessed directly via pointers, their values are automatically updated during the Newton iteration. If the {\ttfamily Problem} has any auxiliary parameters that depend on the unknowns, their values need to be updated whenever an unknown might have changed (i.\+e. after every step of the Newton iteration). For such cases, the {\ttfamily Problem} class provides the four (empty) virtual functions 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_before\_newton\_step()\ }

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_after\_newton\_step()\ }

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_before\_newton\_solve()\ }

\end{DoxyCode}
 and 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_after\_newton\_solve()\ }

\end{DoxyCode}
 which are executed before/after every step of the Newton iteration and before/after the nonlinear solve itself, respectively. In addition, the virtual function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_before\_newton\_convergence\_check()\ }

\end{DoxyCode}
 is executed before the residuals are calculated in the Newton solver.

When you formulate your own {\ttfamily Problem}, you will have to decide what (if anything) should live in these functions. Typical examples of actions that should be taken before a solve are the update of any boundary conditions. If the boundary conditions depend upon variables in the problem, they must be updated before every Newton step and should therefore be placed in {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+step()}. Actions that take place after a Newton step or solve would include things like updating the nodal positions, writing output or any other post-\/processing/solution monitoring. For example, if the solution after each Newton step were to be documented this could be accomplished by calling a suitable output function in the {\ttfamily Problem\+::actions\+\_\+after\+\_\+newton\+\_\+step()} function.

In many cases, only the {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} function is required. On entry to the Newton solver, the initial residuals are computed and checked, so the function is executed {\bfseries{before}} any Newton steps are taken. After each Newton step, the residuals vector is recomputed and checked, so the function is also called after every Newton step (or before the next Newton step). Nonetheless, we provide all five functions for the greatest possible flexibility.\hypertarget{index_timestepping}{}\doxysection{\texorpdfstring{Time-\/stepping}{Time-stepping}}\label{index_timestepping}
\hypertarget{index_time}{}\doxysubsection{\texorpdfstring{Time}{Time}}\label{index_time}
Time-\/derivatives are generally evaluated by finite difference expressions, e.\+g. by BDF schemes. Hence, within the code, functions are only ever evaluated at discrete time levels. The class {\ttfamily Time} contains (a pointer to) the `current' value of the continuous time and a vector of current and previous timesteps so that the value of the continuous time at any previous timestep can easily be reconstructed. This is useful/necessary if there are any explicitly time-\/dependent parameters in the problem. The general convention within all timestepping procedures is to associate the values at the `present' time (i.\+e. the time for which a solution is sought) with time level `0', those at the previous time level (where the solution is already known) with time levels `1', `2' etc. The function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Time::time(\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}})\ }

\end{DoxyCode}
 therefore returns the `current' value of the continuous time if t=0, the continuous time before the previous timestep if t=1, etc.\hypertarget{index_basic_timestepping}{}\doxysubsection{\texorpdfstring{Basic Time-\/stepping}{Basic Time-stepping}}\label{index_basic_timestepping}
The base class {\ttfamily Time\+Stepper} provides the basic functionality required to evaluate time derivatives, and to keep track of the time histories of the unknowns. Primarily, a {\ttfamily Time\+Stepper} stores the coefficients (weights) that allow the evaluation of time-\/derivatives (up to a certain order) in terms of the history values stored in {\ttfamily Data}. Synchronisation of multiple {\ttfamily Time\+Stepper} s is ensured by providing them with pointers to the {\ttfamily Problem\textquotesingle{}s} (single) {\ttfamily Time} object.

Here\textquotesingle{}s an illustration of the time-\/stepping procedure for an implicit scheme.
\begin{DoxyItemize}
\item {\bfseries{Stage}} {\bfseries{1}}\+: {\bfseries{Initialise}} 
\begin{DoxyEnumerate}
\item Add a {\ttfamily Time\+Stepper} to the {\ttfamily Problem}. If a {\ttfamily Time} object has not yet been created, the {\ttfamily Problem\+::add\+\_\+time\+\_\+stepper\+\_\+pt(...)} function creates one with the necessary storage. If the {\ttfamily Time} object already exists and the new {\ttfamily Time\+Stepper} requires more storage than presently exists, the storage in the {\ttfamily Time} object is resized. The function also passes a pointer to the global {\ttfamily Time} object to each {\ttfamily Time\+Stepper}.
\item Set up the {\ttfamily Problem} as discussed in section \doxysectlink{index_problems}{Problems}{2}
\item Initialise the history of the previous timesteps by calling {\ttfamily Problem\+::initialise\+\_\+dt(...)}.
\item Provide initial values for all unknowns. {\bfseries{Note\+:}} In many cases, the initial values may be the result of a steady calculation. The function {\ttfamily Problem\+::steady\+\_\+newton\+\_\+solve()} should be used to calculate these values. The function sets the weights of the time-\/stepping scheme such that the time derivatives are zero and a steady problem is solved, even when the {\ttfamily Problem\textquotesingle{}s} {\ttfamily Time\+Stepper} is not the dummy timestepper, {\ttfamily Steady}.
\item Provide time histories for the values (pinned {\itshape and} free!), either by imposing an impulsive start or by setting history values according to some given time-\/dependence\+: When generating the initial time history for the values from a given (`exact') solution, assign the current values and the history values so that the solution is represented correctly at the initial time, {\ttfamily Time\+::time()}. At the end of this stage, {\ttfamily Data\+::value(...)} must return the current values and ~\newline
 {\ttfamily Time\+Stepper\+::time\+\_\+derivative(...)} must return their time-\/derivatives at the initial time.
\end{DoxyEnumerate}
\item {\bfseries{Stage}} {\bfseries{2}}\+: {\bfseries{Perform}} {\bfseries{one}} {\bfseries{timestep\+:}} ~\newline
 A timestep is performed by using the 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::unsteady\_newton\_solve(...)\ }

\end{DoxyCode}
 function, which implements the following steps\+:
\begin{DoxyEnumerate}
\item Shift the time values back using 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::shift\_time\_values()\ }

\end{DoxyCode}
 (For BDF timesteppers, this simply moves the history values back by one level; see below for a detailed discussion of how the shifting of the history values is performed).
\item Solve the {\ttfamily Problem} at the advanced time by performing the following steps
\begin{DoxyEnumerate}
\item Choose a timestep {\ttfamily dt}.
\item Advance the {\ttfamily Problem\textquotesingle{}s} global time and (re-\/)calculate the weights for the {\ttfamily Time\+Stepper(s)}.
\item Update any time-\/dependent boundary conditions etc., usually via 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_before\_newton\_solve()\ }

\end{DoxyCode}
 or 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_before\_implicit\_timestep()}

\end{DoxyCode}

\item Call the nonlinear solver to find the unknowns at the current (advanced) time.
\end{DoxyEnumerate}
\end{DoxyEnumerate}
\item {\bfseries{Stage\+:}} {\bfseries{3}} {\bfseries{Document}} {\bfseries{the}} {\bfseries{solution}} ~\newline
 We now have a completely consistent representation of the current and history values of the system\textquotesingle{}s unknowns for the current value of {\ttfamily Time\+::time()}. This is an excellent moment to dump the solutions to disk or do any other post-\/processing. These steps may be included in 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_after\_newton\_solve()\ }

\end{DoxyCode}
 or 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_after\_implicit\_timestep()\ }

\end{DoxyCode}

\item Now return to {\bfseries{Stage}} {\bfseries{2}} for the next timestep.
\end{DoxyItemize}

It is important to understand how the shifting of the timesteps (in preparation for the next timestep) is performed because certain default operations will not be appropriate for all {\ttfamily Elements/} {\ttfamily Problems}. Recall that in time-\/dependent problems, {\ttfamily Data\+::value\+\_\+pt(i)} points to the current (and, as yet, unknown) {\ttfamily Data} values, while {\ttfamily Data\+::value\+\_\+pt(t,i)} for t\texorpdfstring{$>$}{>}0 points to the history values that the {\ttfamily Time\+Stepper} uses to work out time-\/derivatives. When we move to the next timestep, the history values need to be adjusted in the manner that is appropriate for the timestepping scheme. For instance, for BDF schemes, all values need to be pushed back by one time level. This operation is performed by the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{TimeStepper::shift\_time\_values(...)\ }

\end{DoxyCode}
 In the case of {\ttfamily Nodes}, the shifting of values associated with the nodal positions is performed by the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{TimeStepper::shift\_time\_positions(...)\ }

\end{DoxyCode}
 To ensure that all {\ttfamily Data} in the {\ttfamily Problem} is shifted once (and only once!) {\ttfamily Problem\+::shift\+\_\+time\+\_\+values()} performs the following operations\+:
\begin{DoxyEnumerate}
\item Shift the values of the time history stored in the {\ttfamily Time} object.
\item Shift the time values in the global {\ttfamily Mesh}. This involves the following steps\+:
\begin{DoxyEnumerate}
\item Loop over all elements and call {\ttfamily Time\+Stepper\+::shift\+\_\+time\+\_\+values(...)} for the {\ttfamily Time\+Stepper} corresponding to each internal {\ttfamily Data} value. This leads to the slightly ugly construction 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal\_pt(\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})-\/>time\_stepper\_pt()-\/>shift\_time\_values(internal\_pt(\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}}))}

\end{DoxyCode}
 but there appears to be no way to avoid this.
\item Loop over all {\ttfamily Nodes} in the mesh and
\begin{DoxyEnumerate}
\item call {\ttfamily Time\+Stepper\+::shift\+\_\+time\+\_\+values(...)} for each {\ttfamily Node} \textquotesingle{}s {\ttfamily Time\+Stepper}.
\item call {\ttfamily Time\+Stepper\+::shift\+\_\+time\+\_\+positions(...)} for each {\ttfamily Node\textquotesingle{}s} positional {\ttfamily Time\+Stepper}.
\end{DoxyEnumerate}
\end{DoxyEnumerate}
\item Shift the time values for all global {\ttfamily Data}.
\end{DoxyEnumerate}\hypertarget{index_adaptive_time_stepping}{}\doxysubsection{\texorpdfstring{Adaptive time-\/stepping}{Adaptive time-stepping}}\label{index_adaptive_time_stepping}
In adaptive time-\/stepping, the size of the timestep is adjusted automatically, so that the global (temporal) error estimate, computed by the Problem member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::global\_error\_norm()\ }

\end{DoxyCode}
 remains below a preset threshold. However, the function {\ttfamily Problem\+::global\+\_\+error\+\_\+norm()} must be implemented for each specific problem. The error norm is usually constructed from the (estimated) errors of individual {\ttfamily Data} values. Estimates for these quantities are given by the differences between the actual value and a predicted value, as determined by 
\begin{DoxyCode}{0}
\DoxyCodeLine{TimeStepper::error\_in\_value(...)\ }

\end{DoxyCode}
 and the errors in positional {\ttfamily Data} values, found by 
\begin{DoxyCode}{0}
\DoxyCodeLine{TimeStepper::error\_in\_position(...)\ }

\end{DoxyCode}


In moving mesh problems, a suitable norm is the root-\/mean-\/square of the errors in all positional coordinates at every {\ttfamily Node}. In fluid problems, the error is usually based on the velocity components, etc.

Once a suitable norm has been chosen, a single adaptive timestep is taken by the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::adaptive\_unsteady\_newton\_solve(...)\ }

\end{DoxyCode}
 This function returns a double precision number that is the value of {\ttfamily dt} that should be taken at the next timestep. A typical calling loop is thus 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Initial\ suggestion\ for\ timestep}}
\DoxyCodeLine{\textcolor{keywordtype}{double}\ dt=0.001;}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ \mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}}=0;\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}}<100;\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}}++)}
\DoxyCodeLine{\ \{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Try\ to\ take\ a\ timestep\ dt\ forward;\ if\ the\ computed}}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ solution\ is\ not\ sufficiently\ accurate,\ reduce\ the}}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ the\ timestep\ and\ repeat...\ Return\ the\ suggestion\ for}}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ next\ timestep}}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{double}\ dt\_next\ =\ adaptive\_unsteady\_newton\_solve(dt,...);}
\DoxyCodeLine{\ \ dt\ =\ dt\_next;}
\DoxyCodeLine{\ \}}

\end{DoxyCode}


Within the {\ttfamily Problem\+::adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve}(..) function, if the global error norm is too large, the step is rejected, the timestep reduced and the step repeated. If the timestep falls below a preset tolerance {\ttfamily Problem\+::\+Minimum\+\_\+dt} (which has the default value {\ttfamily 1.\+0e-\/12}), the program will terminate. It is also possible to set a maximum timestep by over-\/writing the (large) default for {\ttfamily Problem\+::\+Maximum\+\_\+dt} (initialised to {\ttfamily 1.\+0e12}) with a smaller value.\hypertarget{index_restarts}{}\doxysubsection{\texorpdfstring{Restarts}{Restarts}}\label{index_restarts}
Time-\/dependent simulations can consume a lot of computer time, and it is essential to be able to restart simulations rather than having to re-\/do them from scratch if a computer crashes during the code execution. For this purpose the {\ttfamily Problem} class provides the two member functions 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::dump(...)\ }

\end{DoxyCode}
 and 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::read(...)\ }

\end{DoxyCode}
 which write/read the generic {\ttfamily Problem} components (i.\+e. the {\ttfamily Data} values and history values, the history of previous timestep increments, etc) to/from disk. These generic functions are typically called from within a specific {\ttfamily Problem\textquotesingle{}s} own dump/read functions which also deal with any additional, problem-\/specific data that has to be recorded/reset to allow a proper restart.\hypertarget{index_mesh_refinement}{}\doxysection{\texorpdfstring{Problem/\+Mesh adaptation}{Problem/Mesh adaptation}}\label{index_mesh_refinement}
\hypertarget{index_RefineableProblems}{}\doxysubsection{\texorpdfstring{Adaptation at the Problem level}{Adaptation at the Problem level}}\label{index_RefineableProblems}
The ability to adaptively refine/unrefine the {\ttfamily Problem\textquotesingle{}s} mesh(es) in regions in which the solution undergoes rapid/slow variations is of crucial importance for the overall efficiency of the solution process. Mesh-\/adaptation involves the following steps\+:
\begin{DoxyEnumerate}
\item Compute an estimate of the error in the computed solution for all elements in the mesh.
\item Label the elements whose error estimate is the above the maximum (or below the minimum) permissible error.
\item Perform the actual mesh adaptation\+: elements whose error is too large are subdivided into `son' elements; elements whose error is too small are merged with their `siblings', provided the `siblings' are also scheduled for de-\/refinement. Usually, certain bounds are imposed on the maximum and minimum refinement levels to prevent excessive mesh refinement (e.\+g. near singularities) or de-\/refinement. (While the use of very large elements might be permissible in regions in which the solution varies little, such elements will provide a poor representation of the domain shape and thus lead to unsatisfactory post-\/processing.)
\item Represent the previously computed solution on the newly created {\ttfamily Nodes} / elements.
\item Once all the {\ttfamily Problem\textquotesingle{}s} submeshes have been adapted, update the {\ttfamily Problem} itself by updating the global {\ttfamily Mesh}, re-\/generating the equation numbering scheme, etc.
\item Solve the adapted {\ttfamily Problem}.
\end{DoxyEnumerate}

The {\ttfamily Problem} class provides several functions that perform these tasks completely automatically. For instance, the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::refine\_uniformly()\ }

\end{DoxyCode}
 performs one uniform mesh refinement step for all (refineable) submeshes in the {\ttfamily Problem}. Similarly, the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::adapt(...)\ }

\end{DoxyCode}
 performs one mesh adaptation step. In both functions, mesh adaptation is followed by the update of the global {\ttfamily Mesh} and the re-\/assignment of the equation numbers so that, on return from these functions, the {\ttfamily Problem} can immediately be solved again.

The {\ttfamily Problem} class also provides overloaded versions of the steady and unsteady Newton solvers 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::newton\_solve(...)\ }

\end{DoxyCode}
 and 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::unsteady\_newton\_solve(...)\ }

\end{DoxyCode}
 that automatically perform mesh adaptations until the computed solution satisfies the specified error bounds on all submeshes (or until a max. number of adaptations has been performed). The (empty) virtual member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::set\_initial\_condition()\ }

\end{DoxyCode}
 establishes the interface to the function that sets all {\ttfamily Data} to their initial conditions. This function must be overloaded if nontrivial initial conditions are to be applied. (If mesh adaptations are performed while the first timestep is computed, the initial conditions on the adapted mesh can usually be represented more accurately by re-\/assigning them, rather than by interpolation from the coarse initial mesh).\hypertarget{index_RefineableMeshes}{}\doxysubsection{\texorpdfstring{Adaptation at the Mesh level}{Adaptation at the Mesh level}}\label{index_RefineableMeshes}
The ability to perform the adaptation at the {\ttfamily Problem} level relies on the availability of standardised interfaces to functions that handle the adaptation on the {\ttfamily Mesh} level. These interfaces are provided in the class {\ttfamily Refineable\+Mesh\+Base}. {\ttfamily Refineable\+Mesh\+Base} is derived from {\ttfamily Mesh} and stores a pointer to a spatial error estimator, as well as double precision numbers representing the target error levels for the adaptation. The member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{RefineableMeshBase::refine\_uniformly(...)\ }

\end{DoxyCode}
 performs one uniform mesh refinement step. Similarly, 
\begin{DoxyCode}{0}
\DoxyCodeLine{RefineableMeshBase::adapt(...)\ }

\end{DoxyCode}
 adapts the mesh according to the specified error bounds, using the mesh\textquotesingle{}s spatial error estimator to compute the elemental errors.

The details of the mesh adaptation process depend on the mesh topology; currently the virtual functions in {\ttfamily Refineable\+Mesh\+Base} are implemented in a general form for quad and brick elements. We shall discuss the mesh adaptation process in detail for meshes of a particular type\+: The {\ttfamily Refineable\+Quad\+Mesh} class implements the mesh adaptation procedures for two-\/dimensional, block-\/structured meshes which consist of the refineable variant of 2D {\ttfamily QElements}. The description provides a template for the development of mesh refinement procedures for meshes with different element topologies (e.\+g. triangular elements, or 3D {\ttfamily QElements}).\hypertarget{index_RefineableQuadMesh_section}{}\doxysubsection{\texorpdfstring{Mesh adaptation for 2\+D quadrilateral meshes}{Mesh adaptation for 2D quadrilateral meshes}}\label{index_RefineableQuadMesh_section}
\hypertarget{index_RefineableQElementsInmeshes}{}\doxysubsubsection{\texorpdfstring{Refineable QElements}{Refineable QElements}}\label{index_RefineableQElementsInmeshes}
The abstract base class {\ttfamily Refineable\+QElement$<$2$>$} `upgrades' existing elements of (geometric) type {\ttfamily QElement$<$2,\+NNODE\+\_\+1\+D$>$} to versions that are suitable for use in adaptive computations. \textquotesingle{}Upgrading\textquotesingle{} is achieved via inheritance so that, e.\+g., refineable Poisson elements are defined as\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keywordtype}{unsigned}\ DIM,\ \textcolor{keywordtype}{unsigned}\ NNODE\_1D>}
\DoxyCodeLine{\textcolor{keyword}{class\ }RefineableQPoissonElement\ :\ \textcolor{keyword}{public}\ QPoissonElement<DIM,NNODE\_1D>,}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{virtual}\ RefineablePoissonEquations<DIM>,}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{virtual}\ RefineableQElement<DIM>}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ [...]}
\DoxyCodeLine{\}}

\end{DoxyCode}
 The abstract base class {\ttfamily Refineable\+QElement$<$2$>$} defines virtual interfaces for those {\ttfamily Finite\+Element} member functions that might have to be overloaded in the refineable version. In most cases, these member functions must be re-\/implemented to deal with the possible presence of hanging nodes, see below.\hypertarget{index_QuadTreeInMeshes}{}\doxysubsubsection{\texorpdfstring{Quad\+Tree procedures for mesh refinement}{QuadTree procedures for mesh refinement}}\label{index_QuadTreeInMeshes}
Many of the mesh adaptation procedures for meshes of type {\ttfamily Refineable\+Quad\+Mesh} use quadtree representations of the mesh. The quadtree navigation and search algorithms are based on those described in H. Samet\textquotesingle{}s "{}\+The   design and analysis of spatial data structures"{} (Addison-\/\+Wesley, 1990). \mbox{[}Note\+: Unfortunately, in the usual tree terminology, quadtrees are made of {\itshape "{}nodes"{}} which are, of course, completely unrelated to the {\ttfamily Nodes} in the finite element mesh! The context and -- within this document -- the different typefaces should make it clear which is which...\mbox{]} It is important to understand that each {\ttfamily Refineable\+QElement$<$2$>$} has an associated {\ttfamily Quad\+Tree} and each {\ttfamily Quad\+Tree} has an associated {\ttfamily Refineable\+QElement$<$2$>$}. This two-\/way "{}has a"{} relationship permits a "{}clean"{} implementation of the (generic) {\ttfamily Quad\+Tree} algorithms, although it does incur the cost of two additional pointers.

To illustrate the way in which {\ttfamily Refineable\+Quad\+Meshes} are represented by {\ttfamily Quad\+Trees}, the figure below shows a simple finite element mesh together with its quadtree-\/representation. There are two different types of quadtree classes\+: {\ttfamily Quad\+Trees} and {\ttfamily Quad\+Tree\+Roots}, which inherit from {\ttfamily Quad\+Trees}. The overall structure of the quadtree is defined by pointers between its {\itshape "{}nodes"{}}. Each {\itshape "{}node"{}} (an object of type {\ttfamily Quad\+Tree}, shown in pink) in the quadtree has a pointer to its {\itshape "{}father"{}} (if this pointer is NULL, the {\itshape "{}node"{}} is the {\itshape "{}root node"{}}) and a vector of pointers to its four {\itshape "{}sons"{}} (if the vector is empty, the "{}node"{} is a {\itshape "{}leaf   \textbackslash{}e node"{}}). This data structure is sufficient to navigate the quadtree (e.\+g. identify the quadtree\textquotesingle{}s {\itshape "{}leaf nodes"{}}, determine a {\itshape "{}node"{}\textquotesingle{}s} neighbours, etc.) Each {\ttfamily Quad\+Tree} also stores a pointer to an associated {\itshape "{}object"{}} of type {\ttfamily Refineable\+Element} (shown in light blue). The finite element mesh that is used in the computations only comprises those {\ttfamily Refineable\+Elements} that are associated with {\itshape "{}leaf nodes"{}}. We refer to these elements as "{}active elements"{}. In the diagram below, the active elements are identified by thick blue boundaries and the blue element numbers correspond to those in the mesh.

\hypertarget{index_RefineableQuadMesh_setup_section}{}\doxysubsubsection{\texorpdfstring{Mesh generation}{Mesh generation}}\label{index_RefineableQuadMesh_setup_section}
Any {\ttfamily Mesh} that is designed to contain 2D {\ttfamily QElement} s forms a suitable basis for a {\ttfamily Refineable\+Quad\+Mesh} mesh and the initial stages of the mesh generation process can be performed exactly as described in section \doxysectlink{index_meshes}{Meshes}{2} above. Typically, the constructor for a {\ttfamily Refineable\+Quad\+Mesh} will produce a relatively coarse background mesh (sometimes referred to as a "{}root mesh"{}) which can subsequently be refined as required. As discussed before, the type of element will typically be passed as a template parameter and it is assumed that in any concrete instantiation of the {\ttfamily Refineable\+Quad\+Mesh} class, the element is derived from the class {\ttfamily Refineable\+QElement$<$2$>$}.

Following the generic setup of the mesh (creating elements, {\ttfamily Nodes}, etc), the constructor of the {\ttfamily Refineable\+Quad\+Mesh} must associate each {\ttfamily Refineable\+QElement$<$2$>$} in the mesh with a {\ttfamily Quad\+Tree\+Root} and vice versa. The association between {\ttfamily Refineable\+QElement$<$2$>$s} and {\ttfamily Quad\+Tree\+Roots} is established by the {\ttfamily Quad\+Tree\+Root} constructor which takes the pointer to the {\ttfamily Refineable\+QElement$<$2$>$} as its argument. The different {\ttfamily Quad\+Trees} must then be combined into a {\ttfamily Quad\+Tree\+Forest}, whose constructor establishes each {\ttfamily Quad\+Tree} \textquotesingle{}s N/\+S/\+W/E neighbours and their relative orientation. Here is an illustration\+:




\begin{DoxyImage}
\includegraphics[width=\textwidth,height=\textheight/2,keepaspectratio=true]{QuarterCircleMesh}
\doxyfigcaption{Mesh consisting of three Refineable\+QElements\texorpdfstring{$<$}{<}2\texorpdfstring{$>$}{>}/ Quad\+Trees. Element/\+Quad\+Tree numbers are blue, and the Quad\+Tree\textquotesingle{}s \`{}northern\textquotesingle{} direction is indicated by the red arrows. The Quad\+Trees are combined into a Quad\+Tree\+Forest, which establishes their adjacency (Quad\+Tree 2 is Quad\+Tree 0\textquotesingle{}s northern neighbour etc.) and their relative orientation (Quad\+Tree 1\textquotesingle{}s North coincides with Quad\+Tree 2\textquotesingle{}s West, etc.) Note that the Refineable\+QElement\texorpdfstring{$<$}{<}2\texorpdfstring{$>$}{>}\textquotesingle{}s local coordinates s\+\_\+0 and s\+\_\+1 are aligned with the Quad\+Tree \textquotesingle{}s W-\/-\/\texorpdfstring{$>$}{>}E and S-\/-\/\texorpdfstring{$>$}{>}N directions, respectively.}
\end{DoxyImage}


The virtual member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{RefineableQuadMesh::setup\_quadtree\_forest()\ }

\end{DoxyCode}
 creates the {\ttfamily Quad\+Tree\+Forest} automatically and should be called at the end of the {\ttfamily Refineable\+Quad\+Mesh\textquotesingle{}s} constructor. Finally, the mesh must be given a pointer to a spatial error estimator.\hypertarget{index_Hanging_Nodes}{}\doxysubsubsection{\texorpdfstring{Hanging Nodes}{Hanging Nodes}}\label{index_Hanging_Nodes}
Before explaining the details of the mesh adaptation process we discuss how hanging nodes are treated in {\ttfamily oomph-\/lib}. The figure below shows a {\ttfamily Refineable\+Quad\+Mesh} that originally consisted of four 4-\/node {\ttfamily Refineable\+QElements} and nine nodes (nodes 0 to 8). The mesh was adapted twice\+: During the first adaptation, the top right element was subdivided into four son elements and five new {\ttfamily Nodes} (nodes 9 to 13) were created. Then one of the newly created elements was subdivided again and in the process {\ttfamily Nodes} 14 to 18 were created. ~\newline
 On this mesh, inter-\/element continuity is not ensured unless the hanging {\ttfamily Nodes} (=internal {\ttfamily Nodes} not shared by an adjacent element -- here {\ttfamily Nodes} 9, 10, 14, 15, 17 and 18) are suitably constrained. For instance, the nodal values at {\ttfamily Node} 10 must be linear combinations of the values at nodes 4 and 7 if the solution is to remain continuous across the eastern edge of element 2. We refer to nodes 4 and 7 as the "{}master nodes"{} of {\ttfamily Node} 
\begin{DoxyEnumerate}
\item ~\newline
 The hanging node status of the {\ttfamily Nodes} can be determined by the following procedure\+:
\end{DoxyEnumerate}
\begin{DoxyItemize}
\item Loop over all elements in the mesh. For each element {\bfseries{E}} do\+:
\begin{DoxyItemize}
\item Loop over the edges of element. For each edge {\bfseries{e\+\_\+E}} do\+:
\begin{DoxyItemize}
\item Identify the neighbouring element, {\bfseries{N}}, that faces edge {\bfseries{e\+\_\+E}}.
\item If the neighbouring element, {\bfseries{N}}, has the same size as element {\bfseries{E}} then the hanging node status of the {\ttfamily Nodes} that are located on edge {\bfseries{e\+\_\+E}} does not need to be changed.
\item If the neighbouring element, {\bfseries{N}}, is larger than {\bfseries{E}}, determine the edge {\bfseries{e\+\_\+N}} of element {\bfseries{N}} that faces the edge {\bfseries{e\+\_\+E}}. Make all {\ttfamily Nodes} on edge {\bfseries{e\+\_\+N}} master nodes for all hanging {\ttfamily Nodes} on edge {\bfseries{e\+\_\+E}}.
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}If the difference in the refinement levels of two adjacent elements is greater than one, some of the master nodes determined by the above procedure will themselves be hanging nodes and these now need to be eliminated recursively. For instance, {\ttfamily Nodes} 9 and 11 are initially classified as master nodes for {\ttfamily Node} 17. However, {\ttfamily Node} 9 is a hanging node which depends on {\ttfamily Nodes} 4 and 5. Hence, the ultimate master nodes for {\ttfamily Node} 17 are {\ttfamily Nodes} 4, 5 and 11.




\begin{DoxyImage}
\includegraphics[width=\textwidth,height=\textheight/2,keepaspectratio=true]{HangingNodes}
\doxyfigcaption{Illustration of hanging nodes}
\end{DoxyImage}


The presence of hanging nodes must not affect the node-\/based representations for the unknown function(s) and for the geometric mapping within the elements. Hence, within any element $ E $, a scalar function $ u $ should continue to be representable as \[ u = \sum_{j} U_{J(j,E)} \psi_j(s) \mbox{\hspace{5cm} (1)} \] while the mapping between local and global coordinates should retain the form  \[   {\bf x} = \sum_{j} {\bf X}_{J(j,E)} \psi_j(s),
        \mbox{\hspace{5cm} (2)} \] where the sums are taken over the nodes $ j $ of the element. $ J(j,E) $ represents the global node number of local node $ j $ in element $ E $ and $ U_J $ and $ {\bf X}_J $ represent the function value at and the position vector to global node $ J $, respectively. To ensure inter-\/element continuity of $ u $ and $ {\bf x} $, we constrain the nodal values and positions of the hanging nodes so that for every hanging node $ J $ we have \[ U_J = \sum_{K} U_{K} \omega_{JK}  \] and \[ {\bf X}_J = \sum_{K} {\bf X}_{K} \omega_{JK} \] where the sum is taken over the hanging node\textquotesingle{}s master nodes $ K $ and the $ \omega_{JK} $ are suitable weights. It is precisely this representation of the nodal positions and values that is implemented in {\ttfamily Node\+::value(...)} and {\ttfamily Node\+::position()}. \mbox{[}Note that different nodal values can have different hanging node constraints; e.\+g. in Taylor-\/\+Hood elements where the pressure and velocities are interpolated by linear and quadratic basis functions.\mbox{]}

For simply hanging nodes (e.\+g. {\ttfamily Nodes} 9, 10, 14 and 15 in the above sketch) the weights $ \omega_{JK} $ are determined as follows\+:
\begin{DoxyItemize}
\item Find the neighbour element {\bfseries{N}} that faces the hanging node $ J $.
\item Let $ s_J $ be the local coordinate of hanging node $ J $ in the neighbour element {\bfseries{N}}.
\item For each master node $ K $ in {\bfseries{N}}, the weight $  \omega_{JK} $ is then given by the shape function associated with master node $ K $, evaluated at $ s_J $, evaluated in element {\bfseries{N}}. \[ \omega_{JK} = \psi_K(s_J) \]
\end{DoxyItemize}For multiply hanging nodes ({\ttfamily Nodes} 17 and 18 in the above sketch), the weights of the ultimate master nodes are determined recursively, e.\+g. $ \omega_{17\ 4} = \omega_{17\ 9}  
 \times \omega_{9 \ 4}. $~\newline


For {\ttfamily Refineable\+Quad\+Mesh} meshes, the above procedures are fully implemented. Executing the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{RefineableQElement<2>::setup\_hanging\_nodes()\ }

\end{DoxyCode}
 for each element in the mesh establishes which of the elements\textquotesingle{} {\ttfamily Nodes} are hanging and determines their primary master nodes and weights. Furthermore, it pins the values at the hanging nodes -- because the values are constrained, they cannot be unknowns in the problem. When this function has been executed for all elements in the mesh, the recursive elimination of hanging master nodes is performed by calling 
\begin{DoxyCode}{0}
\DoxyCodeLine{RefineableMesh::complete\_hanging\_nodes();\ }

\end{DoxyCode}


As mentioned above, the possible occurrence of hanging nodes needs to be reflected in the element\textquotesingle{}s equation numbering scheme and in the functions that compute the elemental Jacobian matrix because the element residuals now potentially depend on {\ttfamily Nodes} outside the element. Therefore, {\ttfamily Refineable\+QElement$<$2$>$s} must re-\/implement various {\ttfamily Finite\+Element} member functions, e.\+g., by re-\/implementing the virtual functions 
\begin{DoxyCode}{0}
\DoxyCodeLine{RefineableQElement<2>::get\_residuals()\ }

\end{DoxyCode}
 and 
\begin{DoxyCode}{0}
\DoxyCodeLine{RefineableQElement<2>::get\_jacobian(...)\ }

\end{DoxyCode}
 and various others, as specified in the {\ttfamily Refineable\+QElement$<$2$>$} class.

In practice, we again distinguish between the "{}geometry"{} and the "{}maths"{} by writing a general {\ttfamily Refineable\+Poisson\+Equations$<$\+DIM$>$} class that inherits from {\ttfamily Poisson\+Equations$<$\+DIM$>$} and re-\/implements the appropriate member functions.\hypertarget{index_RefineableQuadMesh_adaption_section}{}\doxysubsubsection{\texorpdfstring{Mesh adaptation}{Mesh adaptation}}\label{index_RefineableQuadMesh_adaption_section}
We can now discuss the details of the mesh adaptation process for {\ttfamily Refineable\+Quad\+Mesh} meshes, although the general procedure is, in fact, generic\+: Once a solution has been computed, {\ttfamily Problem\+::adapt()} loops over all refineable submeshes, and uses their error estimator functions to compute the vector of elemental errors. The vector of errors is then passed to the submeshes\textquotesingle{} 
\begin{DoxyCode}{0}
\DoxyCodeLine{RefineableMesh::adapt(...)\ }

\end{DoxyCode}
 function which performs the actual mesh adaptation and entails the following steps\+:
\begin{DoxyItemize}
\item Select all elements whose error exceeds the target maximum error for refinement, provided the elements have not already been refined to the maximum refinement level.
\item Select all elements whose error is smaller than the target minimum error for unrefinement, provided
\begin{DoxyItemize}
\item their siblings (which can be identified via (Quad)Tree procedures) can also be unrefined
\end{DoxyItemize}and
\begin{DoxyItemize}
\item the unrefinement would not coarsen the mesh beyond the minimum refinement level.
\end{DoxyItemize}
\item Now loop over all elements in the mesh (traversing through the leaves of the {\ttfamily Quad\+Tree\+Forest}) and split those elements that are targeted for refinement. This involves the following steps\+:
\begin{DoxyItemize}
\item Create new {\ttfamily Refineable\+Elements} of the same type as the father element.
\item Create new {\ttfamily Quad\+Trees} --- as in the original setup, we pass the pointers to the newly created {\ttfamily Refineable\+Elements} to the {\ttfamily Quad\+Tree} constructors to establish the association between each {\ttfamily Quad\+Tree} and its {\ttfamily Refineable\+Element}.
\item Declare the newly created {\ttfamily Quad\+Trees} to be the sons of the current {\ttfamily Quad\+Tree}. This transforms the current {\ttfamily Quad\+Tree} into a {\itshape "{}non-\/leaf node"{}} in the {\ttfamily Quad\+Tree\+Forest}. Note that the {\ttfamily Refineable\+Element} is not deleted when it is split -- it retains its full functionality (e.\+g. its pointers to its {\ttfamily Nodes}, etc). This ensures that the element is fully functional should its sons become scheduled for unrefinement at a later stage. Note that in cases when the {\ttfamily Nodes} are not uniformly-\/spaced, certain {\ttfamily Nodes} in the father will not be used by the sons. These {\ttfamily Nodes} will be marked as obsolete and deleted from the {\ttfamily Mesh}. The pointers to these {\ttfamily Nodes} must be set to NULL in the father element, but this cannot be done until after the hanging node procedures have been completed, see below.
\end{DoxyItemize}
\item The newly-\/created elements now exist (and are accessible via the leaves of the {\ttfamily Quad\+Tree\+Forest}) but they have not been `built' i.\+e. they do not have pointers to {\ttfamily Nodes} etc. We now loop over the {\itshape "{}leaf nodes"{}} in the {\ttfamily Quad\+Tree\+Forest} and execute the virtual function 
\begin{DoxyCode}{0}
\DoxyCodeLine{RefineableElement::build()\ }

\end{DoxyCode}
 for all newly created elements. In the specific case of a 2D {\ttfamily Quad\+Mesh}, the {\ttfamily Refineable\+QElement$<$2$>$\+::build()} function will be called. \mbox{[}{\bfseries{Note\+:}} Elements that have not been built yet are identified by the fact that the entries in their {\ttfamily Node\+\_\+pt} vector point to NULL. All other elements are ignored by the {\ttfamily Refineable\+Element\+::build()} function.\mbox{]} ~\newline
 The {\ttfamily Refineable\+Element\+::build()} function establishes the element\textquotesingle{}s pointers to its {\ttfamily Nodes} and creates new {\ttfamily Nodes} as and when required\+: some {\ttfamily Nodes} will already have existed in the old mesh; some new {\ttfamily Nodes} might already have been created by a neighbouring element, etc. If a new {\ttfamily Node} needs to be created, it is allocated with the element\textquotesingle{}s {\ttfamily Finite\+Element\+::construct\+\_\+node(...)} or {\ttfamily Finite\+Element\+::construct\+\_\+boundary\+\_\+node(...)} functions. By default, the current and previous positions of the new {\ttfamily Nodes} are determined via the father element\textquotesingle{}s geometric mapping. However, rather than referring directly to {\ttfamily QElement\+::interpolated\+\_\+x(...)}, we determine the position with 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::get\_x(...)\ }

\end{DoxyCode}
 which determines the nodal positions based on the father element\textquotesingle{}s macro-\/element representation if it exists; see section \doxysectlink{index_MacroElements}{Domains and Macro Elements}{2} for a discussion of macro elements for mesh refinement in domains with curvilinear boundaries. ~\newline
 By default, all values at a newly created {\ttfamily Node} are free (not pinned). If a new {\ttfamily Node} is located on the edge of the father element, we apply the same boundary conditions (if any) that apply along the father element\textquotesingle{}s edge. ~\newline
 If a {\ttfamily Node} lies on a {\ttfamily Mesh} boundary, we add it to the {\ttfamily Mesh} \textquotesingle{}s storage scheme for {\ttfamily Boundary\+Nodes}. ~\newline
 Finally, the values (and the history values) at the newly created {\ttfamily Nodes} must be assigned. This is done by using the interpolated values from the father element. Since the way in which values are interpolated inside an element is element-\/specific (e.\+g. in Taylor-\/\+Hood Navier-\/\+Stokes elements, different interpolations are used for the pressure and for the velocities), interpolated values are obtained from a call to the father element\textquotesingle{}s 
\begin{DoxyCode}{0}
\DoxyCodeLine{RefineableQElement<2>::get\_interpolated\_values(...)\ }

\end{DoxyCode}
 function which returns the vector of interpolated values (or history values) at a given local coordinate. This pure virtual function must be implemented for every specific {\ttfamily Refineable\+Element}. ~\newline
 At this point, the generic steps in the build process are completed, but many particular {\ttfamily Refineable\+Elements} now require further build operations. For instance, in Crouzeix-\/\+Raviart Navier-\/\+Stokes elements, the pressure interpolation is not based on nodal values but on internal {\ttfamily Data} which must be suitably initialised. For this purpose, we provide the interface 
\begin{DoxyCode}{0}
\DoxyCodeLine{RefineableElement::further\_build(...)\ }

\end{DoxyCode}
 which is executed at the end of {\ttfamily Refineable\+Element\+::build(...)} and can be used to perform any element-\/specific further build operations.
\item All new {\ttfamily Nodes} and elements have now been created. In the course of the mesh refinement, some of the previously existing {\ttfamily Nodes} that are (still) marked as hanging might have become non-\/hanging. Therefore, we now update the hanging nodes\textquotesingle{} values and coordinates so that their entries are consistent with their current hanging-\/node constraints and then reset their hanging-\/node status to non-\/hanging. Finally, we free (unpin) their nodal values. The hanging-\/node status of all {\ttfamily Nodes} will be re-\/assessed later, when the de-\/refinement phase is completed.
\item Now we loop over {\bfseries{all}} {\itshape "{}nodes"{}} in the {\ttfamily Quad\+Tree\+Forest}. If the sons of any {\itshape "{}non-\/leaf node"{}} in the {\ttfamily Quad\+Tree\+Forest} are scheduled for de-\/refinement, we merge them into their father element. This entails the following steps\+:
\begin{DoxyItemize}
\item First we execute the father element\textquotesingle{}s 
\begin{DoxyCode}{0}
\DoxyCodeLine{RefineableElement::rebuild\_from\_sons()\ }

\end{DoxyCode}
 member function, which can be used, e.\+g., to determine suitable values for the father element\textquotesingle{}s internal {\ttfamily Data} from the values of its sons. In addition, if any of the father\textquotesingle{}s {\ttfamily Nodes} have been deleted during refinement, they must be re-\/created during the merge procedure.
\item Next, we \textquotesingle{}unbuild\textquotesingle{} the son elements by marking those of its {\ttfamily Nodes} that do not exist in their father element as obsolete (this classification can later be over-\/ruled by other elements that need to retain the {\ttfamily Node}).
\item Now we delete the son {\ttfamily Refineable\+Elements} and the associated {\ttfamily Quad\+Trees} and empty the father element\textquotesingle{}s vector of pointers to its sons. This (re)turns the father element into a fully functional element.
\end{DoxyItemize}
\item Next, we empty the {\ttfamily Mesh\+::\+Element\+\_\+pt} vector and refill it with the currently active elements which are accessible via the {\ttfamily Quad\+Tree\+Forest} \textquotesingle{}s {\itshape "{}leaf nodes"{}}.
\item Now we loop over all elements in the {\ttfamily Mesh\+::\+Element\+\_\+pt} vector and mark their {\ttfamily Nodes} as non-\/obsolete.
\item We then update the {\ttfamily Nodes} hanging node status and adjust the nodal positions and values of the hanging nodes to make them consistent with the current hanging-\/node constraints.
\item We loop over all non-\/leaf elements in the {\ttfamily Quad\+Tree\+Forest} and call their {\ttfamily deactivate\+\_\+object()} function, which sets {\ttfamily Finite\+Element\+::\+Node\+\_\+pt}\mbox{[}n\mbox{]} to zero for any obsolete {\ttfamily Nodes}. Any {\ttfamily Nodes} in the {\ttfamily Mesh\+::\+Node\+\_\+pt} vector that are still labelled as obsolete are truly obsolete and are deleted by calling 
\begin{DoxyCode}{0}
\DoxyCodeLine{Mesh::prune\_dead\_nodes()\ }

\end{DoxyCode}

\item Finally, in order to facilitate dump and restart operations we sort the {\ttfamily Nodes} into a standard order using 
\begin{DoxyCode}{0}
\DoxyCodeLine{Mesh::reorder\_nodes()\ }

\end{DoxyCode}

\end{DoxyItemize}\hypertarget{index_Macro_element_meshes}{}\doxysection{\texorpdfstring{Mesh adaptation in domains with curved boundaries}{Mesh adaptation in domains with curved boundaries}}\label{index_Macro_element_meshes}
The mesh refinement procedures outlined above are perfectly adequate for meshes in polygonal domains. In such meshes the generation of the new nodal positions and the transfer of the solution from the old to the new mesh can be performed by simple interpolation, using the `father' element\textquotesingle{}s geometric mapping and shape functions. However, in problems with curvilinear mesh boundaries we must ensure that the refined meshes provide a progressively more accurate representation of the curvilinear domain boundary.

To facilitate these steps, we now introduce the concept of {\ttfamily Geom\+Objects}, {\ttfamily Domains} and {\ttfamily Macro\+Elements}, which allow a convenient and generic representation of domains that are bounded by time-\/dependent and/or curvilinear boundaries.\hypertarget{index_GeomObjects}{}\doxysubsection{\texorpdfstring{Geometric Objects}{Geometric Objects}}\label{index_GeomObjects}
Here are two examples of curvilinear boundaries that are frequently encountered in computations on moving domains\+:
\begin{DoxyItemize}
\item In many problems the boundary $\partial D$ of the moving domain $D$ is given explicitly in terms of a position vector \[ {\bf r}_{_{\partial D}}(\boldmath{\xi},t), \] where $ t $ is the (continuous) time and the components of the vector $ \boldmath{\xi} $ parametrise the boundary. We have $DIM({\bf r}_{_{\partial D}}) = DIM(\boldmath{\xi}) + 1$. For instance, the surface of a cylinder $C$ with time-\/dependent radius $R(t)$ can be represented as  \[ {\bf r}_{_{\partial C}} = \left( \begin{array}{c} 
                         R(t) \cos(\xi_2) \\
                         R(t) \sin(\xi_2) \\ 
                         \xi_1 \\ 
                         \end{array} \right). \]
\item In fluid problems with free surfaces or in fluid-\/structure interaction (FSI) problems, the domain boundary might have to be determined as part of the solution. In such cases, the boundary will have some computational representation. For instance, in an FSI computation in which a shell structure bounds the fluid domain, each shell finite element defines a small part of the fluid domain boundary and the shell element\textquotesingle{}s local coordinates provide a parametrisation of some part of the boundary in a form similar to the one shown above.
\end{DoxyItemize}

The common feature of these two examples is that, in both cases, the boundary is represented by a parametrised position vector. The {\ttfamily Geom\+Object} base class provides an abstract interface for such situations. In its most basic form, a `geometric object' simply provides a parametrisation of its shape by implementing the {\ttfamily Geom\+Object\textquotesingle{}s} pure virtual member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{GeomObject::position(xi,r)}

\end{DoxyCode}
 which computes the position vector {\ttfamily r} at the coordinates specified by the vector {\ttfamily xi}. {\ttfamily Geom\+Object} also provides a large number of additional interfaces in the form of (broken) virtual functions. The most important of these is the time-\/dependent version of the above function 
\begin{DoxyCode}{0}
\DoxyCodeLine{GeomObject::position(xi,\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}},r)}

\end{DoxyCode}
 which computes the position vector {\ttfamily r} at the coordinates specified by the vector {\ttfamily xi} at the {\bfseries{previous}} {\bfseries{discrete}} time level {\ttfamily t}. We follow the usual convention that
\begin{DoxyItemize}
\item for {\ttfamily t=0} the vector {\ttfamily r} is the position vector at the current time, {\ttfamily  time = Time\+::time() = Time\+::time(0) }
\item for {\ttfamily t=1} it represents the position at the previous (discrete) time level {\ttfamily t}, i.\+e. at the continuous time {\ttfamily  time = Time\+::time() -\/ Time\+::dt() = Time\+::time(1) }
\item etc.
\end{DoxyItemize}By default, the virtual member function {\ttfamily Geom\+Object\+::position(xi,t,r)} calls the steady version {\ttfamily Geom\+Object\+::position(xi,r)}, so it only needs to be overloaded for genuinely time-\/dependent geometric objects (by default, the code execution terminates if the time-\/dependent version is called for $ {\tt t} \ne 0; $ the function needs to be overloaded if this is not appropriate).

Further virtual member functions provide interfaces for the determination of the first and second spatial and temporal derivatives of the position vector, allowing the computation of boundary velocities, accelerations and curvatures, etc. These interfaces are provided as broken virtual functions, so they only need to be overloaded if/when the functionality is actually required in a particular application.

Typically, the shape of a {\ttfamily Geom\+Object} depends on a certain number of parameters (in the above examples, the radius $ R(t) $ of the cylinder and the displacements of the shell element, respectively) which can be unknowns in the problem. We therefore store these parameters as (geometric) {\ttfamily Data}, whose values can be pinned or free.\hypertarget{index_MacroElements}{}\doxysubsection{\texorpdfstring{Domains and Macro Elements}{Domains and Macro Elements}}\label{index_MacroElements}
For the purposes of mesh generation, we represent curvilinear domains by objects that are derived from the base class {\ttfamily Domain} and use {\ttfamily Geom\+Objects} to represent the curvilinear boundaries. For instance, the {\ttfamily Quarter\+Circle\+Sector\+Domain} sketched in the figure below is bounded by the geometric object {\ttfamily Ellipse} that parametrises the domain\textquotesingle{}s curved boundary, shown in red.

Consider the coarse discretisation of the domain shown in the Fig. (a) and assume that element 2 (a four-\/node quad element from the {\ttfamily QElement} family) is scheduled for refinement into four son elements. As discussed above, by default the {\ttfamily Nodes} of the son elements are established/created as follows\+:
\begin{DoxyItemize}
\item If a {\ttfamily Node} already exists in the father element we store the pointer to the existing {\ttfamily Node} in the son element\textquotesingle{}s {\ttfamily Node\+\_\+pt} vector.
\item If a {\ttfamily Node} needs to be created, we determine its position from the geometric mapping of the father element. Thus the five new {\ttfamily Nodes} that need to be created when element 2 is refined, are placed at their father element\textquotesingle{}s (i.\+e. element 2\textquotesingle{}s) local coordinates (0,0), (0,1), (0,-\/1), (1,0) and (-\/1,0). The father element\textquotesingle{}s 
\begin{DoxyCode}{0}
\DoxyCodeLine{RefineableQElement<2>::get\_x(...)\ }

\end{DoxyCode}
 determines the nodal position via a call to {\ttfamily QElement\+::interpolated\+\_\+x(...)}. Similarly, the nodal values of the new {\ttfamily Nodes} are determined by using the interpolated values in the father element.
\end{DoxyItemize}



For the element 0, this procedure would be perfectly adequate, as the domain boundary after refinement would (still) be captured exactly. However, when refining element 2 by this procedure, the new {\ttfamily Node} on the boundary is positioned on the straight line between the two boundary {\ttfamily Nodes} in the father element and not on the curved boundary itself, as shown in Fig. (b). Hence repeated mesh refinement will not lead to a better representation of the domain geometry and preclude convergence to the exact solution.

To overcome this problem, objects of type {\ttfamily Domain} provide a decomposition of the domain into a number of so-\/called {\ttfamily Macro\+Elements}, as sketched in Fig. (c). Boundaries of the {\ttfamily Macro\+Elements} are either given by (parts of) the (exact) curvilinear boundaries (as specified by the {\ttfamily Domain\textquotesingle{}s} {\ttfamily Geom\+Objects}) or by (arbitrary and usually straight) internal edges (or, in 3D, faces). In 2D, {\ttfamily Macro\+Elements} provide a mapping $ {\bf r}(S_0,S_1) $ from a local coordinate system $ (S_0, S_1) $, with $ S_i \in [-1..1]^2 $, to the points inside the {\ttfamily Macro\+Element} via their member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{MacroElement::macro\_map(S,r)\ }

\end{DoxyCode}
 The mapping needs to be chosen such that for $ S_1\in [-1..1]$ the position vector $ {\bf r}(S_0=-1,S_1) $ sweeps along the `southern' edge of the {\ttfamily Macro\+Element}, etc.; see Fig. (e). The form of the macro-\/element mapping is obviously not unique and it depends on the {\ttfamily Macro\+Element\textquotesingle{}s} topology. The class {\ttfamily QMacro\+Element$<$2$>$} provides a mapping that is suitable for 2D quadrilateral elements and can therefore be used with {\ttfamily Refineable\+QElement$<$2$>$} s.

The constructors for objects of type {\ttfamily Domain} typically require a vector of pointers to the {\ttfamily Geom\+Objects} that define its boundaries. The {\ttfamily Domain} constructor then usually employs function pointers to the {\ttfamily Geom\+Object\+::position(...)} function to define the {\ttfamily Macro\+Element} boundaries. Once built, the {\ttfamily Macro\+Elements} are accessible via the member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Domain::macro\_element\_pt(...).\ }

\end{DoxyCode}


We illustrate the macro-\/element based mesh generation and adaptation process for the case of {\ttfamily Refineable\+Quad\+Mesh} meshes. Assume that the domain is represented by an object of type {\ttfamily Domain}. We build a coarse initial mesh which contains as many {\ttfamily Refineable\+QElement$<$2$>$s} as there are {\ttfamily QMacro\+Elements} in the {\ttfamily Domain}. We associate each {\ttfamily Refineable\+QElement$<$2$>$} with one of the {\ttfamily QMacro\+Elements} by storing a pointer to the {\ttfamily QMacro\+Element} in {\ttfamily Finite\+Element\+::\+Macro\+\_\+elem\+\_\+pt}. Next, we use the {\ttfamily QMacro\+Elements\textquotesingle{}} macro map to determine the {\ttfamily Refineable\+QElement$<$2$>$\textquotesingle{}s} nodal positions such that, e.\+g., the {\ttfamily Refineable\+QElement$<$2$>$\textquotesingle{}s} SW node is placed at the {\ttfamily QMacro\+Element} \textquotesingle{}s local coordinates $(S_0,S_1)=(-1,-1)$, etc. The fraction of the {\ttfamily QMacro\+Element} that is spanned by each {\ttfamily Refineable\+QElement$<$2$>$} is represented by the maximum and minimum values of the {\ttfamily QMacro\+Element\textquotesingle{}s} local coordinates; the {\ttfamily Refineable\+QElement$<$2$>$} constructor initially sets these values to the defaults of +1.\+0 and -\/1.\+0, respectively, indicating that the {\ttfamily Refineable\+QElement$<$2$>$} spans the entire area of the corresponding {\ttfamily QMacro\+Element}.

With this additional information, we modify the ~\newline
 {\ttfamily Refineable\+QElement$<$2$>$\+::build()} process as follows\+:
\begin{DoxyItemize}
\item After creating the son elements, we set their {\ttfamily Finite\+Element\+::\+Macro\+\_\+elem\+\_\+pt} to that of their father.
\item We adjust the son\textquotesingle{}s maximum and minimum {\ttfamily Macro\+Element} coordinates so that they span the appropriate fraction of the {\ttfamily Macro\+Element}. For instance, for the SW son element of element 2 in the above sketch, we set $ S_0^{min}=-1, \  S_0^{max}=0, \ S_1^{min}=-1, \  S_1^{max}=0 $. Should this element get refined again, we set its NW son element\textquotesingle{}s coordinates to $ S_0^{min}=-1, \  S_0^{max}=-0.5,
   \ S_1^{min}=-0.5, \  S_1^{max}=0 $, etc.
\item The nodal positions of newly created {\ttfamily Nodes} are determined via calls to the father element\textquotesingle{}s {\ttfamily Refineable\+QElement$<$2$>$\+::get\+\_\+x(...)} function. If the father element is associated with a {\ttfamily Macro\+Element} (indicated by a non-\/\+NULL {\ttfamily Refineable\+QElement$<$2$>$\+::\+Macro\+\_\+elem\+\_\+pt} pointer), this function does not refer to {\ttfamily QElement\+::interpolated\+\_\+x(...)} (i.\+e. the FE mapping) but places the new {\ttfamily Node} at the appropriate point inside the father\textquotesingle{}s {\ttfamily Macro\+Element}. This ensures that {\ttfamily Nodes} that are created on the {\ttfamily Mesh} boundaries get placed on the {\ttfamily Domain} boundary, as shown in Fig. (d).
\item In time-\/dependent, moving mesh problems, the history of the new {\ttfamily Nodes\textquotesingle{}} position is established by calls to the time-\/dependent version of the {\ttfamily Macro\+Element\+::macro\+\_\+map(...)} function, which in turn refers to the time-\/dependent {\ttfamily Geom\+Object\+::position(...)} function of the {\ttfamily Geom\+Objects} that define the {\ttfamily Domain} boundaries. Hence for all new {\ttfamily Nodes}, {\ttfamily Node\+::x(t,i)} for {\ttfamily t\texorpdfstring{$>$}{>}0}, returns the position the {\ttfamily Node} would have had if it had already existed at the previous time level t.
\item We retain the original procedure for initialising the current and previous values at the new {\ttfamily Nodes} and continue to determine them by interpolation from the father element, based on the father element\textquotesingle{}s local coordinates. (We cannot determine the function values at the exact new nodal positions because new {\ttfamily Nodes} can be located outside their father elements.)
\end{DoxyItemize}\hypertarget{index_moving_mesh}{}\doxysubsection{\texorpdfstring{Macro-\/element-\/based node updates in moving mesh problems}{Macro-element-based node updates in moving mesh problems}}\label{index_moving_mesh}
Once a {\ttfamily Mesh} is associated with a {\ttfamily Domain}, the function {\ttfamily Mesh\+::node\+\_\+update()} updates the nodal positions in response to a change in the shape of the {\ttfamily Geom\+Objects} that define the {\ttfamily Domain} boundaries. \mbox{[}Note\+: This function updates all nodal positions first and then updates the positions of the hanging nodes to subject them to the hanging node constraints.\mbox{]} Alternative procedures for the update of the nodal positions in response to changes in the domain boundary are implemented in the {\ttfamily Algebraic\+Mesh}, {\ttfamily Spine\+Mesh} and {\ttfamily Solid\+Mesh} classes.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{\texorpdfstring{PDF file}{PDF file}}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
