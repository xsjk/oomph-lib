\chapter{Example problem\+: Spatially adaptive solution of the 2D unsteady heat equation with flux boundary conditions.}
\hypertarget{index}{}\label{index}\index{Example problem: Spatially adaptive solution of the 2D unsteady heat equation with flux boundary conditions.@{Example problem: Spatially adaptive solution of the 2D unsteady heat equation with flux boundary conditions.}}
This is a slightly more advanced example in which we demonstrate the use of spatial adaptivity in time-\/dependent problems. We discuss the implementation of the spatially adaptive version of {\ttfamily oomph-\/lib\textquotesingle{}s} unsteady Newton solver, {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve(...)}, and explain why the assignment of initial conditions should be performed by overloading the {\ttfamily Problem\+::set\+\_\+initial\+\_\+condition()} function. We also discuss briefly how {\ttfamily oomph-\/lib\textquotesingle{}s} generic dump and restart functions deal with adaptive meshes.

For this purpose consider the following problem\+:

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{The two-\/dimensional unsteady heat equation with flux boundary conditions in a quarter circle domain}} \end{center}  Solve  \[
\sum_{i=1}^2\frac{\partial^2 u}{\partial x_i^2} 
= \frac{\partial u}{\partial t} + f\left(x_1,x_2,t\right),
 \ \ \ \ \ \ \ \ \ \ (1)
\] in the quarter-\/circle domain $ D $, bounded by the coordinate axes and the unit circle, subject to Neumann boundary conditions,  \[
\left. \frac{\partial u}{\partial n}\right|_{\partial D_{Neumann}}=
- \left. \frac{\partial u}{\partial x_2}\right|_{\partial D_{Neumann}}=
g_0, 
\ \ \ \ \ \ \ \ \ \ (2)
\] along the horizontal domain boundary $ \partial D_{Neumann} = 
\{ (x_1,x_2) | x_1 \in [0,1], x_2=0 \} $, and to Dirichlet boundary conditions,  \[
\left. u\right|_{\partial D_{Dirichlet}}=h_0, 
\ \ \ \ \ \ \ \ \ \ (3)
\] elsewhere.  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{domain}
\doxyfigcaption{Sketch of the domain and the boundary conditions. }
\end{DoxyImage}
 The initial conditions are given by  \[
u(x_1,x_2,t=0)=k_0(x_1,x_2),
\ \ \ \ \ \ \ \ \ \ (4)
\] where the functions $ f, g_0, \ h_0$ and $ k_0$ are given.   \\\cline{1-1}
\end{longtabu}
~\newline
 \end{center} 

We choose the functions $ f, g_0, \ h_0$ and $ k_0$ so that  \[
u_0(x_1,x_2,t) = \tanh\bigg[1-\alpha\bigg(\tan\Phi
\big(x_1-\beta\tanh[ \gamma\cos\left(2\pi
t\right)]\big)- x_2\bigg)\bigg]
 \ \ \ \ \ \ \ \ \ \ (5)
\] is the exact solution.

The solution represents the "{}usual"{} tanh profile, whose steepness is controlled by the parameter $ \alpha $ so that for $ \alpha
\gg 1 $ the solution approaches a step. The step is oriented at an angle $ \Phi $ against the $ x_1-$ axis and its position varies periodically. The parameter $ \beta $ controls the amplitude of the step\textquotesingle{}s lateral displacement, while $ \gamma $ determines the rate at which its position changes. For $ \gamma \gg 1 $ , the step remains stationary for most of the period and then translates rapidly parallel to the $ x_1- $ axis, making this a very challenging problem.

The figure below shows a snapshot of the \href{../figures/step_soln.avi}{\texttt{ animated solution}}, obtained from the spatially adaptive simulation discussed below, for the parameter values $ \alpha=10, \ 
\Phi=45^o, \ \beta=0.3, \ \gamma=5. $

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{step_soln}
\doxyfigcaption{Snapshot of the solution. }
\end{DoxyImage}


The mesh adaptation in response to the translation of the step can be seen more clearly in this contour plot, taken from \href{../figures/unsteady_heat_contour.avi}{\texttt{ another animation of the solution}}.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{unsteady_heat_contour}
\doxyfigcaption{Contour plot of the solution. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_spatial_adapt}{}\doxysection{\texorpdfstring{Background\+: Spatial adaptivity in time-\/dependent problems}{Background: Spatial adaptivity in time-dependent problems}}\label{index_spatial_adapt}
Enabling spatial adaptivity in time-\/dependent problems involves essentially the same steps as for steady problems\+:
\begin{DoxyItemize}
\item The domain must be discretised with a mesh that is derived from the {\ttfamily Refineable\+Mesh} base class.
\item An {\ttfamily Error\+Estimator} object must be created and passed to the mesh.
\item The empty virtual functions {\ttfamily Problem\+::actions\+\_\+before\+\_\+adapt()} and {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()} may be overloaded to perform any actions that are required before or after the mesh adaptation, such as the deletion or recreation of any {\ttfamily Face\+Elements} that apply flux boundary conditions.
\end{DoxyItemize}Once these steps have been performed, a spatially adaptive solution can be computed with a three-\/argument version of {\ttfamily oomph-\/lib\textquotesingle{}s} unsteady Newton solver {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve(...)}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::unsteady\_newton\_solve(dt,max\_adapt,first)}

\end{DoxyCode}


The arguments to this function are as follows\+:
\begin{DoxyItemize}
\item The {\ttfamily double} {\ttfamily dt} specifies the (fixed) timestep.
\item The {\ttfamily unsigned} {\ttfamily max\+\_\+adapt} specifies the maximum number of spatial adaptations allowed.
\item The {\ttfamily bool} {\ttfamily first} indicates if the first timestep is performed. This argument is required to allow the automatic re-\/assignment of the initial conditions following any mesh adaptations during the computation of the first timestep.
\end{DoxyItemize}Given these arguments, the unsteady Newton solver solves the non-\/linear system of spatially and temporally discretised equations to advance the solution from time $ t $ to $ t + dt $ . Once the solution at time $ t + dt $ has been obtained, error estimates are computed for all elements. If any elemental error estimates are outside the target range, the solution is rejected and the mesh is adapted. In the course of mesh adaptation the existing solution (the nodal values {\itshape and} the history values) at time $ t $ are interpolated onto the new mesh before recomputing the solution. This process is repeated until the error estimates are within the target range, or until the maximum number of adaptations, specified by the parameter {\ttfamily max\+\_\+adapt}, is exceeded, just as in the steady case.

Here is an illustration of the procedure for a 1D problem\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{adapted}
\doxyfigcaption{Sketch of the mesh adaptation for time-\/dependent problems. }
\end{DoxyImage}


This procedure is the obvious generalisation of the procedure for steady problems. However, in time-\/dependent problems two additional issues arise\+:
\begin{DoxyEnumerate}
\item In a steady problem the interpolation of the solution onto the adapted mesh (step 4 in the above sketch) merely serves to provide an initial guess for the solution on the refined mesh. It is irrelevant if the interpolation from the coarse mesh provides a poor approximation of the actual solution as the solution is completely recomputed anyway. ~\newline
~\newline
 In an unsteady problem, we also have to interpolate the history values (the solution at previous timesteps in a BDF scheme) onto the adapted mesh. Their values are {\itshape not} changed when the solution is advanced from time $ t $ to $ t+ dt. $ In time-\/dependent problems, the benefit of repeated mesh adaptations (i.\+e. {\ttfamily max\+\_\+adapt} \texorpdfstring{$>$}{>} 1) is therefore limited by the fact that mesh refinement cannot improve their accuracy -- the history values are always given by the (possibly poor) approximations obtained by interpolation from the coarser mesh employed at the previous timestep. We therefore recommend limiting the number of spatial adaptations to {\ttfamily max\+\_\+adapt} = 1. We stress that, in practice, this is not a serious restriction because the time-\/integration procedure will only provide (temporally) accurate results if the timestep {\ttfamily dt} is so small that the solution at time $ t $ only differs slightly from that at time $ t + dt $ . One level of mesh adaptation per timestep should therefore be sufficient to adapt the mesh in response to these changes.
\item The only exception to this recommendation arises during the computation of the first timestep, illustrated in the following sketch\+:  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{adapted_ic1}
\doxyfigcaption{Sketch of the mesh adaptation during the computation of the first timestep. }
\end{DoxyImage}
 When computing the first timestep, the solution on the initial mesh will have been created by assigning the nodal values according to the analytical initial condition (4). If the initial mesh is very coarse (as it should be), the finite-\/element representation of the initial condition is likely to be very poor, as shown in the above sketch. Clearly, the interpolation from the coarse onto the fine mesh cannot recover any small-\/scale features in the initial condition that were missed by its representation on the coarse mesh. It is therefore better to re-\/assign the initial condition (the values {\itshape and} the history values!) on the adapted mesh, as shown in this sketch\+:  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{adapted_ic2}
\doxyfigcaption{Sketch of the modified mesh adaptation during the computation of the first timestep. }
\end{DoxyImage}
 With this procedure, repeated mesh adaptations will improve the accuracy of the solution, therefore much larger values of {\ttfamily max\+\_\+adapt} can (and should!) be specified when the first timestep is computed. The unsteady Newton solver {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve(...)} performs the revised procedure if the boolean argument {\ttfamily first} is set {\ttfamily true}. In that case, the values and history values on the adapted mesh are (re-\/)assigned by calling the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::set\_initial\_condition()}

\end{DoxyCode}
 which is defined as an empty virtual function in the {\ttfamily Problem} base class. You should overload it in your derived {\ttfamily Problem} to ensure that your specific initial conditions are assigned by the mesh adaptation procedures. \mbox{[}In fact, the function {\ttfamily Problem\+::set\+\_\+initial\+\_\+condition()} is not quite empty -- not re-\/setting the initial condition when performing mesh adaptations during the first timestep of a time-\/dependent simulation seems "{}so     wrong"{} that the function issues a warning message. Although the overloading of this function is not strictly necessary if the initial conditions can be represented exactly by the interpolation from the coarse mesh onto the fine mesh, we consider it good practice to do so, for reasons discussed in \href{../../../axisym_navier_stokes/spin_up/html/index.html\#good_practice_ics}{\texttt{ another tutorial}}.\mbox{]}
\end{DoxyEnumerate}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_overview}{}\doxysection{\texorpdfstring{Overview of the driver code}{Overview of the driver code}}\label{index_overview}
Equipped with this background information, the driver code for our example problem is easy to understand, if somewhat lengthy. \mbox{[}Using an example with Dirichlet boundary conditions along the entire domain boundary would have shortened the code significantly but we deliberately chose an example with Neumann boundary conditions to demonstrate that the functions {\ttfamily Problem\+::actions\+\_\+before\+\_\+adapt()} and {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()} may be used exactly as in the steady computations.\mbox{]} We will not discuss the methodology for applying flux-\/type boundary conditions in problems with spatial adaptivity in detail, but refer to the discussion provided in the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\texttt{ earlier steady example.}}

Overall, the code is a straightforward combination of the driver code for the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\texttt{ steady Poisson problem with flux boundary conditions and spatial adaptivity}} and the driver code for the \href{../../two_d_unsteady_heat/html/index.html}{\texttt{ unsteady heat equation without spatial adaptivity. }}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_namespace}{}\doxysection{\texorpdfstring{Global parameters and functions}{Global parameters and functions}}\label{index_namespace}
As usual, we store the problem parameters in a namespace, {\ttfamily \doxylink{namespaceTanhSolnForUnsteadyHeat}{Tanh\+Soln\+For\+Unsteady\+Heat}}, in which we also specify the source function, the prescribed flux along the Neumann boundary and the exact solution.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_ellipse}{}\doxysection{\texorpdfstring{Representing the curvilinear domain boundary by a  Geom\+Object}{Representing the curvilinear domain boundary by a  GeomObject}}\label{index_ellipse}
As discussed \href{../../../poisson/fish_poisson2/html/index.html}{\texttt{ elsewhere,}} {\ttfamily oomph-\/lib\textquotesingle{}s} mesh adaptation procedures require curvilinear domain boundaries to be represented by {\ttfamily Geom\+Objects} which describe the object\textquotesingle{}s shape via their member function {\ttfamily Geom\+Object\+::position(...)}. This function exists in two versions\+:
\begin{DoxyItemize}
\item The two-\/argument version, {\ttfamily Geom\+Object\+::position(xi,r)} computes the position vector, {\ttfamily r}, to the point on/in the {\ttfamily Geom\+Object}, parametrised by the vector of intrinsic coordinates, {\ttfamily xi}.
\item The three-\/argument version {\ttfamily Geom\+Object\+::position(t,xi,r)}, where {\ttfamily t} is an {\ttfamily unsigned}, computes the position vector at the {\ttfamily t} -\/ th previous timestep.
\end{DoxyItemize}In the current problem, the domain boundary is stationary, therefore the steady and unsteady versions of the function are identical. Here is the complete source code for the {\ttfamily \doxylink{classMyUnitCircle}{My\+Unit\+Circle}} object which we will use to represent the curvilinear domain boundary\+:

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_MyUnitCircle====================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Unit\ circle\ as\ GeomObject}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ \(\backslash\)f[\ x\ =\ \(\backslash\)cos(\(\backslash\)xi)\ \ \(\backslash\)f]}}
\DoxyCodeLine{\textcolor{comment}{///\ \(\backslash\)f[\ y\ =\ \(\backslash\)sin(\(\backslash\)xi)\ \ \(\backslash\)f]}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//=====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{class\ }\mbox{\hyperlink{classMyUnitCircle}{MyUnitCircle}}\ :\ \textcolor{keyword}{public}\ GeomObject}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Constructor:\ The\ circle\ is\ a\ 1D\ object}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ (i.e.\ it's\ parametrised\ by\ one\ intrinsic\ coordinate)\ in\ 2D\ space.}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pass\ these\ arguments\ to\ the\ constructor\ of\ the\ GeomObject\ base\ class.}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classMyUnitCircle_a056add64776e52a8ea2ba2e9d6d0e32d}{MyUnitCircle}}()\ :\ GeomObject(1,2)\ \{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Destructor:\ Empty}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keyword}{virtual}\ \mbox{\hyperlink{classMyUnitCircle_ae6b321a25ef6f6b12d7c9a225f91140d}{\string~MyUnitCircle}}()\ \{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Current\ position\ vector\ to\ material\ point\ at\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Lagrangian\ coordinate\ xi\ }}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classMyUnitCircle_ab60b73d1c28b013c40dd2aaa98072261}{position}}(\textcolor{keyword}{const}\ Vector<double>\&\ xi,\ Vector<double>\&\ r)\textcolor{keyword}{\ const}}
\DoxyCodeLine{\textcolor{keyword}{\ \ }\{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Position\ vector}}
\DoxyCodeLine{\ \ \ r[0]\ =\ cos(xi[0]);}
\DoxyCodeLine{\ \ \ r[1]\ =\ sin(xi[0]);}
\DoxyCodeLine{\ \ \}\ \textcolor{comment}{//\ end\ of\ position(...)}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Parametrised\ position\ on\ object:\ r(xi).\ Evaluated\ at}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ previous\ time\ level.\ t=0:\ current\ time;\ t>0:\ previous}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ time\ level.\ Circle\ is\ fixed\ -\/-\/\ simply\ call\ the\ steady\ version.}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classMyUnitCircle_ab60b73d1c28b013c40dd2aaa98072261}{position}}(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ t,\ \textcolor{keyword}{const}\ Vector<double>\&\ xi,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Vector<double>\&\ r)\textcolor{keyword}{\ const}}
\DoxyCodeLine{\textcolor{keyword}{\ \ }\{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Call\ steady\ version\ }}
\DoxyCodeLine{\ \ \ \mbox{\hyperlink{classMyUnitCircle_ab60b73d1c28b013c40dd2aaa98072261}{position}}(xi,r);}
\DoxyCodeLine{\ \ \}\ \textcolor{comment}{//\ end\ of\ position(...)}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\};\ \textcolor{comment}{//\ end\ of\ MyUnitCircle}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysection{\texorpdfstring{The main function}{The main function}}\label{index_main}
As before, we use command line arguments to (optionally) specify a restart file. We store the command line arguments in the namespace {\ttfamily Command\+Line\+Args} and build the {\ttfamily Problem} object, passing the pointer to the source function. Next we specify the time-\/interval for the simulation and set the error targets for the spatial adaptation.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//======start\_of\_main=====================================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Demonstrate\ how\ to\ solve\ an\ unsteady\ heat\ problem}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ with\ mesh\ adaptation.\ Command\ line\ arguments\ specify\ }}
\DoxyCodeLine{\textcolor{comment}{///\ the\ name\ of\ the\ restart\ file.\ }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{two__d__unsteady__heat__adapt_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}}(\textcolor{keywordtype}{int}\ argc,\ \textcolor{keywordtype}{char}*\ argv[])}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Store\ command\ line\ arguments}}
\DoxyCodeLine{\ CommandLineArgs::setup(argc,argv);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Build\ problem}}
\DoxyCodeLine{\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem}{RefineableUnsteadyHeatProblem<RefineableQUnsteadyHeatElement<2,3>}}\ >}
\DoxyCodeLine{\ \ problem(\&\mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat_aea922a29dfeeb80ef4768def0d6fbde4}{TanhSolnForUnsteadyHeat::get\_source}});}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Specify\ duration\ of\ the\ simulation}}
\DoxyCodeLine{\ \textcolor{comment}{//double\ t\_max=3.0;}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ targets\ for\ spatial\ adaptivity}}
\DoxyCodeLine{\ problem.bulk\_mesh\_pt()-\/>max\_permitted\_error()=0.001;}
\DoxyCodeLine{\ problem.bulk\_mesh\_pt()-\/>min\_permitted\_error()=0.0001;}

\end{DoxyCodeInclude}
 We create and initialise the boolean flag that indicates if the first timestep is computed, and choose a large initial value for the number of permitted mesh adaptations. We then assign the initial conditions on the coarse initial mesh and retrieve the timestep (chosen when the initial conditions are assigned in {\ttfamily set\+\_\+initial\+\_\+condition()} ) from the problem\textquotesingle{}s {\ttfamily Time} object.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ IC}}
\DoxyCodeLine{\ problem.set\_initial\_condition();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Initial\ timestep:\ Use\ the\ one\ used\ when\ setting\ up\ the\ initial}}
\DoxyCodeLine{\ \textcolor{comment}{//\ condition}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ dt=problem.time\_pt()-\/>dt();}

\end{DoxyCodeInclude}
 If the simulation has been restarted, the first timestep is not the step at which the initial condition has to be assigned, therefore we reset the {\ttfamily first} and {\ttfamily max\+\_\+adapt} parameters to their appropriate values. If the run is not restarted, the problem will have been built with a very coarse initial mesh (comprising just three elements). We don\textquotesingle{}t need an error estimator to tell us that this is too coarse to represent the solution accurately and apply two levels of uniform refinement before solving the problem. Note that we refine the entire problem, not just the mesh to ensure that {\ttfamily Problem\+::actions\+\_\+before\+\_\+adapt()} and {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()} are executed and the equation numbering scheme is re-\/generated. {\ttfamily Problem\+::refine\+\_\+uniformly()} also interpolates the solution from the coarse initial mesh onto the refined mesh but, as discussed above, this will lead to a very poor representation of the initial condition. Therefore we re-\/assign the initial condition on the refined mesh and document the finite-\/element representation of the initial condition.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ If\ restart:\ The\ first\ step\ isn't\ really\ the\ first\ step,}}
\DoxyCodeLine{\ \textcolor{comment}{//\ i.e.\ initial\ condition\ should\ not\ be\ re-\/set\ when\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ adaptive\ refinement\ has\ been\ performed.\ Also,\ limit}}
\DoxyCodeLine{\ \textcolor{comment}{//\ the\ max.\ number\ of\ refinements\ per\ timestep\ to\ the}}
\DoxyCodeLine{\ \textcolor{comment}{//\ normal\ value\ straightaway.}}
\DoxyCodeLine{\ \textcolor{keywordflow}{if}\ (CommandLineArgs::Argc==2)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ first=\textcolor{keyword}{false};}
\DoxyCodeLine{\ \ \ max\_adapt=1;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \textcolor{comment}{//\ If\ no\ restart,\ refine\ mesh\ uniformly\ before\ we\ get\ started}}
\DoxyCodeLine{\ \textcolor{keywordflow}{else}}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ problem.refine\_uniformly();}
\DoxyCodeLine{\ \ \ problem.refine\_uniformly();}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Solution\ is\ automatically\ interpolated\ from\ the\ coarse\ initial\ mesh}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ onto\ the\ refined\ mesh\ but\ this\ provides\ a\ very\ poor\ representation}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ of\ the\ intial\ condition:\ Re-\/assign\ the\ initial\ conditions}}
\DoxyCodeLine{\ \ \ problem.set\_initial\_condition();}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Output\ FE\ representation\ of\ the\ initial\ condition}}
\DoxyCodeLine{\ problem.doc\_solution();}

\end{DoxyCodeInclude}
 The time-\/stepping loop itself is very similar to that used in the \href{../../two_d_unsteady_heat/html/index.html}{\texttt{ example without spatial adaptivity}}. Here we call the three-\/argument version of the unsteady Newton solver {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve(...)} and re-\/set the parameters {\ttfamily max\+\_\+adapt} and {\ttfamily first} to their appropriate values once the first step has been performed.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Find\ number\ of\ steps}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ nstep\ =\ 6;\ \textcolor{comment}{//\ unsigned(t\_max/dt);}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Timestepping\ loop}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ istep=0;istep<nstep;istep++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Take\ timestep\ }}
\DoxyCodeLine{\ \ \ problem.unsteady\_newton\_solve(dt,max\_adapt,first);}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Now\ we've\ done\ the\ first\ timestep\ -\/-\/\ don't\ re-\/set\ the\ IC}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ in\ subsequent\ steps}}
\DoxyCodeLine{\ \ \ first=\textcolor{keyword}{false};}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Reduce\ the\ number\ of\ spatial\ adaptations\ to\ one\ per\ }}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ timestep}}
\DoxyCodeLine{\ \ \ max\_adapt=1;}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Output\ solution}}
\DoxyCodeLine{\ \ \ problem.doc\_solution();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ }
\DoxyCodeLine{}
\DoxyCodeLine{\};\ \textcolor{comment}{//\ end\ of\ main}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_problem}{}\doxysection{\texorpdfstring{The problem class}{The problem class}}\label{index_problem}
As discussed above, the problem class mainly contains verbatim copies of the member functions in the corresponding \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\texttt{ steady }} and \href{../../two_d_unsteady_heat/html/index.html}{\texttt{ unsteady}} problems\+:

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====start\_of\_problem\_class=========================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Unsteady\ heat\ problem\ in\ quarter\ circle\ domain.}}
\DoxyCodeLine{\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class\ }\mbox{\hyperlink{classRefineableUnsteadyHeatProblem}{RefineableUnsteadyHeatProblem}}\ :\ \textcolor{keyword}{public}\ Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Constructor:\ Pass\ pointer\ to\ source\ function}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem}{RefineableUnsteadyHeatProblem}}(UnsteadyHeatEquations<2>::}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ UnsteadyHeatSourceFctPt\ source\_fct\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Destructor:\ Close\ trace\ file}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a975e00f5e87d77b4e1bf4d50482dea2b}{\string~RefineableUnsteadyHeatProblem}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ the\ problem\ specs\ after\ solve\ (empty)}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_ada522772b79e92a75edf3724d0a273da}{actions\_after\_newton\_solve}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ the\ problem\ specs\ before\ solve\ (empty)}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_aac1935e15c67b196e6db97dd058511b5}{actions\_before\_newton\_solve}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ the\ problem\ specs\ after\ timestep\ (empty)}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_aa740f2eb1b3909100a04709b401c0b41}{actions\_after\_implicit\_timestep}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Update\ the\ problem\ specs\ before\ next\ timestep:\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Set\ Dirchlet\ boundary\ conditions\ from\ exact\ solution.}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_ac754f1313cd6d684c149443beb5bcf9e}{actions\_before\_implicit\_timestep}}();}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Actions\ before\ adapt:\ Wipe\ the\ mesh\ of\ prescribed\ flux\ elements}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a4419fcea0ccbf0509f1d5dd37d8301de}{actions\_before\_adapt}}();}
\DoxyCodeLine{\ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Actions\ after\ adapt:\ Rebuild\ the\ mesh\ of\ prescribed\ flux\ elements}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a1f8a9e91269440c799a2075f989d62b1}{actions\_after\_adapt}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Set\ initial\ condition\ (incl\ previous\ timesteps)\ according}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ to\ specified\ function.\ Note\ that\ his\ overloads\ the\ virtual}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ function\ in\ the\ Problem\ base\ class\ and\ is\ therefore\ executed\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ automatically\ to\ re-\/assign\ the\ initial\ conditions\ during\ the\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ spatially\ adaptive\ solution\ at\ the\ first\ timestep.}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a30e2e1d62b059982f7014b74f4fe2be9}{set\_initial\_condition}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Create\ UnsteadyHeat\ flux\ elements\ on\ boundary\ b\ of\ the\ Mesh\ pointed}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ to\ by\ bulk\_mesh\_pt\ and\ add\ them\ to\ the\ Mesh\ object\ pointed\ to\ by\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ surface\_mesh\_pt}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a65601ec64c73ac578b43f4af04c46569}{create\_flux\_elements}}(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \&b,\ Mesh*\ \textcolor{keyword}{const}\ \&\mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a49ee185e10fdab1851a67150cbb0710a}{bulk\_mesh\_pt}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Mesh*\ \textcolor{keyword}{const}\ \&surface\_mesh\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Delete\ UnsteadyHeat\ flux\ elements\ and\ wipe\ the\ surface\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_ad2e53af5c385e44e33e400b430b610e8}{delete\_flux\_elements}}(Mesh*\ \textcolor{keyword}{const}\ \&surface\_mesh\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Doc\ the\ solution}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a77d590171785b6b5f4070af9401c0e37}{doc\_solution}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Dump\ problem\ data\ to\ allow\ for\ later\ restart}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a1fb939c3f9c258fd49328bb1516ced98}{dump\_it}}(ofstream\&\ dump\_file);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Read\ problem\ data\ for\ restart}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_af36fa71e72852367411e21b50b179625}{restart}}(ifstream\&\ restart\_file);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ bulk\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ RefineableQuarterCircleSectorMesh<ELEMENT>*\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a49ee185e10fdab1851a67150cbb0710a}{bulk\_mesh\_pt}}()}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_afade341e03a4c97e62444c80adc9552f}{Bulk\_mesh\_pt}};}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ GeomObject\ that\ specifies\ the\ domain\ bondary}}
\DoxyCodeLine{\textcolor{comment}{}\ GeomObject*\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a368512778fbfd59e918104340466b1df}{Boundary\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ source\ function}}
\DoxyCodeLine{\textcolor{comment}{}\ UnsteadyHeatEquations<2>::UnsteadyHeatSourceFctPt\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a99eb5a2cd4b680b4f83e739bd4e16639}{Source\_fct\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ the\ "{}bulk"{}\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ RefineableQuarterCircleSectorMesh<ELEMENT>*\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_afade341e03a4c97e62444c80adc9552f}{Bulk\_mesh\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ the\ "{}surface"{}\ mesh}}
\DoxyCodeLine{\textcolor{comment}{}\ Mesh*\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a2febbb317a74e427bf6304235d779fe6}{Surface\_mesh\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Pointer\ to\ central\ node\ (exists\ at\ all\ refinement\ levels)\ for\ doc}}
\DoxyCodeLine{\textcolor{comment}{}\ Node*\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a7ff1982af5819bab492c693178be0c24}{Doc\_node\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Doc\ info\ object}}
\DoxyCodeLine{\textcolor{comment}{}\ DocInfo\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a9ea9d79a57cb16a6292a637965767f7e}{Doc\_info}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Trace\ file}}
\DoxyCodeLine{\textcolor{comment}{}\ ofstream\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a8f62ba78fb856d2e07b00254ca7a0e6a}{Trace\_file}};}
\DoxyCodeLine{}
\DoxyCodeLine{\};\ \textcolor{comment}{//\ end\ of\ problem\_class}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysection{\texorpdfstring{The problem constructor}{The problem constructor}}\label{index_constructor}
The problem constructor combines the constructors of the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\texttt{ steady }} and \href{../../two_d_unsteady_heat/html/index.html}{\texttt{ unsteady}} problems. We start by creating a {\ttfamily Doc\+Info} object to control the output, set the parameters for the exact solution and create the {\ttfamily Time\+Stepper\+:} 


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//========start\_of\_constructor============================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Constructor\ for\ UnsteadyHeat\ problem\ in\ quarter\ circle\ domain.}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ Pass\ pointer\ to\ source\ function.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a894f3bd6c1c23c307a736de6898e4e98}{RefineableUnsteadyHeatProblem<ELEMENT>::RefineableUnsteadyHeatProblem}}(}
\DoxyCodeLine{\ \ \ UnsteadyHeatEquations<2>::UnsteadyHeatSourceFctPt\ source\_fct\_pt)\ :\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ Source\_fct\_pt(source\_fct\_pt)}
\DoxyCodeLine{\{\ }
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Setup\ labels\ for\ output}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Output\ directory}}
\DoxyCodeLine{\ Doc\_info.set\_directory(\textcolor{stringliteral}{"{}RESLT"{}});}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Output\ number}}
\DoxyCodeLine{\ Doc\_info.number()=0;\ }
\DoxyCodeLine{\ }
\DoxyCodeLine{\ \textcolor{comment}{//\ Open\ trace\ file}}
\DoxyCodeLine{\ \textcolor{keywordtype}{char}\ filename[100];\ \ \ }
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/trace.dat"{}},Doc\_info.directory().c\_str());}
\DoxyCodeLine{\ Trace\_file.open(filename);}
\DoxyCodeLine{\ }
\DoxyCodeLine{\ Trace\_file\ <<\ \textcolor{stringliteral}{"{}VARIABLES=\(\backslash\)"{}time\ t\(\backslash\)"{},\(\backslash\)"{}u<SUB>FE</SUB>\(\backslash\)"{},\(\backslash\)"{}u<SUB>exact</SUB>\(\backslash\)"{},"{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\(\backslash\)"{}A\(\backslash\)"{},"{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\(\backslash\)"{}X<SUB>step</SUB>\(\backslash\)"{},"{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\(\backslash\)"{}N<SUB>element</SUB>\(\backslash\)"{},"{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\(\backslash\)"{}N<SUB>refined</SUB>\(\backslash\)"{},"{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\(\backslash\)"{}N<SUB>unrefined</SUB>\(\backslash\)"{},"{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\(\backslash\)"{}norm\ of\ error\(\backslash\)"{},"{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\(\backslash\)"{}norm\ of\ solution\(\backslash\)"{}"{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ <<\ std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Setup\ parameters\ for\ tanh\ solution}}
\DoxyCodeLine{\ \textcolor{comment}{//\ -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Steepness\ of\ step}}
\DoxyCodeLine{\ \mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat_a4c75d9887d6f25405bbead696a94db63}{TanhSolnForUnsteadyHeat::Alpha}}=10.0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Orientation\ of\ step}}
\DoxyCodeLine{\ \mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat_af8d2e06630e8a3f71d1f8dbeecf8a964}{TanhSolnForUnsteadyHeat::TanPhi}}=1.0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Amplitude\ for\ movement\ of\ step}}
\DoxyCodeLine{\ \mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat_a66f6116310a5f9f96c2d3bf28250a92b}{TanhSolnForUnsteadyHeat::Beta}}=0.3;\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Parameter\ for\ time-\/dependence\ of\ step\ movement}}
\DoxyCodeLine{\ \mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat_a5bb742b074ab5f3f65286b1cff1f1512}{TanhSolnForUnsteadyHeat::Gamma}}=5.0;}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Allocate\ the\ timestepper\ -\/-\/\ This\ constructs\ the\ time\ object\ as\ well}}
\DoxyCodeLine{\ add\_time\_stepper\_pt(\textcolor{keyword}{new}\ BDF<2>());}

\end{DoxyCodeInclude}


We create the {\ttfamily Geom\+Object} that describes the curvilinear domain boundary and pass it to the mesh constructor\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Setup\ mesh}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Build\ geometric\ object\ that\ forms\ the\ curvilinear\ domain\ boundary:}}
\DoxyCodeLine{\ \textcolor{comment}{//\ a\ unit\ circle\ }}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ GeomObject}}
\DoxyCodeLine{\ Boundary\_pt=\textcolor{keyword}{new}\ \mbox{\hyperlink{classMyUnitCircle}{MyUnitCircle}};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Start\ and\ end\ coordinates\ of\ curvilinear\ domain\ boundary\ on\ circle}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ xi\_lo=0.0;}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ xi\_hi=MathematicalConstants::Pi/2.0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Now\ create\ the\ bulk\ mesh.\ Separating\ line\ between\ the\ two\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ elements\ next\ to\ the\ curvilinear\ boundary\ is\ located\ half-\/way}}
\DoxyCodeLine{\ \textcolor{comment}{//\ along\ the\ boundary.}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ fract\_mid=0.5;}
\DoxyCodeLine{\ Bulk\_mesh\_pt\ =\ \textcolor{keyword}{new}\ RefineableQuarterCircleSectorMesh<ELEMENT>(}
\DoxyCodeLine{\ \ Boundary\_pt,xi\_lo,fract\_mid,xi\_hi,time\_stepper\_pt());}

\end{DoxyCodeInclude}
 Next, we create the surface mesh that contains the prescribed flux elements and combine the two submeshes to the {\ttfamily Problem\textquotesingle{}s} global mesh. We create an instance of the {\ttfamily Z2\+Error\+Estimator} and pass it to the bulk mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ the\ surface\ mesh\ as\ an\ empty\ mesh}}
\DoxyCodeLine{\ Surface\_mesh\_pt=\textcolor{keyword}{new}\ Mesh;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ prescribed-\/flux\ elements\ from\ all\ elements\ that\ are\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ adjacent\ to\ boundary\ 0\ (the\ horizontal\ lower\ boundary),\ and\ add\ them\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ to\ the\ (so\ far\ empty)\ surface\ mesh.}}
\DoxyCodeLine{\ create\_flux\_elements(0,Bulk\_mesh\_pt,Surface\_mesh\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Add\ the\ two\ sub\ meshes\ to\ the\ problem}}
\DoxyCodeLine{\ add\_sub\_mesh(Bulk\_mesh\_pt);}
\DoxyCodeLine{\ add\_sub\_mesh(Surface\_mesh\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Combine\ all\ submeshes\ into\ a\ single\ global\ Mesh}}
\DoxyCodeLine{\ build\_global\_mesh();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ error\ estimator\ for\ bulk\ mesh}}
\DoxyCodeLine{\ Z2ErrorEstimator*\ error\_estimator\_pt=\textcolor{keyword}{new}\ Z2ErrorEstimator;}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>spatial\_error\_estimator\_pt()=error\_estimator\_pt;}

\end{DoxyCodeInclude}
 We pin the nodal values on the Dirichlet boundaries and select the central node in the unrefined three-\/element mesh as the control node at which the solution is documented in the trace file.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Set\ the\ boundary\ conditions\ for\ this\ problem:\ All\ nodes\ are}}
\DoxyCodeLine{\ \textcolor{comment}{//\ free\ by\ default\ -\/-\/\ just\ pin\ the\ ones\ that\ have\ Dirichlet\ conditions}}
\DoxyCodeLine{\ \textcolor{comment}{//\ here.\ }}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_bound\ =\ Bulk\_mesh\_pt-\/>nboundary();}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ b=0;b<n\_bound;b++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Leave\ nodes\ on\ boundary\ 0\ free\ -\/-\/\ this\ is\ where\ we\ apply\ the\ flux}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ boundary\ condition}}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{if}\ (b!=0)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \textcolor{keywordtype}{unsigned}\ n\_node\ =\ Bulk\_mesh\_pt-\/>nboundary\_node(b);}
\DoxyCodeLine{\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ n=0;n<n\_node;n++)}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ Bulk\_mesh\_pt-\/>boundary\_node\_pt(b,n)-\/>pin(0);\ }
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Extract\ pointer\ to\ the\ central\ node\ (this\ exists\ at\ all\ refinement\ levels)}}
\DoxyCodeLine{\ \textcolor{comment}{//\ for\ doc\ of\ solution}}
\DoxyCodeLine{\ FiniteElement*\ el0\_pt=Bulk\_mesh\_pt-\/>finite\_element\_pt(0);}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ nnod=el0\_pt-\/>nnode();}
\DoxyCodeLine{\ Doc\_node\_pt=el0\_pt-\/>node\_pt(nnod-\/1);}

\end{DoxyCodeInclude}
 Finally, we complete the build of all elements by passing the relevant function pointers to the elements, and assign the equation numbers.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Complete\ the\ build\ of\ all\ elements\ so\ they\ are\ fully\ functional}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Find\ number\ of\ elements\ in\ mesh}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_element\ =\ Bulk\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Loop\ over\ the\ elements\ to\ set\ up\ element-\/specific\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ things\ that\ cannot\ be\ handled\ by\ constructor}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ i=0;i<n\_element;i++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Upcast\ from\ FiniteElement\ to\ the\ present\ element}}
\DoxyCodeLine{\ \ \ ELEMENT\ *el\_pt\ =\ \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt-\/>element\_pt(i));}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//Set\ the\ source\ function\ pointer}}
\DoxyCodeLine{\ \ \ el\_pt-\/>source\_fct\_pt()\ =\ Source\_fct\_pt;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Loop\ over\ the\ flux\ elements\ to\ pass\ pointer\ to\ prescribed\ flux\ function}}
\DoxyCodeLine{\ n\_element=Surface\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ e=0;e<n\_element;e++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Upcast\ from\ GeneralisedElement\ to\ UnsteadyHeat\ flux\ element}}
\DoxyCodeLine{\ \ \ UnsteadyHeatFluxElement<ELEMENT>\ *el\_pt\ =\ }
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{dynamic\_cast<}UnsteadyHeatFluxElement<ELEMENT>*\textcolor{keyword}{>}(}
\DoxyCodeLine{\ \ \ \ \ Surface\_mesh\_pt-\/>element\_pt(e));}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Set\ the\ pointer\ to\ the\ prescribed\ flux\ function}}
\DoxyCodeLine{\ \ \ el\_pt-\/>flux\_fct\_pt()\ =\ }
\DoxyCodeLine{\ \ \ \ \&\mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat_af4d78d73bd9981a5a9ecacecfd0e9cb8}{TanhSolnForUnsteadyHeat::prescribed\_flux\_on\_fixed\_y\_boundary}};}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Do\ equation\ numbering}}
\DoxyCodeLine{\ cout\ <<\textcolor{stringliteral}{"{}Number\ of\ equations:\ "{}}\ <<\ assign\_eqn\_numbers()\ <<\ std::endl;\ }
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ constructor}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_old_functions}{}\doxysection{\texorpdfstring{Other member functions}{Other member functions}}\label{index_old_functions}
The remaining member functions
\begin{DoxyItemize}
\item {\ttfamily actions\+\_\+after\+\_\+newton\+\_\+solve()} 
\item {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+solve()} 
\item {\ttfamily actions\+\_\+after\+\_\+implicit\+\_\+timestep()} 
\item {\ttfamily actions\+\_\+before\+\_\+implicit\+\_\+timestep()} 
\item {\ttfamily actions\+\_\+before\+\_\+adapt()} 
\item {\ttfamily actions\+\_\+after\+\_\+adapt()} 
\item {\ttfamily set\+\_\+initial\+\_\+condition()} 
\item {\ttfamily create\+\_\+flux\+\_\+elements(...)} 
\item {\ttfamily delete\+\_\+flux\+\_\+elements(...)} 
\item {\ttfamily doc\+\_\+solution()} 
\item {\ttfamily dump\+\_\+it(...)} 
\item {\ttfamily restart(...)} 
\end{DoxyItemize}are identical (or at least extremely similar) to those in previous examples, so we do not list them here. You can examine the functions in detail in the source code \href{../../../../demo_drivers/unsteady_heat/two_d_unsteady_heat_adapt/two_d_unsteady_heat_adapt.cc}{\texttt{ two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+adapt.\+cc}}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_restart}{}\doxysection{\texorpdfstring{Dump/restart with spatial adaptivity}{Dump/restart with spatial adaptivity}}\label{index_restart}
It is worth examining the dump and restart functions, however, as they demonstrate that the generic versions defined in the {\ttfamily Problem} base class can also deal with adaptive problems -- a non-\/trivial task!


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=======start\_of\_dump\_it=================================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Dump\ the\ solution\ to\ disk}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a1fb939c3f9c258fd49328bb1516ced98}{RefineableUnsteadyHeatProblem<ELEMENT>::dump\_it}}(ofstream\&\ dump\_file)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Dump\ the\ refinement\ pattern\ and\ the\ generic\ problem\ data}}
\DoxyCodeLine{\ Problem::dump(dump\_file);}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ dump\_it}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//=========start\_of\_restart===============================================}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ Read\ solution\ from\ disk}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_af36fa71e72852367411e21b50b179625}{RefineableUnsteadyHeatProblem<ELEMENT>::restart}}(ifstream\&\ restart\_file)}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Refine\ the\ mesh\ and\ read\ in\ the\ generic\ problem\ data}}
\DoxyCodeLine{\ Problem::read(restart\_file);}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ restart}}

\end{DoxyCodeInclude}
 Since details of their implementation are hidden from the user, we briefly comment on the various tasks performed by these functions. The main task of the {\ttfamily Problem\+::read(...)} function is to read values (and history values) of all {\ttfamily Data} objects from a file and to assign these values to the appropriate {\ttfamily Data} (and {\ttfamily Node}) objects in the {\ttfamily Problem}. This assumes that the {\ttfamily Problem\textquotesingle{}s} constituent {\ttfamily Meshes}, elements, {\ttfamily Nodes} and {\ttfamily Data} objects have been created, and that the {\ttfamily Problem\textquotesingle{}s} various pointer-\/based lookup schemes access them in the order they were in when the {\ttfamily Problem} was dumped to the restart file. In a non-\/adaptive computation, the number of elements and the number of {\ttfamily Data} objects remain constant throughout the simulation and the {\ttfamily Problem\+::read(...)} function can be called as soon as the {\ttfamily Problem} has been built -- usually by its constructor. (The {\ttfamily Problem} constructor always builds and enumerates its constituent objects in the same order.)

In a simulation with spatial adaptivity the number of elements, {\ttfamily Nodes} and {\ttfamily Data} objects varies throughout the computation. It is therefore necessary to re-\/generate the {\ttfamily Problem\textquotesingle{}s} refinement pattern before the {\ttfamily Data} values can be read from the restart file. This is achieved (internally) by calling the function {\ttfamily Refineable\+Mesh\+::dump\+\_\+refinement(...)} for all refineable meshes before the {\ttfamily Data} is dumped. This function writes the {\ttfamily Mesh\textquotesingle{}s} refinement pattern to the restart file, using a format that can be read by the corresponding member function {\ttfamily Refineable\+Mesh\+::refine(...)} which adapts an unrefined mesh so that its topology and the order of its {\ttfamily Nodes} and elements is recreated.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comments}{}\doxysection{\texorpdfstring{Comments and exercises}{Comments and exercises}}\label{index_comments}
The plots below show the time history of various parameters.
\begin{DoxyItemize}
\item The upper graph compares the solution at the control node (red line) against the exact solution (green line).
\item The middle graph shows the position of the step by plotting its intercept with the $ x_1- $ axis as a function of time, and the error of the solution.
\item The lower graph illustrates the evolution of the adaptive spatial refinement process\+: The green line illustrates the total number of elements; the blue and red lines show the number of elements that are refined and unrefined at each timestep.
\end{DoxyItemize}

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{trace}
\doxyfigcaption{Time history of the solution. }
\end{DoxyImage}


The plots illustrate clearly how the mesh is adapted as the step moves through the domain -- the peaks in the number of refined/unrefined elements per timestep coincide with the periods during which the step moves very rapidly. The increase in the error during these phases is mainly due to the temporal error -- the \href{../figures/step_soln.avi}{\texttt{ animation}} shows that the computed solution lags behind the exact one. We will address this by adding adaptive time-\/stepping in \href{../../two_d_unsteady_heat_2adapt/html/index.html}{\texttt{ another example.}}\hypertarget{index_ex}{}\doxysubsection{\texorpdfstring{Exercises}{Exercises}}\label{index_ex}

\begin{DoxyEnumerate}
\item Confirm that the error during the periods of rapid change in the solution is due to the temporal error by repeating the simulation with a smaller/larger timestep and/or a time-\/stepping scheme with higher/lower order (e.\+g. BDF$<$1$>$ or BDF$<$4$>$).
\item Assess the importance of re-\/assigning the initial conditions when spatial adaptations are performed during the computation of the first timestep.
\begin{DoxyEnumerate}
\item Compare the finite-\/element representation of the initial condition(contained in the file {\ttfamily RESLT/soln0.\+dat}) against that obtained when the re-\/assignment of the initial conditions after the two calls to {\ttfamily problem.\+refine\+\_\+uniformly()} in the {\ttfamily main} function is suppressed.
\item Comment out the calls to {\ttfamily problem.\+refine\+\_\+uniformly()} and set {\ttfamily first=false} throughout the {\ttfamily main} function and compare the computed results against those obtained with ~\newline
 the correct procedure.
\end{DoxyEnumerate}
\end{DoxyEnumerate}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{\texorpdfstring{Source files for this tutorial}{Source files for this tutorial}}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{
../../../../
demo_drivers/unsteady_heat/two_d_unsteady_heat_adapt/
}{\texttt{ demo\+\_\+drivers/unsteady\+\_\+heat/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+adapt/ }} \end{center} 
\item The driver code is\+: \begin{center} \href{
../../../../
demo_drivers/unsteady_heat/two_d_unsteady_heat_adapt/two_d_unsteady_heat_adapt.cc
}{\texttt{ demo\+\_\+drivers/unsteady\+\_\+heat/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+adapt/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+adapt.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{\texorpdfstring{PDF file}{PDF file}}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
