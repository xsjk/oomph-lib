\chapter{Example problem\+: Spatially adaptive solution of the 2D unsteady heat equation with flux boundary conditions in a moving domain\+: ALE methods.}
\hypertarget{index}{}\label{index}\index{Example problem: Spatially adaptive solution of the 2D unsteady heat equation with flux boundary conditions in a moving domain: ALE methods.@{Example problem: Spatially adaptive solution of the 2D unsteady heat equation with flux boundary conditions in a moving domain: ALE methods.}}
In this example we consider the solution of the unsteady heat equation in a domain with moving boundaries. We demonstrate that the presence of moving boundaries only requires trivial changes to driver codes for corresponding fixed-\/mesh computations.

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{The two-\/dimensional unsteady heat equation with flux boundary conditions in a moving domain.}} \end{center}  Solve  \[
\sum_{i=1}^2\frac{\partial^2 u}{\partial x_i^2} 
= \frac{\partial u}{\partial t} + f\left(x_1,x_2,t\right),
 \ \ \ \ \ \ \ \ \ \ (1)
\] in the domain $ D $ , bounded by the coordinate axes and the time-\/dependent ellipse  \[
\mathbf{r}_{ellipse}(\xi,t) = 
\left(
\begin{array}{c}
\big( a+\hat{a}\sin(2\pi t/\hat{T}) \big) \cos(\xi) \\
\big( b+\hat{b}\sin(2\pi t/\hat{T}) \big) \sin(\xi)
\end{array}
\right),
 \ \ \ \ \ \ \ \ \ \ (2)
\] subject to Neumann boundary conditions,  \[
\left. \frac{\partial u}{\partial n}\right|_{\partial D_{Neumann}}=
- \left. \frac{\partial u}{\partial x_2}\right|_{\partial D_{Neumann}}=
g_0, 
\ \ \ \ \ \ \ \ \ \ (3)
\] along the horizontal domain boundary $ \partial D_{Neumann} = 
\{ (x_1,x_2) | x_1 \in [0,1], x_2=0 \} $ , and to Dirichlet boundary conditions,  \[
\left. u\right|_{\partial D_{Dirichlet}}=h_0, 
\ \ \ \ \ \ \ \ \ \ (4)
\] elsewhere.  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{domain}
\doxyfigcaption{Sketch of the time-\/dependent domain and the boundary conditions. }
\end{DoxyImage}
 The initial conditions are given by  \[
u(x_1,x_2,t=0)=k_0(x_1,x_2),
\ \ \ \ \ \ \ \ \ \ (5)
\] where the functions $ f, g_0, \ h_0 $ and $ k_0 $ are given.   \\\cline{1-1}
\end{longtabu}
~\newline
 \end{center} 

We choose the functions $ f, g_0, \ h_0 $ and $ k_0 $ so that  \[
u_0(x_1,x_2,t) = \tanh\bigg[ 1-\alpha\bigg( \tan\Phi
\big(x_1-\beta\tanh[ \gamma\cos\left(2\pi
t\right)]\big)- x_2\bigg)\bigg]
 \ \ \ \ \ \ \ \ \ \ (6)
\] is the exact solution.

The solution represents the "{}usual"{} tanh profile, whose steepness is controlled by the parameter $ \alpha $ so that for $ \alpha
\gg 1 $ the solution approaches a step. The step is oriented at an angle $ \Phi $ against the $ x_1- $ axis and its position varies periodically. The parameter $ \beta $ controls the amplitude of the step\textquotesingle{}s lateral displacement, while $ \gamma $ determines the rate at which its position changes. For $ \gamma \gg 1 $ , the step remains stationary for most of the period and then translates rapidly parallel to the $ x_1- $ axis, making this a very challenging problem.

The figure below shows a snapshot of the \href{../figures/step_soln.avi}{\texttt{ animated solution}}, obtained from the spatially adaptive simulation discussed below, for the parameter values $ \alpha=10, \ 
\Phi=45^o, \ \beta=-0.3, \ \gamma=5. $

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{step_soln}
\doxyfigcaption{Snapshot of the solution. }
\end{DoxyImage}


The mesh adaptation in response to the translation of the step can be seen more clearly in this contour plot, taken from \href{../figures/unsteady_heat_contour.avi}{\texttt{ another animation of the solution}}.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{unsteady_heat_contour}
\doxyfigcaption{Contour plot of the solution. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_ale}{}\doxysection{\texorpdfstring{Background\+: ALE methods and the evaluation of time-\/derivatives in moving domains}{Background: ALE methods and the evaluation of time-derivatives in moving domains}}\label{index_ale}
{\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Unsteady\+Heat\+Equations}, the equation class that forms the basis for the isoparametric {\ttfamily QUnsteady\+Heat\+Elements}, is based on the Arbitrary Lagrangian Eulerian (ALE) formulation of the weak form of the governing PDE, (1). Within each element, the solution is represented by interpolation between the element\textquotesingle{}s $ N_{node}^{(E)} $ nodal values $ U_j^{(E)}(t) \ 
(i=1,..., N_{node}^{(E)})$ , i.\+e.  \[
u = \sum_{j=1}^{N_{node}^{(E)}} U_j^{(E)}(t) \  \psi_{j}(s_1,s_2),
\ \ \ \ \ \ \ \ \ \ (7)
\] where $ s_1 $ and $ s_2 $ are the element\textquotesingle{}s two local coordinates. The mapping between the local and global (Eulerian) coordinates is based on the interpolation between the nodal coordinates,  \[
x_i(s_1,s_2) = \sum_{j=1}^{N_{node}^{(E)}} X_{ij}^{(E)}(t) \  
\psi_{j}(s_1,s_2),
\ \ \ \ (i=1,2) \ \ \ \ \ \  (8)
\] where $ X_{ij}^{(E)}(t) $ is the i-\/th global (Eulerian) coordinate of node j in the element. In moving-\/domain problems, where the nodal positions vary as function of time, the time-\/derivative of the nodal value, $ dU_j(t)/dt $ , represents the rate-\/of-\/change of $ u $ at the moving node, rather than the time-\/derivative of $ u $ at a fixed Eulerian position, ~\newline
 $ \partial u/\partial t, $ the quantity required in the PDE, (1).

The rate of change of $ u $ at a moving node, $ dU_j(t)/dt $ , may also be expressed by the material derivative,  \[
\left. \frac{D u}{Dt}\right|_{\mbox{\small node} \ j} =  
\frac{\partial u}{\partial t}
+ \sum_{i=1}^2 v_{ij} \ \frac{\partial u}{\partial x_i}
\] where  \[
v_{ij} =  \frac{dX_{ij}^{(E)}}{dt}
\] is the i-\/th velocity component of node j, often referred to as the "{}mesh velocity"{}. The rate of change of $ u $ , experienced at the (fixed) spatial position that coincides with the current position of node j is therefore given by  \[
\frac{\partial u}{\partial t} =
\frac{d U_j^{(E)}}{dt}
- \sum_{i=1}^2 
\left( 
\frac{dX_{ij}^{(E)}}{dt}
\ \sum_{k=1}^{N_{node}^{(E)}} U_k^{(E)} \
\frac{\partial \psi_{k}}{\partial x_i}
\right) .
\] This is the form in which the time-\/derivative in (1) is implemented in {\ttfamily oomph-\/lib\textquotesingle{}s} unsteady heat elements. The mesh velocity is determined automatically, using the {\ttfamily Node\textquotesingle{}s} positional {\ttfamily Time\+Stepper} and the history values of the nodal positions. \mbox{[}By default, the positional {\ttfamily Time\+Stepper} is the same as the {\ttfamily Time\+Stepper} used for the evaluation of the time-\/derivatives of the nodal values; a different one may be assigned with the access function {\ttfamily Node\+::position\+\_\+time\+\_\+stepper\+\_\+pt()}.\mbox{]} This is why it is important to initialise the "{}previous nodal positions"{} in computations on fixed meshes, as demonstrated in the \href{../../two_d_unsteady_heat/html/index.html}{\texttt{ exercise in our earlier example\+:}} The previous nodal positions are initialised to zero when a {\ttfamily Node} is first created. Therefore, if the previous positions are not overwritten with the actual nodal positions, the positional {\ttfamily Time\+Stepper} would compute non-\/zero mesh velocities, even though the {\ttfamily Nodes} are stationary.

{\ttfamily oomph-\/lib\textquotesingle{}s} unsteady Newton solvers automatically advance the time-\/history of the nodal positions when computing a new timestep. Performing computations on moving meshes is therefore extremely straightforward\+: The only task to be performed by the "{}user"{} is to update the nodal positions before a new timestep is taken. This is best done in the function {\ttfamily Problem\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep()}.

The update of the nodal positions may be performed "{}manually"{}, by assigning new nodal positions directly, using the function {\ttfamily Node\+::x(...)}. However, in most cases, the deformation of the domain will be driven by the motion of its boundaries. We discussed in an \href{../../../poisson/fish_poisson2/html/index.html}{\texttt{ earlier example,}} that in {\ttfamily oomph-\/lib} curvilinear, moving boundaries are typically represented by (time-\/dependent) {\ttfamily Geom\+Objects} which define the {\ttfamily Macro\+Element} boundaries of the {\ttfamily Domain} object associated with the {\ttfamily Mesh}. In this case, the update of the nodal positions may be performed by updating the parameters that control the shape of the {\ttfamily Geom\+Object} and calling the {\ttfamily Mesh\textquotesingle{}s} node-\/update function {\ttfamily Mesh\+::node\+\_\+update()}, as illustrated in the \href{../../../poisson/fish_poisson2/html/index.html}{\texttt{ earlier example.}}

It is also possible (and, in fact, much easier) to include the time-\/dependence of the domain boundaries into the definition of the {\ttfamily Geom\+Object}, by making its shape, described by {\ttfamily Geom\+Object\+::position(...)}, a function of time. In that case, the update of the nodal positions in response to the boundary motion merely requires a call to {\ttfamily Mesh\+::node\+\_\+update()} in {\ttfamily Problem\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep()}. This is the approach we take in the present problem.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_namespace}{}\doxysection{\texorpdfstring{Global parameters and functions}{Global parameters and functions}}\label{index_namespace}
As usual, we store the problem parameters in a namespace, {\ttfamily \doxylink{namespaceTanhSolnForUnsteadyHeat}{Tanh\+Soln\+For\+Unsteady\+Heat}}, in which we also specify the source function, the prescribed flux along the Neumann boundary and the exact solution. The namespace is identical to that used in \href{../../two_d_unsteady_heat/html/index.html}{\texttt{ the fixed domain example.}}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_ellipse}{}\doxysection{\texorpdfstring{Representing the moving curvilinear domain boundary by a time-\/dependent Geom\+Object}{Representing the moving curvilinear domain boundary by a time-dependent GeomObject}}\label{index_ellipse}
As discussed above, we will incorporate the time-\/dependence of the moving curvilinear boundary into the specification of the {\ttfamily Geom\+Object} that defines that boundary. For this purpose we represent the elliptical boundary by the {\ttfamily Geom\+Object} {\ttfamily \doxylink{classMyEllipse}{My\+Ellipse}}. Its constructor stores the geometric parameters (the mean values of the ellipse\textquotesingle{}s half axes, $ a $ and $ b $ , the amplitude of their temporal variations $ \hat{a} $ and $ \hat{b} $ , and the period of the oscillation, $ \hat{T} $ , in its private member data. We also store a pointer to a {\ttfamily Time} object to give the {\ttfamily Geom\+Object} access to the "{}current"{} and "{}previous"{} values of the "{}continuous time"{}. The destructor can remain empty.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_MyEllipse===========================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Oscillating\ ellipse}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ \(\backslash\)f[\ x\ =\ (a\ +\ \(\backslash\)widehat\{a\}\ \(\backslash\)sin(2\(\backslash\)Pi\ t/T))\ \(\backslash\)cos(\(\backslash\)xi)\ \ \(\backslash\)f]}}
\DoxyCodeLine{\textcolor{comment}{///\ \(\backslash\)f[\ y\ =\ (b\ +\ \(\backslash\)widehat\{b\}\ \(\backslash\)sin(2\(\backslash\)Pi\ t/T))\ \(\backslash\)sin(\(\backslash\)xi)\ \ \(\backslash\)f]}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//=========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{class\ }\mbox{\hyperlink{classMyEllipse}{MyEllipse}}\ :\ \textcolor{keyword}{public}\ GeomObject}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Constructor:\ \ Pass\ half\ axes,\ amplitudes\ of\ their\ variation,\ period}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ of\ oscillation\ and\ pointer\ to\ time\ object.}}
\DoxyCodeLine{\textcolor{comment}{}\ \mbox{\hyperlink{classMyEllipse}{MyEllipse}}(\textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ a,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ b,\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ a\_hat,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ b\_hat,\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\&\ period,\ Time*\ time\_pt)\ :\ }
\DoxyCodeLine{\ \ GeomObject(1,2),\ \mbox{\hyperlink{classMyEllipse_aa2a0efd0a39f9d4fc307a6ff011682ed}{A}}(a),\ \mbox{\hyperlink{classMyEllipse_a8f991996b9040fe94b942eab7e51f0af}{B}}(b),\ \mbox{\hyperlink{classMyEllipse_a653e71cf296cdc86cc595d16f18004dd}{A\_hat}}(a\_hat),\ \mbox{\hyperlink{classMyEllipse_a39d06488447d80f16b80ed8915edf3e3}{B\_hat}}(b\_hat),\ }
\DoxyCodeLine{\ \ \mbox{\hyperlink{classMyEllipse_ab098069ab23bbbd8f30b0da3523dc87f}{T}}(period),\ \mbox{\hyperlink{classMyEllipse_abc1c4c863a599ce87bdff1abb9971953}{Time\_pt}}(time\_pt)\ \{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Destructor:\ Empty}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keyword}{virtual}\ \mbox{\hyperlink{classMyEllipse_ac2f2d3fb269c57fb26b4db6d9a0c7c05}{\string~MyEllipse}}()\ \{\}}

\end{DoxyCodeInclude}
 The "{}steady"{} version of the {\ttfamily position(...)} function must return the position vector to the point on the {\ttfamily Geom\+Object}, identified by its intrinsic coordinate {\ttfamily xi}, and evaluated at the current value of the continuous time, which we extract from {\ttfamily Time\+::time()}\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Current\ position\ vector\ to\ material\ point\ at\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Lagrangian\ coordinate\ xi\ }}
\DoxyCodeLine{\ \textcolor{keywordtype}{void}\ position(\textcolor{keyword}{const}\ Vector<double>\&\ xi,\ Vector<double>\&\ r)\textcolor{keyword}{\ const}}
\DoxyCodeLine{\textcolor{keyword}{\ \ }\{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Get\ current\ time:}}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{double}\ time=Time\_pt-\/>time();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Position\ vector}}
\DoxyCodeLine{\ \ \ r[0]\ =\ (A+A\_hat*sin(2.0*MathematicalConstants::Pi*time/T))*cos(xi[0]);}
\DoxyCodeLine{\ \ \ r[1]\ =\ (B+B\_hat*sin(2.0*MathematicalConstants::Pi*time/T))*sin(xi[0]);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \}\ \textcolor{comment}{//\ end\ of\ position(...)}}

\end{DoxyCodeInclude}


The "{}time-\/dependent"{} version of the {\ttfamily position(...)} function must return the position vector to the {\ttfamily Geom\+Object}, evaluated at the {\ttfamily t} -\/ th previous timestep. The value of the continuous time at that timestep is available from from {\ttfamily Time\+::time(t)}\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Parametrised\ position\ on\ object:\ r(xi).\ Evaluated\ at}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ previous\ time\ level.\ t=0:\ current\ time;\ t>0:\ previous}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ time\ level.}}
\DoxyCodeLine{\textcolor{comment}{}\ \textcolor{keywordtype}{void}\ position(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\&\ t,\ \textcolor{keyword}{const}\ Vector<double>\&\ xi,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Vector<double>\&\ r)\textcolor{keyword}{\ const}}
\DoxyCodeLine{\textcolor{keyword}{\ \ }\{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Get\ current\ time:}}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{double}\ time=Time\_pt-\/>time(t);}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Position\ vector}}
\DoxyCodeLine{\ \ \ r[0]\ =\ (A+A\_hat*sin(2.0*MathematicalConstants::Pi*time/T))*cos(xi[0]);}
\DoxyCodeLine{\ \ \ r[1]\ =\ (B+B\_hat*sin(2.0*MathematicalConstants::Pi*time/T))*sin(xi[0]);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \}\ \textcolor{comment}{//\ end\ of\ position(...)}}

\end{DoxyCodeInclude}
 We omit the code that defines the private member data.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysection{\texorpdfstring{The main function}{The main function}}\label{index_main}
Since the deformation of the domain and the update of the nodal positions will be handled automatically by adding a call to {\ttfamily Mesh\+::node\+\_\+update()} to {\ttfamily Problem\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep()}, the driver code for this problem is exactly the same as that in the \href{../../two_d_unsteady_heat_adapt/html/index.html}{\texttt{ previous example in a fixed domain. }}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_problem_class}{}\doxysection{\texorpdfstring{The Problem class}{The Problem class}}\label{index_problem_class}
The {\ttfamily Problem} class and most of its member functions are exactly the same as in the \href{../../two_d_unsteady_heat/html/index.html}{\texttt{ previous example.}}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysection{\texorpdfstring{The Problem constructor}{The Problem constructor}}\label{index_constructor}
The {\ttfamily Problem} constructor is identical to the fixed-\/mesh version in the \href{../../two_d_unsteady_heat/html/index.html}{\texttt{ previous example,}} apart from the fact that we use the {\ttfamily \doxylink{classMyEllipse}{My\+Ellipse}} {\ttfamily Geom\+Object} to define the curvilinear {\ttfamily Mesh} boundary. Here is the relevant code fragment\+:

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Setup\ mesh}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Build\ geometric\ object\ that\ forms\ the\ curvilinear\ domain\ boundary:}}
\DoxyCodeLine{\ \textcolor{comment}{//\ an\ oscillating\ ellipse}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Half\ axes}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ a=1.0;}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ b=1.0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Variations\ of\ half\ axes}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ a\_hat=\ 0.1;}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ b\_hat=-\/0.1;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Period\ of\ the\ oscillation}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ period=1.0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Create\ GeomObject}}
\DoxyCodeLine{\ Boundary\_pt=\textcolor{keyword}{new}\ \mbox{\hyperlink{classMyEllipse}{MyEllipse}}(a,b,a\_hat,b\_hat,period,Problem::time\_pt());\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Start\ and\ end\ coordinates\ of\ curvilinear\ domain\ boundary\ on\ ellipse}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ xi\_lo=0.0;}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ xi\_hi=MathematicalConstants::Pi/2.0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Now\ create\ the\ bulk\ mesh.\ Separating\ line\ between\ the\ two\ }}
\DoxyCodeLine{\ \textcolor{comment}{//\ elements\ next\ to\ the\ curvilinear\ boundary\ is\ located\ half-\/way}}
\DoxyCodeLine{\ \textcolor{comment}{//\ along\ the\ boundary.}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ fract\_mid=0.5;}
\DoxyCodeLine{\ Bulk\_mesh\_pt\ =\ \textcolor{keyword}{new}\ RefineableQuarterCircleSectorMesh<ELEMENT>(}
\DoxyCodeLine{\ \ Boundary\_pt,xi\_lo,fract\_mid,xi\_hi,time\_stepper\_pt());}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_actions_before_implicit_timestep}{}\doxysection{\texorpdfstring{Actions before timestep}{Actions before timestep}}\label{index_actions_before_implicit_timestep}
As discussed above, the addition of a single line to {\ttfamily Problem\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep()} suffices to update the nodal positions in response to the changes in the domain boundary.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=========start\ of\ actions\_before\_implicit\_timestep===============================}}
\DoxyCodeLine{\textcolor{comment}{///\ Actions\ before\ timestep:\ Update\ the\ domain\ shape,\ then\ set\ the\ }\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{///\ boundary\ conditions\ for\ the\ current\ time.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_ac754f1313cd6d684c149443beb5bcf9e}{RefineableUnsteadyHeatProblem<ELEMENT>::actions\_before\_implicit\_timestep}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Update\ the\ domain\ shape}}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>node\_update();}

\end{DoxyCodeInclude}
 The rest of this function is identical to the that in the \href{../../two_d_unsteady_heat/html/index.html}{\texttt{ fixed-\/domain version}} and updates the nodal values on the Dirichlet boundaries according to the values given by the exact solution.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_set_init}{}\doxysection{\texorpdfstring{Setting the initial condition}{Setting the initial condition}}\label{index_set_init}
The only other change to the code occurs in the assignment of the initial conditions. The {\ttfamily Nodes\textquotesingle{}} positional history values are given by the positions at which the {\ttfamily Nodes} would have been at previous timesteps. Similarly, the history values themselves must be computed by evaluating the exact solution at the position at which the {\ttfamily Nodes} would have been at those timesteps.

This is achieved with a few minor changes to the previous version of this function. We loop over the previous timesteps, reconstruct the value of the continuous time at that timestep, and temporarily over-\/write the value of the continuous time stored in {\ttfamily Time\+::time()}. This ensures that the call to {\ttfamily My\+Ellipse\+::position(...)} during the node update operation returns the position vector to the domain boundary at that timestep. Following the update of the nodal positions (which moves them into the position they would have occupied at the previous timestep) we copy their positions and the value of the exact solution into the appropriate history values. Here is the relevant code fragment from the {\ttfamily set\+\_\+initial\+\_\+condition()} function\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Loop\ over\ current\ \&\ previous\ timesteps\ (in\ outer\ loop\ because}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ the\ mesh\ also\ moves!)}}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ itime=nprev\_steps;itime>=0;itime-\/-\/)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \textcolor{keywordtype}{double}\ time=prev\_time[itime];}
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ Set\ global\ time\ (because\ this\ is\ how\ the\ geometric\ object\ refers\ }}
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ to\ continous\ time\ }}
\DoxyCodeLine{\ \ \ \ \ time\_pt()-\/>time()=time;}
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ cout\ <<\ \textcolor{stringliteral}{"{}setting\ IC\ at\ time\ ="{}}\ <<\ time\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ Update\ the\ mesh\ for\ this\ value\ of\ the\ continuous\ time}}
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ (The\ wall\ object\ reads\ the\ continous\ time\ from\ the\ same}}
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ global\ time\ object)}}
\DoxyCodeLine{\ \ \ \ \ Bulk\_mesh\_pt-\/>node\_update();\ }
\DoxyCodeLine{\ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//\ Loop\ over\ the\ nodes\ to\ set\ initial\ guess\ everywhere}}
\DoxyCodeLine{\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ jnod=0;jnod<num\_nod;jnod++)}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ nodal\ coordinates}}
\DoxyCodeLine{\ \ \ \ \ \ \ x[0]=Bulk\_mesh\_pt-\/>node\_pt(jnod)-\/>x(0);}
\DoxyCodeLine{\ \ \ \ \ \ \ x[1]=Bulk\_mesh\_pt-\/>node\_pt(jnod)-\/>x(1);}
\DoxyCodeLine{\ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ intial\ solution}}
\DoxyCodeLine{\ \ \ \ \ \ \ \mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat_a36857bbdec45f44018772de70558db7d}{TanhSolnForUnsteadyHeat::get\_exact\_u}}(time,x,soln);}
\DoxyCodeLine{\ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{comment}{//\ Assign\ solution}}
\DoxyCodeLine{\ \ \ \ \ \ \ Bulk\_mesh\_pt-\/>node\_pt(jnod)-\/>set\_value(itime,0,soln[0]);}
\DoxyCodeLine{\ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{comment}{//\ Loop\ over\ coordinate\ directions}}
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ i=0;i<2;i++)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ Bulk\_mesh\_pt-\/>node\_pt(jnod)-\/>x(itime,i)=x[i];}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \}\ }
\DoxyCodeLine{\ \ \ \ \}\ \textcolor{comment}{//\ end\ of\ loop\ over\ previous\ timesteps}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comm}{}\doxysection{\texorpdfstring{Comments and Exercises}{Comments and Exercises}}\label{index_comm}
While the spatial adaptivity resolves the rapid spatial variations in the solution, the time-\/integration with a fixed timestep introduces errors during the phases when the solution undergoes rapid temporal variations. The \href{../figures/step_soln.avi}{\texttt{ animations}} of the exact and computed solutions show clearly that the computed solution lags behind the exact one during these phases. In the \href{../../two_d_unsteady_heat_2adapt/html/index.html}{\texttt{ next example}} we will therefore demonstrate how to combine temporal and spatial adaptivity.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{\texorpdfstring{Source files for this tutorial}{Source files for this tutorial}}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/unsteady_heat/two_d_unsteady_heat_ALE/}{\texttt{ demo\+\_\+drivers/unsteady\+\_\+heat/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+\+ALE/ }} \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/unsteady_heat/two_d_unsteady_heat_ALE/two_d_unsteady_heat_ALE.cc}{\texttt{ demo\+\_\+drivers/unsteady\+\_\+heat/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+\+ALE/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+\+ALE.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{\texorpdfstring{PDF file}{PDF file}}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
