\chapter{Parallel solution of the FSI channel with leaflet problem\+: Distributing problems with algebraic node updates}
\hypertarget{index}{}\label{index}\index{Parallel solution of the FSI channel with leaflet problem: Distributing problems with algebraic node updates@{Parallel solution of the FSI channel with leaflet problem: Distributing problems with algebraic node updates}}
This document provides an overview of how to distribute fluid-\/structure interaction problems in which algebraic node update methods are used to deform the fluid mesh in response to changes in the shape of the domain boundary. It is part of a \href{../../../example_code_list/html/index.html\#distributed}{\texttt{ series of tutorials}} that discuss how to modify existing serial driver codes so that the {\ttfamily Problem} object can be distributed across multiple processors.

As discussed in the \href{../../general_mpi/html/index.html\#alg_node_update}{\texttt{ general MPI tutorial}}, the parallel implementation of algebraic node update methods for specific meshes is greatly facilitated if the {\ttfamily Geom\+Object} that describes the motion of the moving domain boundary is available on all processors. In FSI problems, the moving boundary is typically represented by a {\ttfamily Mesh\+As\+Geom\+Object} -- a compound {\ttfamily Geom\+Object} formed from the lower-\/dimensional mesh of {\ttfamily Solid\+Elements} that define the moving boundary of the fluid domain. To ensure that the {\ttfamily Mesh\+As\+Geom\+Object} remains available on all processors when the underlying mesh is distributed, we use the function {\ttfamily Mesh\+::keep\+\_\+all\+\_\+elements\+\_\+as\+\_\+halos()} to indicate that all elements should be retained on all processors.

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{Note}} \end{center}  The procedure described here is appropriate {\bfseries{only}} if the solid mesh used to create the {\ttfamily Mesh\+As\+Geom\+Object} is {\bfseries{not}} {\bfseries{adapted}} during the solution of the problem. We refer to \href{../../turek_flag/html/index.html}{\texttt{ another tutorial}} for instructions on how to deal with the case when the solid mesh is itself adapted.   \\\cline{1-1}
\end{longtabu}
\end{center} 

\DoxyHorRuler{0}
\hypertarget{index_fsi_channel_with_leaflet}{}\doxysection{\texorpdfstring{Revisiting the FSI channel with leaflet problem}{Revisiting the FSI channel with leaflet problem}}\label{index_fsi_channel_with_leaflet}
We demonstrate the methodology for the problem of \href{../../../interaction/fsi_channel_with_leaflet/html/index.html}{\texttt{ flow past an elastic leaflet in a 2D channel}}. Most of driver code is identical to its serial counterpart and we only discuss the changes required to distribute the problem. Please refer to \href{../../../interaction/fsi_channel_with_leaflet/html/index.html}{\texttt{ another tutorial}} for a more detailed discussion of the problem and its (serial) implementation. ~\newline


\DoxyHorRuler{0}
\hypertarget{index_main_body}{}\doxysubsection{\texorpdfstring{The main function}{The main function}}\label{index_main_body}
As with other parallel driver codes, the changes from the \href{../../../interaction/fsi_channel_with_leaflet/html/index.html}{\texttt{ serial driver code }} are extremely modest, essentially including the initialisation and shutdown of MPI. Once the problem is set up, we call {\ttfamily Problem\+::distribute(...)}, using the boolean flag {\ttfamily report\+\_\+stats} to indicate that the statistics of the distribution should be reported on screen.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Distribute\ problem\ using\ METIS\ to\ determine\ the\ partitioning}}
\DoxyCodeLine{\ \ \ problem.distribute(report\_stats);}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
\hypertarget{index_problem_class}{}\doxysubsection{\texorpdfstring{The problem class}{The problem class}}\label{index_problem_class}
The only additional function is {\ttfamily actions\+\_\+after\+\_\+distribute()}, described \href{\#actions_routines}{\texttt{ later in this tutorial}}.

\DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysubsection{\texorpdfstring{The problem constructor}{The problem constructor}}\label{index_constructor}
The only difference from the serial counterpart is that we ~\newline
 insist that all beam elements are kept as halos when the mesh is distributed.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Discretise\ leaflet}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Geometric\ object\ that\ represents\ the\ undeformed\ leaflet}}
\DoxyCodeLine{\ UndeformedLeaflet*\ undeformed\_wall\_pt=\textcolor{keyword}{new}\ UndeformedLeaflet(x\_0);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//Create\ the\ "{}wall"{}\ mesh\ with\ FSI\ Hermite\ beam\ elements}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ n\_wall\_el=5;}
\DoxyCodeLine{\ Wall\_mesh\_pt\ =\ \textcolor{keyword}{new}\ OneDLagrangianMesh<FSIHermiteBeamElement>}
\DoxyCodeLine{\ \ (n\_wall\_el,hleaflet,undeformed\_wall\_pt,wall\_time\_stepper\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Flag\ to\ tell\ the\ wall\ mesh\ that\ all\ its\ elements\ should\ be\ halo}}
\DoxyCodeLine{\ Wall\_mesh\_pt-\/>set\_keep\_all\_elements\_as\_halos();}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
\hypertarget{index_action_after_adapt}{}\doxysubsection{\texorpdfstring{Actions after adaptation}{Actions after adaptation}}\label{index_action_after_adapt}
The {\ttfamily actions\+\_\+after\+\_\+adapt()} function requires only a minor change from the serial version --- a simple re-\/ordering of the sequence in which the various steps are performed. In serial it does not matter in which order the (re-\/)assignment of the auxiliary node update functions and (re-\/)setup of the fluid-\/structure interaction are performed. In the parallel version, however, the assignment of the auxiliary node update functions must take place {\bfseries{after}} the (re-\/)setup of the fluid-\/structure interaction. This is because the function {\ttfamily FSI\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements(...)} creates halo copies of the fluid elements (and their nodes!) if the required fluid element is not present on the current processor. Any newly-\/created halo fluid nodes on the FSI boundary are accessible via the usual boundary lookup schemes and must be told about the auxiliary node update function which applies the no-\/slip condition.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//====\ start\_of\_actions\_after\_adapt=================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Actions\_after\_adapt()}}
\DoxyCodeLine{\textcolor{comment}{//==================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ FSIChannelWithLeafletProblem<ELEMENT>::actions\_after\_adapt()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Unpin\ all\ pressure\ dofs}}
\DoxyCodeLine{\ RefineableNavierStokesEquations<2>::}
\DoxyCodeLine{\ \ unpin\_all\_pressure\_dofs(Fluid\_mesh\_pt-\/>element\_pt());}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Pin\ redundant\ pressure\ dofs}}
\DoxyCodeLine{\ RefineableNavierStokesEquations<2>::}
\DoxyCodeLine{\ \ pin\_redundant\_nodal\_pressures(Fluid\_mesh\_pt-\/>element\_pt());}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Re-\/setup\ FSI}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Work\ out\ which\ fluid\ dofs\ affect\ the\ residuals\ of\ the\ wall\ elements:}}
\DoxyCodeLine{\ \textcolor{comment}{//\ We\ pass\ the\ boundary\ between\ the\ fluid\ and\ solid\ meshes\ and}}
\DoxyCodeLine{\ \textcolor{comment}{//\ pointers\ to\ the\ meshes.\ The\ interaction\ boundary\ is\ boundary\ 4\ and\ 5}}
\DoxyCodeLine{\ \textcolor{comment}{//\ of\ the\ 2D\ fluid\ mesh.}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Front\ of\ leaflet:\ Set\ face=0\ (which\ is\ also\ the\ default\ so\ this\ argument}}
\DoxyCodeLine{\ \textcolor{comment}{//\ could\ be\ omitted)}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ face=0;}
\DoxyCodeLine{\ FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<ELEMENT,2>}
\DoxyCodeLine{\ \ (\textcolor{keyword}{this},4,Fluid\_mesh\_pt,Wall\_mesh\_pt,face);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Back\ of\ leaflet:\ face\ 1,\ needs\ to\ be\ specified\ explicitly}}
\DoxyCodeLine{\ face=1;}
\DoxyCodeLine{\ FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<ELEMENT,2>}
\DoxyCodeLine{\ \ (\textcolor{keyword}{this},5,Fluid\_mesh\_pt,Wall\_mesh\_pt,face);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ (Re-\/)apply\ the\ no\ slip\ condition\ on\ the\ moving\ wall}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ The\ velocity\ of\ the\ fluid\ nodes\ on\ the\ wall\ (fluid\ mesh\ boundary\ 4,5)}}
\DoxyCodeLine{\ \textcolor{comment}{//\ is\ set\ by\ the\ wall\ motion\ -\/-\/\ hence\ the\ no-\/slip\ condition\ must\ be}}
\DoxyCodeLine{\ \textcolor{comment}{//\ re-\/applied\ whenever\ a\ node\ update\ is\ performed\ for\ these\ nodes.}}
\DoxyCodeLine{\ \textcolor{comment}{//\ Such\ tasks\ may\ be\ performed\ automatically\ by\ the\ auxiliary\ node\ update}}
\DoxyCodeLine{\ \textcolor{comment}{//\ function\ specified\ by\ a\ function\ pointer:}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ ibound=4;ibound<6;ibound++\ )}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{unsigned}\ num\_nod=\ Fluid\_mesh\_pt-\/>nboundary\_node(ibound);}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ Fluid\_mesh\_pt-\/>boundary\_node\_pt(ibound,\ inod)-\/>}
\DoxyCodeLine{\ \ \ \ \ \ set\_auxiliary\_node\_update\_fct\_pt(}
\DoxyCodeLine{\ \ \ \ \ \ \ FSI\_functions::apply\_no\_slip\_on\_moving\_wall);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}\ \textcolor{comment}{//\ aux\ node\ update\ fct\ has\ been\ (re-\/)set}}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\_of\_actions\_after\_adapt}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
\hypertarget{index_action_after_distribution}{}\doxysubsection{\texorpdfstring{Actions after distribution}{Actions after distribution}}\label{index_action_after_distribution}
The actions required after distribution are extremely similar to those required after adaptation because distribution deletes certain elements (or replaces them by halo copies). The only difference is that the redundant pressure degrees of freedom do not have to be re-\/pinned.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//====\ start\_of\_actions\_after\_distribute============================}}
\DoxyCodeLine{\textcolor{comment}{///\ Actions\_after\_distribute()}}
\DoxyCodeLine{\textcolor{comment}{//==================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ FSIChannelWithLeafletProblem<ELEMENT>::actions\_after\_distribute()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Re-\/setup\ FSI}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Work\ out\ which\ fluid\ dofs\ affect\ the\ residuals\ of\ the\ wall\ elements:}}
\DoxyCodeLine{\ \textcolor{comment}{//\ We\ pass\ the\ boundary\ between\ the\ fluid\ and\ solid\ meshes\ and}}
\DoxyCodeLine{\ \textcolor{comment}{//\ pointers\ to\ the\ meshes.\ The\ interaction\ boundary\ is\ boundary\ 4\ and\ 5}}
\DoxyCodeLine{\ \textcolor{comment}{//\ of\ the\ 2D\ fluid\ mesh.}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Front\ of\ leaflet:\ Set\ face=0\ (which\ is\ also\ the\ default\ so\ this\ argument}}
\DoxyCodeLine{\ \textcolor{comment}{//\ could\ be\ omitted)}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ face=0;}
\DoxyCodeLine{\ FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<ELEMENT,2>}
\DoxyCodeLine{\ \ (\textcolor{keyword}{this},4,Fluid\_mesh\_pt,Wall\_mesh\_pt,face);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Back\ of\ leaflet:\ face\ 1,\ needs\ to\ be\ specified\ explicitly}}
\DoxyCodeLine{\ face=1;}
\DoxyCodeLine{\ FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<ELEMENT,2>}
\DoxyCodeLine{\ \ (\textcolor{keyword}{this},5,Fluid\_mesh\_pt,Wall\_mesh\_pt,face);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ (Re-\/)apply\ the\ no\ slip\ condition\ on\ the\ moving\ wall}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ The\ velocity\ of\ the\ fluid\ nodes\ on\ the\ wall\ (fluid\ mesh\ boundary\ 4,5)}}
\DoxyCodeLine{\ \textcolor{comment}{//\ is\ set\ by\ the\ wall\ motion\ -\/-\/\ hence\ the\ no-\/slip\ condition\ must\ be}}
\DoxyCodeLine{\ \textcolor{comment}{//\ re-\/applied\ whenever\ a\ node\ update\ is\ performed\ for\ these\ nodes.}}
\DoxyCodeLine{\ \textcolor{comment}{//\ Such\ tasks\ may\ be\ performed\ automatically\ by\ the\ auxiliary\ node\ update}}
\DoxyCodeLine{\ \textcolor{comment}{//\ function\ specified\ by\ a\ function\ pointer:}}
\DoxyCodeLine{\ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}\ ibound=4;ibound<6;ibound++\ )}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \textcolor{keywordtype}{unsigned}\ num\_nod=\ Fluid\_mesh\_pt-\/>nboundary\_node(ibound);}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ Fluid\_mesh\_pt-\/>boundary\_node\_pt(ibound,\ inod)-\/>}
\DoxyCodeLine{\ \ \ \ \ \ set\_auxiliary\_node\_update\_fct\_pt(}
\DoxyCodeLine{\ \ \ \ \ \ \ FSI\_functions::apply\_no\_slip\_on\_moving\_wall);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}\ \textcolor{comment}{//\ aux\ node\ update\ fct\ has\ been\ (re-\/)set}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\_of\_actions\_after\_distribute}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
\hypertarget{index_doc_solution}{}\doxysubsection{\texorpdfstring{The doc\+\_\+solution() function}{The doc\_solution() function}}\label{index_doc_solution}
As usual, we add the processor number to the end of the filename for each output file to make sure that the different processors don\textquotesingle{}t over-\/write each other\textquotesingle{}s output.

The trace file documents the time trace of the imposed influx and the displacement of the node at the tip of the leaflet. It could be written by any processor since all solid elements are retained everywhere. We only write to the trace file from processor 0.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \textcolor{comment}{//\ Write\ trace\ file\ (only\ on\ processor\ 0)\ -\/-\/\ Tip\ node\ exists\ on}}
\DoxyCodeLine{\ \textcolor{comment}{//\ every\ processor\ (because\ all\ wall\ elements\ are\ kept\ as\ halos)}}
\DoxyCodeLine{\ \textcolor{comment}{//\ but\ we\ don't\ want\ different\ processors\ to\ overwrite\ (or\ replicate)}}
\DoxyCodeLine{\ \textcolor{comment}{//\ the\ trace\ file.}}
\DoxyCodeLine{\ \textcolor{keywordflow}{if}\ (this-\/>communicator\_pt()-\/>my\_rank()==0)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ trace\ <<\ time\ <<\ \textcolor{stringliteral}{"{}\ "{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ <<\ Global\_Physical\_Variables::flux(time)\ <<\ \textcolor{stringliteral}{"{}\ "{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ <<\ tip\_node\_pt-\/>x(0)\ <<\ \textcolor{stringliteral}{"{}\ "{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ <<\ tip\_node\_pt-\/>x(1)\ <<\ \textcolor{stringliteral}{"{}\ "{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ <<\ tip\_node\_pt-\/>dposition\_dt(0)\ <<\ \textcolor{stringliteral}{"{}\ "{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ <<\ tip\_node\_pt-\/>dposition\_dt(1)\ <<\ \textcolor{stringliteral}{"{}\ "{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ <<\ doc\_info.number()\ <<\ \textcolor{stringliteral}{"{}\ "{}}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ <<\ std::endl;}
\DoxyCodeLine{\ \ \}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{\texorpdfstring{Source files for this tutorial}{Source files for this tutorial}}\label{index_sources}
The source files for this tutorial can be found in

\begin{center} \href{../../../../demo_drivers/mpi/multi_domain/fsi_channel_with_leaflet}{\texttt{ demo\+\_\+drivers/mpi/multi\+\_\+domain/fsi\+\_\+channel\+\_\+with\+\_\+leaflet }} \end{center} 

Similar examples of modified driver codes for FSI problems for a channel with a collapsible wall and an oscillating ring can be found in \begin{center} \href{../../../../demo_drivers/mpi/multi_domain/}{\texttt{ demo\+\_\+drivers/mpi/multi\+\_\+domain }} \end{center} 

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{\texorpdfstring{PDF file}{PDF file}}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
