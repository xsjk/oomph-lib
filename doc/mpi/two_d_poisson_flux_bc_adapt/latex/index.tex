\chapter{Parallel solution of a 2D Poisson problem with flux boundary conditions}
\hypertarget{index}{}\label{index}\index{Parallel solution of a 2D Poisson problem with flux boundary conditions@{Parallel solution of a 2D Poisson problem with flux boundary conditions}}
This document provides an overview of how to distribute the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\texttt{ 2D Poisson problem with flux boundary conditions}}. It is part of a \href{../../../example_code_list/html/index.html\#distributed}{\texttt{ series of tutorials}} that discuss how to modify existing serial driver codes so that the {\ttfamily Problem} object can be distributed across multiple processors.

A feature of this problem is that the flux boundary conditions are applied by attaching "{}flux elements"{} (derived from the {\ttfamily Face\+Element} base class) to the "{}bulk elements"{} adjacent to the appropriate mesh boundary. As discussed in the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\texttt{ tutorial for the serial driver code}}, the {\ttfamily Face\+Elements} are not involved in any adaptation within the bulk mesh. Instead, they are detached before the bulk mesh is adapted and re-\/attached afterwards, which ensures that the {\ttfamily Face\+Elements} are only attached to bulk elements present in the adapted mesh.

The same issue arises when the {\ttfamily Problem} is distributed\+: all {\ttfamily Face\+Elements} must be attached before the problem is distributed to allow {\ttfamily METIS} to analyse the interaction between face and bulk elements correctly. However, after the {\ttfamily Problem} has been distributed, some of the bulk elements on each processor will have been deleted, leaving the corresponding {\ttfamily Face\+Element} dangling. To deal with such problems, {\ttfamily oomph-\/lib} provides the empty virtual functions


\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_before\_distribute()\ }

\end{DoxyCode}


and


\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_after\_distribute()\ }

\end{DoxyCode}


which are called automatically by {\ttfamily Problem\+::distribute(...)}. Specifically, {\ttfamily Problem\+::actions\+\_\+before\+\_\+distribute()} is called {\bfseries{after}} the problem distribution has been determined by {\ttfamily METIS} but {\bfseries{before}} the actual distribution (during which elements are deleted) takes place. {\ttfamily Problem\+::actions\+\_\+after\+\_\+distribute()} is called after the problem distribution is complete.

In the present problem we overload the functions {\ttfamily Problem\+::actions\+\_\+before\+\_\+distribute()} and {\ttfamily Problem\+::actions\+\_\+after\+\_\+distribute()} to perform the same functions as {\ttfamily actions\+\_\+before\+\_\+adapt()} (i.\+e. delete the flux elements) and {\ttfamily actions\+\_\+after\+\_\+adapt()} (i.\+e. re-\/attach the flux elements). ~\newline
 We note that any {\ttfamily Face\+Element} that is attached to a halo element in the bulk mesh becomes a halo element itself; see the \href{../../general_mpi/html/index.html\#face_elements}{\texttt{ general MPI tutorial}} for further details.

Most of driver code is identical to its serial counterpart and we only discuss the changes required to distribute the problem. Please refer to \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\texttt{ another tutorial}} for a more detailed discussion of the problem and its (serial) implementation.

\DoxyHorRuler{0}
\hypertarget{index_main_body}{}\doxysection{\texorpdfstring{The main function}{The main function}}\label{index_main_body}
The only changes required to the main function are the usual calls to initialise and finalise {\ttfamily oomph-\/lib\textquotesingle{}s} MPI routines and a single call to {\ttfamily Problem\+::distribute()} after the problem has been constructed. The source code is actually slightly more complicated because the distribution is read in from a file so that the driver can be used as a self-\/test. Note that the file must specify the partition for {\bfseries{all}} elements, including the {\ttfamily Face\+Elements}. (We refer to \href{../../adaptive_driven_cavity/html/index.html\#no_disk}{\texttt{ another tutorial}} for details on how to create the distribution file.)

\DoxyHorRuler{0}
\hypertarget{index_problem_class}{}\doxysection{\texorpdfstring{The problem class}{The problem class}}\label{index_problem_class}
The only additions to the problem class are the functions {\ttfamily actions\+\_\+before\+\_\+distribute()} and {\ttfamily actions\+\_\+after\+\_\+distribute()}. As explained above, these perform exactly the same functions as {\ttfamily actions\+\_\+before\+\_\+adapt()} and {\ttfamily actions\+\_\+after\+\_\+adapt()}, respectively.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Actions\ before\ distribute:\ Wipe\ the\ mesh\ of\ prescribed\ flux\ elements}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ (simply\ call\ actions\_before\_adapt()\ which\ does\ the\ same\ thing)}}
\DoxyCodeLine{\ \textcolor{keywordtype}{void}\ actions\_before\_distribute()}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ actions\_before\_adapt();}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\textcolor{comment}{\ ///\ Actions\ after\ distribute:\ Rebuild\ the\ mesh\ of\ prescribed\ flux\ }}
\DoxyCodeLine{\textcolor{comment}{\ ///\ elements\ (simply\ call\ actions\_after\_adapt()\ which\ does\ the\ same\ thing)}}
\DoxyCodeLine{\ \textcolor{keywordtype}{void}\ actions\_after\_distribute()}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ actions\_after\_adapt();}
\DoxyCodeLine{\ \ \}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
\hypertarget{index_doc_solution}{}\doxysection{\texorpdfstring{The doc\+\_\+solution() function}{The doc\_solution() function}}\label{index_doc_solution}
As with other driver codes, the output files are modified to allow each processor to output its elements into files that include the processor number.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====================start\_of\_doc=======================================}}
\DoxyCodeLine{\textcolor{comment}{///\ Doc\ the\ solution:\ doc\_info\ contains\ labels/output\ directory\ etc.}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class}\ ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ RefineableTwoMeshFluxPoissonProblem<ELEMENT>::doc\_solution(DocInfo\&\ doc\_info)}
\DoxyCodeLine{\{\ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Doc\ refinement\ levels\ in\ bulk\ mesh}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ min\_refinement\_level;}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ max\_refinement\_level;}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>get\_refinement\_levels(min\_refinement\_level,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ max\_refinement\_level);\ }
\DoxyCodeLine{\ cout\ <<\ \textcolor{stringliteral}{"{}Ultimate\ min/max.\ refinement\ levels\ in\ bulk\ mesh\ :\ "{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ <<\ min\_refinement\_level\ <<\ \textcolor{stringliteral}{"{}\ "{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ <<\ max\_refinement\_level\ <<\ std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ ofstream\ some\_file;}
\DoxyCodeLine{\ \textcolor{keywordtype}{char}\ filename[100];}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Number\ of\ plot\ points}}
\DoxyCodeLine{\ \textcolor{keywordtype}{unsigned}\ npts;}
\DoxyCodeLine{\ npts=5;\ }
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Output\ solution\ with\ halo\ elements\ }}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>enable\_output\_of\_halo\_elements();}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/soln\_with\_halo\%i\_on\_proc\%i.dat"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.number(),this-\/>communicator\_pt()-\/>my\_rank());}
\DoxyCodeLine{\ some\_file.open(filename);}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>output(some\_file,npts);}
\DoxyCodeLine{\ some\_file.close();}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>disable\_output\_of\_halo\_elements();}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Output\ solution\ }}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/soln\%i\_on\_proc\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.number(),this-\/>communicator\_pt()-\/>my\_rank());}
\DoxyCodeLine{\ some\_file.open(filename);}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>output(some\_file,npts);}
\DoxyCodeLine{\ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Output\ exact\ solution\ }}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/exact\_soln\%i\_on\_proc\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.number(),this-\/>communicator\_pt()-\/>my\_rank());}
\DoxyCodeLine{\ some\_file.open(filename);}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>output\_fct(some\_file,npts,TanhSolnForPoisson::get\_exact\_u);\ }
\DoxyCodeLine{\ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Doc\ error\ and\ return\ of\ the\ square\ of\ the\ L2\ error}}
\DoxyCodeLine{\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\ \textcolor{keywordtype}{double}\ error,norm;}
\DoxyCodeLine{\ sprintf(filename,\textcolor{stringliteral}{"{}\%s/error\%i\_on\_proc\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ doc\_info.number(),this-\/>communicator\_pt()-\/>my\_rank());}
\DoxyCodeLine{\ some\_file.open(filename);}
\DoxyCodeLine{\ Bulk\_mesh\_pt-\/>compute\_error(some\_file,TanhSolnForPoisson::get\_exact\_u,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ error,norm);\ }
\DoxyCodeLine{\ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \textcolor{comment}{//\ Doc\ L2\ error\ and\ norm\ of\ solution}}
\DoxyCodeLine{\ cout\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)nNorm\ of\ error\ \ \ :\ "{}}\ <<\ sqrt(error)\ <<\ std::endl;\ }
\DoxyCodeLine{\ cout\ <<\ \textcolor{stringliteral}{"{}Norm\ of\ solution:\ "{}}\ <<\ sqrt(norm)\ <<\ std::endl\ <<\ std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ of\ doc}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}


The remainder of this driver code is unchanged from the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\texttt{ serial version}}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{\texorpdfstring{Source files for this tutorial}{Source files for this tutorial}}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/mpi/distribution/two_d_poisson_flux_bc_adapt/}{\texttt{ demo\+\_\+drivers/mpi/distribution/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc\+\_\+adapt/ }} \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/mpi/distribution/two_d_poisson_flux_bc_adapt/two_d_poisson_flux_bc_adapt.cc}{\texttt{ demo\+\_\+drivers/mpi/distribution/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc\+\_\+adapt/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc\+\_\+adapt.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{\texorpdfstring{PDF file}{PDF file}}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
