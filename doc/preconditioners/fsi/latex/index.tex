\chapter{oomph-\/lib\textquotesingle{}s fluid-\/structure-\/interaction (FSI) preconditioner}
\hypertarget{index}{}\label{index}\index{oomph-\/lib\textquotesingle{}s fluid-\/structure-\/interaction (FSI) preconditioner@{oomph-\/lib\textquotesingle{}s fluid-\/structure-\/interaction (FSI) preconditioner}}
The purpose of this tutorial is to show how to use {\ttfamily oomph-\/lib\textquotesingle{}s} FSI preconditioner for the efficient monolithic solution of fluid-\/structure interaction problems. We illustrate the use of the preconditioner for the collapsible channel problem described in the \href{../../../interaction/fsi_channel_segregated_solver/html/index.html}{\texttt{ tutorial demonstrating the use of {\ttfamily oomph-\/lib\textquotesingle{}s} segregated FSI solver.}} The test problem used is discussed in detail in \begin{center} \href{http://www.springerlink.com/content/m3r6318701g338g4/}{\texttt{ Heil, M., Hazel, A.\+L. \& Boyle, J. (2008)\+: Solvers for large-\/displacement fluid-\/structure interaction problems\+: Segregated vs. monolithic approaches. Computational Mechanics.}} \end{center}  ~\newline
where we contrast the relative performance of segregated and monolithic solvers.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_theory}{}\doxysection{\texorpdfstring{Theory}{Theory}}\label{index_theory}
The monolithic discretisation of fluid-\/structure interaction problems in which the fluid node-\/update in response to changes in the wall shape is performed by one of {\ttfamily oomph-\/lib\textquotesingle{}s} algebraic node update techniques (such as the ones implemented in the {\ttfamily  \href{../../../the_data_structure/html/classoomph_1_1AlgebraicMesh.html}{\texttt{ Algebraic\+Mesh }}} and {\ttfamily  \href{../../../the_data_structure/html/classoomph_1_1MacroElementNodeUpdateMesh.html}{\texttt{ Macro\+Element\+Node\+Update\+Mesh}}} classes; see the relevant tutorials for a discussion of the \href{../../../interaction/fsi_collapsible_channel_algebraic/html/index.html}{\texttt{ algebraic}} and \href{../../../interaction/macro_element_free_boundary_poisson/html/index.html}{\texttt{ macro-\/element-\/based}} node update techniques) leads to Jacobian matrices that contain three types of degree of freedom, namely the fluid velocities, the fluid pressures, and the solid mechanics degrees of freedom.

{\ttfamily oomph-\/lib\textquotesingle{}s} FSI preconditioner employs the library\textquotesingle{}s \href{../../../mpi/block_preconditioners/html/index.html}{\texttt{ block-\/preconditioning framework}} to (formally) re-\/order the linear system to be solved during the Newton iteration into 3x3 blocks. We note that all fluid velocity components and all solid degrees of freedom are treated as single blocks of unknowns. The linear system therefore has the following block structure

\[
\left(
\begin{array}{cc|c}
{\bf F} & {\bf G} & {\bf  C}_{us} \\
{\bf D} & {\bf 0} & {\bf  C}_{ps} \\
\hline
{\bf C}_{su} & {\bf C}_{sp} & {\bf S} 
\end{array}
\right)
\left(
\begin{array}{c}
\delta {\bf u} \\
\delta {\bf p} \\
\hline
\delta {\bf s}
\end{array}
\right)
= 
- \left(
\begin{array}{c}
{\bf r}_{u} \\
{\bf r}_{p} \\
\hline
{\bf r}_{s}
\end{array}
\right)
\] Here the on-\/diagonal block matrices  \[
\left( 
\begin{array}{cc}
{\bf F} & {\bf G} \\ {\bf D} & {\bf 0} 
\end{array} 
\right)
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (1)
\] and  \[
\big( {\bf S} \big)
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2)
\] are the Jacobian matrices from the corresponding single-\/physics (fluid and solid) problems. The off-\/diagonal matrix blocks ${\bf C}_{**}$ arise from the interaction between fluid and solid equations\+: $ {\bf C}_{us}$ and $ {\bf C}_{ps}$ contain the so-\/called \`{}`shape derivatives'\textquotesingle{} --- the derivatives of the Navier--Stokes residuals with respect to the solid displacements that affect the nodal positions in the fluid mesh. Similarly, ${\bf C}_{su}$ and ${\bf C}_{sp}$ contain the derivatives of the solid residuals with respect to the fluid variables; this interaction arises through the fluid loading on the wall. {\ttfamily oomph-\/lib\textquotesingle{}s} algebraic node-\/update strategy ensures that the interaction matrices are very sparse. The maximum fill level for the examples presented in \href{http://www.springerlink.com/content/m3r6318701g338g4/}{\texttt{ Heil, Hazel \& Boyle\textquotesingle{}s (2008) paper }} is about 3\% and such (relatively) large values only arose in computations with very coarse meshes; the much finer meshes used in typical production runs resulted in much sparser matrices.

We showed in an earlier paper \mbox{[} \href{http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6V29-4B5C1C6-1&_user=494590&_rdoc=1&_fmt=&_orig=search&_sort=d&view=c&_acct=C000024058&_version=1&_urlVersion=0&_userid=494590&md5=1ed12ccb0a1535610fb2d11dca48a4e3}{\texttt{ Heil, M. "{}\+An efficient solver for the fully-\/coupled solution of large-\/displacement fluid-\/structure interaction problems"{}. Computer Methods in Applied Mechanics and Engineering {\bfseries{193}}, 1-\/23, (2004)}}\mbox{]} that the use of block-\/triangular approximations to the global Jacobian matrix, obtained by neglecting the fluid-\/solid or solid-\/fluid interaction blocks,  \[
{\cal P}_1 = 
\left(
\begin{array}{cc|c}
{\bf F} & {\bf G} & {\bf 0} \\
{\bf D} & {\bf 0} & {\bf 0} \\
\hline
{\bf C}_{su} & {\bf C}_{sp} & {\bf S} 
\end{array}
\right)
\mbox{\ \ and \ \ } 
{\cal  P}_2 = 
\left(
\begin{array}{cc|c}
{\bf F} & {\bf G} & {\bf C}_{us} \\
{\bf D} & {\bf 0} & {\bf C}_{ps} \\
\hline
{\bf 0} & {\bf 0} & {\bf S} 
\end{array}
\right)
\mbox{\ \ and \ \ } 
{\cal  P}_3 = 
\left(
\begin{array}{cc|c}
{\bf F} & {\bf G} & {\bf 0} \\
{\bf D} & {\bf 0} & {\bf 0} \\
\hline
{\bf 0} & {\bf 0} & {\bf S} 
\end{array}
\right)
\] in the Newton method seriously degrades its performance, resulting in the loss of its quadratic convergence and thus one of its the most attractive features. However, the block-\/triangular approximations were shown to be excellent preconditioners for the solution of the linear system by Krylov subspace methods. Because of their block-\/triangular structure, each application of the preconditioners involves linear solves with each of the two single-\/physics systems (1) and (2), and matrix-\/vector products with the retained interaction matrices.

The current implementation of the FSI preconditioner within {\ttfamily oomph-\/lib} employs Elman, Silvester \& Wathen\textquotesingle{}s \`{}`least squares commutator'\textquotesingle{} (LSC) preconditioner, \href{../../lsc_navier_stokes/html/index.html}{\texttt{ discussed in another tutorial}} to approximately solve the linear system involving the fluid matrix (1).

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_example}{}\doxysection{\texorpdfstring{An example}{An example}}\label{index_example}
To demonstrate how to use the preconditioner, here are the relevant extracts from the \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/fsi_chan_precond_driver.cc}{\texttt{ driver code {\ttfamily fsi\+\_\+chan\+\_\+precond\+\_\+driver.\+cc}}} which solves the collapsible channel problem discussed in \href{../../../interaction/fsi_channel_segregated_solver/html/index.html}{\texttt{ another tutorial.}} As explained in the \href{../../../linear_solvers/html/index.html}{\texttt{ Linear Solvers Tutorial}} switching to an iterative linear solver is typically performed in the {\ttfamily Problem} constructor and involves a few straightforward steps\+:


\begin{DoxyEnumerate}
\item {\bfseries{Create an instance of the Iterative\+Linear\+Solver and pass it to the Problem}} ~\newline
~\newline
 We create an instance of {\ttfamily GMRES}, ~\newline
~\newline
  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Build\ iterative\ linear\ solver}}
\DoxyCodeLine{\ \ \ GMRES<CRDoubleMatrix>*\ iterative\_linear\_solver\_pt\ =\ }
\DoxyCodeLine{\ \ \ \ \ \textcolor{keyword}{new}\ GMRES<CRDoubleMatrix>;}

\end{DoxyCodeInclude}
 ~\newline
 set the maximum number of iterations to 100, and increase the GMRES convergence tolerance to $ 10^{-6} $ as experiments showed this to give the fastest overall solve times; see \doxysectlink{index_comm_ex}{Further comments and exercises}{1}. ~\newline
~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Set\ maximum\ number\ of\ iterations}}
\DoxyCodeLine{\ \ \ iterative\_linear\_solver\_pt-\/>max\_iter()\ =\ 100;}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Set\ tolerance}}
\DoxyCodeLine{\ \ \ iterative\_linear\_solver\_pt-\/>tolerance()\ =\ 1.0e-\/6;\ \ \ }

\end{DoxyCodeInclude}
 ~\newline
 Finally, we pass the pointer to the iterative linear solver to the problem.~\newline
~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ \ this-\/>linear\_solver\_pt()=iterative\_linear\_solver\_pt;}

\end{DoxyCodeInclude}
 ~\newline
~\newline

\item {\bfseries{Create an instance of the Preconditioner and pass it to the Iterative\+Linear\+Solver}} ~\newline
~\newline
 We start by creating an instance of the FSI preconditioner. ~\newline
~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Create\ an\ instance\ of\ the\ FSI\ preconditioner\ -\/-\/\ pass\ the\ pointer}}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ to\ the\ problem}}
\DoxyCodeLine{\ \ \ \ \ \ FSIPreconditioner*\ prec\_pt=\textcolor{keyword}{new}\ FSIPreconditioner(\textcolor{keyword}{this});}

\end{DoxyCodeInclude}
 ~\newline
 Next we identify the meshes that contain the fluid and solid elements -- this information is required by {\ttfamily oomph-\/lib\textquotesingle{}s} block-\/preconditioning framework to identify the types of the various degrees of freedom in the Jacobian matrix. Identifying the fluid elements is straightforward as they are already contained in a distinct (sub-\/)mesh, accessible via the member function {\ttfamily bulk\+\_\+mesh\+\_\+pt()}\+: ~\newline
~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Set\ Navier\ Stokes\ mesh:}}
\DoxyCodeLine{\ \ \ \ \ \ prec\_pt-\/>set\_navier\_stokes\_mesh(this-\/>bulk\_mesh\_pt());}

\end{DoxyCodeInclude}
 ~\newline
 The {\ttfamily FSIHermite\+Beam\+Element} elements used for the discretisation of the flexible channel wall are also contained in their own (sub-\/)mesh, accessible via the member function {\ttfamily wall\+\_\+mesh\+\_\+pt()}. If displacement control is used, the {\ttfamily Displacement\+Control\+Element} introduces a further unknown into the problem\+: the adjustable external pressure; see the brief discussion of this in \href{../../../interaction/fsi_channel_segregated_solver/html/index.html}{\texttt{ another tutorial}}. We classify the external pressure as a solid mechanics degree of freedom and therefore add the {\ttfamily Displacement\+Control\+Element} to a combined solid mesh (constructed from a vector of pointers to its constituent sub-\/meshes)\+: ~\newline
~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Build\ a\ compound\ mesh\ that\ contains\ all\ solid\ elements:}}
\DoxyCodeLine{\ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Create\ a\ vector\ of\ pointers\ to\ submeshes.\ Start\ with\ the\ solid}}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ mesh\ itself.}}
\DoxyCodeLine{\ \ \ \ \ \ Vector<Mesh*>\ s\_mesh\_pt(1);}
\DoxyCodeLine{\ \ \ \ \ \ s\_mesh\_pt[0]=this-\/>wall\_mesh\_pt();}
\DoxyCodeLine{\ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Add\ the\ displacement\ control\ mesh\ if\ required}}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keywordflow}{if}\ (this-\/>Displ\_control)\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ s\_mesh\_pt.push\_back(this-\/>Displ\_control\_mesh\_pt);}
\DoxyCodeLine{\ \ \ \ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Build\ compound\ mesh\ from\ vector\ of\ solid\ submeshes}}
\DoxyCodeLine{\ \ \ \ \ \ Mesh*\ combined\_solid\_mesh\_pt\ =\ \textcolor{keyword}{new}\ Mesh(s\_mesh\_pt);}

\end{DoxyCodeInclude}
 ~\newline
 Finally, we pass the pointer to the combined solid mesh to the FSI preconditioner to identify the solid degrees of freedom (the optional boolean flag indicates that we allow the mesh to contain multiple element types)\+: ~\newline
~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Set\ solid\ mesh\ and\ tolerate\ multiple\ element\ types\ this\ is\ mesh.}}
\DoxyCodeLine{\ \ \ \ \ \ prec\_pt-\/>set\_wall\_mesh(combined\_solid\_mesh\_pt,\textcolor{keyword}{true});}

\end{DoxyCodeInclude}
 ~\newline
 The preconditioner is now fully functional and we pass ~\newline
 a pointer to it to the preconditioner\+: ~\newline
~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Pass\ preconditioner\ to\ iterative\ linear\ solver}}
\DoxyCodeLine{\ \ \ \ \ \ iterative\_linear\_solver\_pt-\/>preconditioner\_pt()=\ prec\_pt;}

\end{DoxyCodeInclude}
 ~\newline

\item {\bfseries{Customise the Preconditioner (if required)}} ~\newline
~\newline
 The {\ttfamily FSIPreconditioner} allows preconditioning to be performed with either one of the three block-\/triangular approximations to the Jacobian\+: ~\newline
~\newline

\begin{DoxyEnumerate}
\item The lower-\/triangular block preconditioner $ {\cal P}_1 $ which retains the interaction matrices $ {\bf C}_{s*} $ that represent the effect of the fluid onto the solid\+: ~\newline
~\newline
  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Choose\ preconditioner\ that\ retains\ fluid\ on\ solid\ terms}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ prec\_pt-\/>use\_block\_triangular\_version\_with\_fluid\_on\_solid();}

\end{DoxyCodeInclude}
 ~\newline

\item The upper-\/triangular block preconditioner $ {\cal P}_2 $ which retains the interaction matrices $ {\bf C}_{*s} $ that represent the effect of the solid onto the fluid\+: ~\newline
~\newline
  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Choose\ preconditioner\ that\ retains\ solid\ on\ fluid\ terms}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ prec\_pt-\/>use\_block\_triangular\_version\_with\_solid\_on\_fluid();}

\end{DoxyCodeInclude}
 ~\newline

\item The block-\/diagonal block preconditioner $ {\cal P}_3 $ which suppresses all the interaction matrices\+: ~\newline
~\newline
  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Use\ block-\/diagonal\ preconditioner}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ prec\_pt-\/>use\_block\_diagonal\_version();}

\end{DoxyCodeInclude}
 ~\newline

\end{DoxyEnumerate}The linear systems involving the fluid block are solved (approximately) by {\ttfamily oomph-\/lib\textquotesingle{}s} Least-\/\+Squares-\/\+Commutator Navier-\/\+Stokes preconditioner {\ttfamily Navier\+Stokes\+LSCPreconditioner}, discussed in \href{../../lsc_navier_stokes/html/index.html}{\texttt{ another tutorial.}} The behaviour of this (sub-\/)preconditioner may be customised too. For instance, to employ the {\ttfamily Hypre} AMG solver to solve the linear systems involving the pressure Schur complement matrix $ {\bf P}
   $ in the {\ttfamily Navier\+Stokes\+LSCPreconditioner}, we use the procedure discussed \href{../../lsc_navier_stokes/html/index.html}{\texttt{ earlier}}\+: ~\newline
~\newline
  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef\ OOMPH\_HAS\_HYPRE}}
\DoxyCodeLine{\textcolor{comment}{//If\ we\ are\ using\ MPI,\ then\ only\ use\ HYPRE\ if\ it\ has\ been\ initialised}}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef\ OOMPH\_HAS\_MPI}}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keywordflow}{if}(MPI\_Helpers::mpi\_has\_been\_initialised())}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{\ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ By\ default,\ the\ LSC\ Preconditioner\ uses\ SuperLU\ as}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ an\ exact\ preconditioner\ (i.e.\ a\ solver)\ for\ the}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ momentum\ and\ Schur\ complement\ blocks.\ }}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Can\ overwrite\ this\ by\ passing\ pointers\ to\ }}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ other\ preconditioners\ that\ perform\ the\ (approximate)}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ solves\ of\ these\ blocks.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Create\ internal\ preconditioners\ used\ on\ Schur\ block}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ HyprePreconditioner*\ P\_matrix\_preconditioner\_pt\ =\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ HyprePreconditioner;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Set\ defaults\ parameters\ for\ use\ as\ preconditioner\ on\ Poisson-\/type\ }}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ problem}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ Hypre\_default\_settings::set\_defaults\_for\_2D\_poisson\_problem(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ P\_matrix\_preconditioner\_pt);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Use\ Hypre\ for\ the\ Schur\ complement\ block}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ prec\_pt-\/>navier\_stokes\_preconditioner\_pt()-\/>}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ set\_p\_preconditioner(P\_matrix\_preconditioner\_pt);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Shut\ up}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ P\_matrix\_preconditioner\_pt-\/>disable\_doc\_time();}
\DoxyCodeLine{\ \ \ \ \ \ \ \}}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ endif\ for\ we\ have\ hypre...}}

\end{DoxyCodeInclude}

\end{DoxyEnumerate}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comm_ex}{}\doxysection{\texorpdfstring{Further comments and exercises}{Further comments and exercises}}\label{index_comm_ex}

\begin{DoxyEnumerate}
\item {\bfseries{The convergence tolerance for the iterative linear solver}}~\newline
~\newline
 Since the iterative linear solver operates within an "{}outer"{} (Newton) iteration it has occasionally been suggested to adjust the convergence tolerance for the iterative linear solver, depending on the progress of the "{}outer"{} (Newton) iteration\+: The idea is that there is little point in "{}over-\/solving"{} the linear system (i.\+e. solving it to very high precision) if the Newton method is still "{}far"{} from converged. (Only) during the final stages of the Newton iteration is an accurate solution of linear systems essential, otherwise the Newton iteration stagnates. This idea can be made rigorous (see, e.\+g., R.\+S. Dembo, S.\+C. Eisenstat and T. Steilhaug "{}\+Inexact Newton methods"{} SIAM J. Numer. Anal. {\bfseries{19}} (1982), 400-\/408). ~\newline
~\newline
 In practice we found that the method does not offer particularly great savings in CPU time; see e.\+g. \href{http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6V29-4B5C1C6-1&_user=494590&_rdoc=1&_fmt=&_orig=search&_sort=d&view=c&_acct=C000024058&_version=1&_urlVersion=0&_userid=494590&md5=1ed12ccb0a1535610fb2d11dca48a4e3}{\texttt{ Heil (2004).}} This is because the Newton method tends to converge in very few steps. Hence the need to perform the occasional additional Newton step (because the convergence tolerance of the "{}inner"{} iterative linear solver ~\newline
 was "{}just"{} not tight enough) is hardly ever compensated for by ~\newline
 the reduced number of iterations in the iterative linear solver. ~\newline
~\newline
 The GMRES convergence tolerance of $ 10^{-6} $ chosen here was found (by trial and error) to give optimal overall solve times, but this choice is problem-\/dependent and unless you are willing to perform systematic preliminary investigations, we recommend using the default convergence tolerance of $ 10^{-8} $, as defined in the {\ttfamily Iterative\+Linear\+Solver} base class. ~\newline
~\newline

\item {\bfseries{Explore the behaviour of preconditioner(s)}} ~\newline
~\newline
 The shell script \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/steady_precond.bash}{\texttt{ steady\+\_\+precond.\+bash}} may be used to explore the performance of the various FSI preconditioners. It solves the monolithically-\/discretised, steady fluid-\/structure interaction problem described in \href{http://www.springerlink.com/content/m3r6318701g338g4/}{\texttt{ Heil, Hazel \& Boyle\textquotesingle{}s (2008) paper }} with a variety of solver/preconditioner combinations\+: ~\newline
~\newline

\begin{DoxyEnumerate}
\item The direct solver, {\ttfamily Super\+LUSolver}. ~\newline
~\newline

\item {\ttfamily GMRES}, with the three FSI preconditioners $ {\cal P}_1, {\cal P}_2 $ or $ {\cal P}_3 $, discussed above, using various (sub-\/)solver combinations ({\ttfamily Super\+LUSolver} or (if available) {\ttfamily Hypre}) for the solution of linear (sub-\/)systems. ~\newline
~\newline

\item GMRES with various "{}sanity-\/check"{} preconditioners\+: ~\newline
~\newline

\begin{DoxyItemize}
\item The {\ttfamily Exact\+FSIPreconditioner\+:} A preconditioner formed from the full Jacobian matrix by re-\/arranging the entries into the appropriate block structure. This is an exact preconditioner (and its application is therefore just as costly as a direct solve) and leads to GMRES convergence in a single iteration. ~\newline
~\newline

\item The {\ttfamily Simple\+FSIPreconditioner\+:} A preconditioner that uses the block-\/triangular matrices $ {\cal P}_1, {\cal P}_2 $ or $ {\cal P}_3 $, stored as full matrices (i.\+e. without performing any block elimination). ~\newline
~\newline

\end{DoxyItemize}
\end{DoxyEnumerate}There is a second shell script \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/unsteady_precond.bash}{\texttt{ unsteady\+\_\+precond.\+bash}} that can be used to perform similar parameter studies for the corresponding unsteady problem discussed in \href{http://www.springerlink.com/content/m3r6318701g338g4/}{\texttt{ Heil, Hazel \& Boyle\textquotesingle{}s (2008) paper.}} ~\newline
~\newline

\item {\bfseries{Explore the FSI preconditioner in other problems}} ~\newline
~\newline
 The FSI preconditioner is also used in the driver codes for other demo problems\+:~\newline
~\newline

\begin{DoxyItemize}
\item \href{../../../interaction/turek_flag/html/index.html}{\texttt{ Hron \& Turek\textquotesingle{}s FSI benchmark of flow past a flag.}}~\newline
~\newline

\item \href{../../../interaction/fsi_channel_with_leaflet/html/index.html}{\texttt{ The problem of flow in a channel that is partially obstructed by an elastic leaflet.}}~\newline
~\newline

\item Your own? If so, \href{../../../contact/html/index.html}{\texttt{ let us know how}} it works.
\end{DoxyItemize}
\end{DoxyEnumerate}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{\texorpdfstring{Source files for this tutorial}{Source files for this tutorial}}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/}{\texttt{ demo\+\_\+drivers/interaction/fsi\+\_\+channel\+\_\+seg\+\_\+and\+\_\+precond }} \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/fsi_channel_seg_and_precond/fsi_chan_precond_driver.cc}{\texttt{ demo\+\_\+drivers/interaction/fsi\+\_\+channel\+\_\+seg\+\_\+and\+\_\+precond/fsi\+\_\+chan\+\_\+precond\+\_\+driver.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{\texorpdfstring{PDF file}{PDF file}}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
