\chapter{Demo problem\+: A preconditioner for the solution of Navier-\/\+Stokes equations with weakly imposed boundary conditions via Lagrange multipliers}
\hypertarget{index}{}\label{index}\index{Demo problem: A preconditioner for the solution of Navier-\/Stokes equations with weakly imposed boundary conditions via Lagrange multipliers@{Demo problem: A preconditioner for the solution of Navier-\/Stokes equations with weakly imposed boundary conditions via Lagrange multipliers}}
The purpose of this tutorial is to show how to use {\ttfamily oomph-\/lib\textquotesingle{}s} Lagrange Enforced Flow Navier-\/\+Stokes preconditioner. Similarly to the problem considered in the \href{../../../navier_stokes/vmtk_fluid/html/index.html}{\texttt{ Steady finite-\/\+Reynolds-\/number flow through an iliac bifurcation}} tutorial, the outflow boundary of the demo problem (discussed below) are not aligned with any coordinate planes. Parallel outflow is therefore enforced by a Lagrange multiplier method, implemented using {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Face\+Element} framework.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_model}{}\doxysection{\texorpdfstring{The model problem, theory and preconditioner}{The model problem, theory and preconditioner}}\label{index_model}
We will demonstrate the development and application of the preconditioner using the Poiseuille flow through a unit square domain $\Omega^{[\alpha]} \in
\mathbb{R}^2$ rotated by an arbitrary angle $\alpha$ (see the figure below). The domain $\Omega^{[\alpha]}$ is obtained by rotating the discrete points $(x_1,x_2)$ in the unit square $\Omega = [0,1]^2$ by the following transformation  \[
R(\alpha)=
\left( 
\begin{array}{cc}
{\cos(\alpha)} & {-\sin(\alpha)} \\ {\sin(\alpha)} & {\cos(\alpha)} 
\end{array} 
\right),
 \ \ \ \ \ \ \ \ \ \ (1)
\] where $\alpha$ is the angle of rotation. The figure below show the flow field (velocity vectors and pressure contours) for a unit square domain rotated by an angle of $\alpha=30^\circ $ and a Reynolds number of $ Re = 100
$. The flow is driven by a prescribed parabolic boundary condition.

 
\begin{DoxyImage}
\includegraphics[width=0.4\textwidth]{SimAng30Rey100Noel4}
\doxyfigcaption{Velocity field and pressure }
\end{DoxyImage}


For convenience, we present the boundary conditions for the non-\/rotated unit square $\alpha = 0^{\circ}$. In order to obtain the boundary conditions for $\alpha \ne 0^\circ$, we only have to apply the rotation (1). The flow is driven by imposing a parabolic velocity profile along the inflow boundary $\Omega_I$. Along the characteristic boundary, $\Omega_C$, the no-\/slip condition $u_i = 0$, $i = 1,2$, is prescribed. We impose `parallel outflow' along the outlet $\Omega_O$ by insisting that  \[     
{\bf u}\cdot {\bf t}_{} = 0 \mbox{\ \ \ \ on $\Omega_{O}$,}
 \ \ \ \ \ \ \ \ \ \ (2)
\] where $ {\bf t}$ is the tangent vector at each discrete point on the boundary $ \Omega_{O}$. We weakly enforce the flow constraint by augmenting the Navier-\/\+Stokes momentum residual equation (introduced in the \href{../../../navier_stokes/rayleigh_traction_channel/html/index.html}{\texttt{ Unsteady flow in a 2D channel, driven by an applied traction}} tutorial) with a Lagrange multiplier term so that it becomes  \[
r_{il}^{u}
=
\int_\Omega
\left[
  Re
    \left(
      St\frac{\partial u_i}{\partial t}
      + u_j\frac{\partial u_i}{\partial x_j}
    \right) \psi_l
  + \tau_{ij}\frac{\partial \psi_l}{\partial x_j}
\right]
d\Omega
-
\int_{\partial\Omega}
\tau_{ij} n_j\psi_l dS
+ \delta \Pi_{constraint} = 0,
 \ \ \ \ \ \ \ \ \ \ (3)
\] where  \[
\Pi_{constraint}
=
\int_{\partial \Omega} \lambda u_i t_i dS,
 \ \ \ \ \ \ \ \ \ \ (4)
\] and $\lambda$ is the Lagrange multiplier. Upon taking the first variation of the constraint with respect to the unknown velocity and the Lagrange multiplier, the residual form of the constrained momentum equation is  \[
r_{il}^{u}
=
\int_\Omega
\left[
  Re
    \left(
      St\frac{\partial u_i}{\partial t}
      + u_j\frac{\partial u_i}{\partial x_j}
    \right) \psi_l
  + \tau_{ij}\frac{\partial \psi_l}{\partial x_j}
\right]
d\Omega
-
\int_{\partial\Omega}
\tau_{ij} n_j\psi_l dS
+ 
\int_{\partial\Omega}
\lambda\psi_l t_i = 0.
 \ \ \ \ \ \ \ \ \ \ (5)
\] The weak formulation of (2) is simply  \[
r_{l}^{\lambda}
=
\int_\Omega
u_i t_i \psi^\lambda
dS
=
0,
 \ \ \ \ \ \ \ \ \ \ (6)
\] where $\psi^\lambda$ is a suitable basis function. Equation (5) reveals that the Lagrange multipliers act as the (negative) tangential traction $(\lambda =
-{\mathbf{n}}^T{\mathbf{\tau}}{\mathbf{t}})$ that enforce the parallel flow across the boundary $\partial\Omega_{O}$. We discretise this constraint by attaching {\ttfamily Impose\+Parallel\+Outflow\+Elements} to the boundaries of the "{}bulk"{} Navier-\/\+Stokes elements that are adjacent to $ \partial \Omega_O $ as shown in the \href{../../../navier_stokes/vmtk_fluid/html/index.html}{\texttt{ Steady finite-\/\+Reynolds-\/number flow through an iliac bifurcation}} tutorial, also see the \href{../../../solid/prescribed_displ_lagr_mult/html/index.html}{\texttt{ Deformation of a solid by a prescribed boundary motion }} tutorial which employs a similar technique used to enforce prescribed boundary displacements in solid mechanics problems. We discretise the Navier-\/\+Stokes equations using {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily QTaylor\+Hood\+Elements}, see the \href{../../../navier_stokes/driven_cavity/html/index.html}{\texttt{ 2D Driven Cavity Problem}} tutorial for more information.

The discretised problem therefore contains the following types of discrete unknowns\+:
\begin{DoxyItemize}
\item The fluid degrees of freedom (velocity and pressure).~\newline
~\newline

\item The nodal values representing the components of the (vector-\/valued) Lagrange multipliers. These only exist for the nodes on $ \partial \Omega_O$. (The nodes are re-\/sized to accommodate the additional unknowns when the {\ttfamily Impose\+Parallel\+Outflow\+Elements} are attached to the bulk elements.)
\end{DoxyItemize}

The preconditioner requires a further sub-\/division of these degrees of freedom into the following categories\+:
\begin{DoxyItemize}
\item the unconstrained velocity in the x-\/direction
\item the unconstrained velocity in the y-\/direction
\item \mbox{[}the unconstrained velocity in the z-\/direction (only in 3D)\mbox{]}
\item the constrained velocity in the x-\/direction
\item the constrained velocity in the y-\/direction
\item \mbox{[}the constrained velocity in the z-\/direction (only in 3D)\mbox{]}
\item the Lagrange multiplier at the constrained nodes
\item \mbox{[}the other Lagrange multiplier at the constrained nodes (only in 3D)\mbox{]}.
\end{DoxyItemize}For a 2D problem, the linear system to be solved in the course of the Newton iteration can then be (formally) re-\/ordered into the following block structure\+:

\[
\left[
\begin{array}{ccccc|c}
{ F_{\rm xx}}&{ F_{\rm x\bar{\rm
      x}}}&{ F_{\rm xy}}&{ F_{\rm x\bar{\rm y}}}&{ B_{\rm x}^{T}}&\\
{ F_{\bar{\rm x}\rm x}}&{ F_{\bar{\rm x}\bar{\rm x}}}&{ F_{\bar{\rm x}\rm y}}&{ F_{\bar{\rm x}\bar{\rm y}}}&{ B_{\bar{\rm x}}^{T}}&{ M_{\rm x}}\\
{ F_{\rm yx}}&{ F_{\rm y\bar{\rm
      x}}}&{ F_{\rm yy}}&{ F_{\rm y\bar{\rm y}}}&{ B_{\rm y}^{T}}&\\
{ F_{\bar{\rm y}\rm x}}&{ F_{\bar{\rm
      y}\bar{\rm x}}}&{ F_{\bar{\rm y}\rm y}}&{ 
  F_{\bar{\rm y}\bar{\rm y}}}&{ B_{\bar{\rm y}}^{T}}&{ M_{\rm y}}\\
{ B_{\rm x}}&{ B_{\bar{\rm x}}}&{ B_{\rm y}}&{ B_{\bar{\rm y}}}&\\
\hline
&{ M_{\rm x}}&&{ M_{\rm y}}&&
\end{array}
\right]
\left[
\begin{array}{c}
\Delta \mathbf{U}_{\rm x}\\
\Delta \mathbf{\overline{U}}_{\rm x}\\
\Delta \mathbf{U}_{\rm y}\\
\Delta \mathbf{\overline{U}}_{\rm y}\\
\Delta \mathbf{P}\\
\Delta \mathbf{\Lambda}
\end{array}
\right]
 =
-
\left[
\begin{array}{c}
\mathbf{r}_{\rm x}\\
\mathbf{r}_{\bar{\rm x}}\\
\mathbf{r}_{\rm y}\\
\mathbf{r}_{\bar{\rm y}}\\
\mathbf{r}_{\rm p}\\
\mathbf{r}_{\rm \Lambda}
\end{array}
\right].
\ \ \ \ \ \   (7)
\] Here the vectors ${\bf U}_{\rm x}$, ${\bf U}_{\rm y}$, ${\bf P}$ and ${\bf \Lambda}$ contain the $x$ and $y$ components of the velocity unknowns, the pressure unknowns and Lagrange multipliers unknowns, respectively. The overbars identify the unknown nodal positions that are constrained by the Lagrange multiplier. The matrices $M_{\rm x}$ and $M_{\rm y}$ are mass-\/like matrices whose entries are formed from products of the basis functions multiplied by a component of the tangent vector at each discrete point on $\partial\Omega_{O}$, for example,  $[M_{{\rm x}}]_{ij}
=
\int_{\partial \Omega_{O}} t_x {\psi_i} \ {\psi_j} \ dS $. Denote  \[
J_{\rm NS}
=
\left[
\begin{array}{ccccc}
{ F_{\rm xx}}&{ F_{\rm x\bar{\rm
      x}}}&{ F_{\rm xy}}&{ F_{\rm x\bar{\rm y}}}&{ B_{\rm x}^{T}}\\
{ F_{\bar{\rm x}\rm x}}&{ F_{\bar{\rm x}\bar{\rm x}}}&{ F_{\bar{\rm x}\rm y}}&{ F_{\bar{\rm x}\bar{\rm y}}}&{ B_{\bar{\rm x}}^{T}}\\
{ F_{\rm yx}}&{ F_{\rm y\bar{\rm
      x}}}&{ F_{\rm yy}}&{ F_{\rm y\bar{\rm y}}}&{ B_{\rm y}^{T}}\\
{ F_{\bar{\rm y}\rm x}}&{ F_{\bar{\rm
      y}\bar{\rm x}}}&{ F_{\bar{\rm y}\rm y}}&{ 
  F_{\bar{\rm y}\bar{\rm y}}}&{ B_{\bar{\rm y}}^{T}}\\
{ B_{\rm x}}&{ B_{\bar{\rm x}}}&{ B_{\rm y}}&{ B_{\bar{\rm y}}}
\end{array}
\right],
 \ \ \ 
L = 
\left[
\begin{array}{ccccc}
 &{M_{\rm x}}& &{ M_{\rm x}} &
\end{array}
\right],
 \ \ \ 
\Delta \mathbf{X}_{\rm NS}
=
\left[
\begin{array}{c}
\Delta \mathbf{U}_{\rm x}\\
\Delta \mathbf{\overline{U}}_{\rm x}\\
\Delta \mathbf{U}_{\rm y}\\
\Delta \mathbf{\overline{U}}_{\rm y}\\
\Delta \mathbf{P}
\end{array}
\right],\mbox{\ \ \ \ and }
 \ \ \ 
\mathbf{r}_{\rm NS}
=
\left[
\begin{array}{c}
\mathbf{r}_{\rm x}\\
\mathbf{r}_{\bar{\rm x}}\\
\mathbf{r}_{\rm y}\\
\mathbf{r}_{\bar{\rm y}}\\
\mathbf{r}_{\rm p}
\end{array}
\right].
\] Then we can re-\/write (7) as  \[
\left[
\begin{array}{cc}
{ J_{\rm NS}}&L^{T}\\
L& 
\end{array}
\right]
\left[
\begin{array}{c}
\Delta \mathbf{X}_{\rm NS}\\
\Delta \mathbf{\Lambda}
\end{array}
\right]
 =
-
\left[
\begin{array}{c}
\mathbf{r}_{\rm NS}\\
\mathbf{r}_{\rm \Lambda}
\end{array}
\right].
\ \ \ \ \ \   (8)
\] We have shown that  \[
P=
\left[
\begin{array}{cc}
{ J_{\rm NS}} + L^{T}W^{-1} L& \\
 & W
\end{array}
\right],
\ \ \ \ \ \   (9)
\] where $W = \frac{1}{\sigma}LL^{T}$ is an optimal preconditioner for the linear system (8) if we set $ \sigma=\|F\|_{\infty}
$ where $F$ is the compound $4\times 4$ top-\/left block  \[
F
=
\left[
\begin{array}{ccccc}
{ F_{\rm xx}}&{ F_{\rm x\bar{\rm
      x}}}&{ F_{\rm xy}}&{ F_{\rm x\bar{\rm y}}}\\
{ F_{\bar{\rm x}\rm x}}&{ F_{\bar{\rm x}\bar{\rm x}}}&{ F_{\bar{\rm x}\rm y}}&{ F_{\bar{\rm x}\bar{\rm y}}}\\
{ F_{\rm yx}}&{ F_{\rm y\bar{\rm
      x}}}&{ F_{\rm yy}}&{ F_{\rm y\bar{\rm y}}}\\
{ F_{\bar{\rm y}\rm x}}&{ F_{\bar{\rm
      y}\bar{\rm x}}}&{ F_{\bar{\rm y}\rm y}}&{ 
  F_{\bar{\rm y}\bar{\rm y}}}
\end{array}
\right]
\] in the Jacobian matrix. Application of the preconditioner $P$ requires the repeated solution of linear systems involving the diagonal blocks ${J_{\rm
NS}} + L^{T}W^{-1} L$ and $W$. The matrix $W^{-1} = \sigma
(LL^{T})^{-1} = \sigma ({M_{\rm x}}^{2}+{M_{\rm y}^{2}})^{-1}$ is dense and will cause the addition of dense sub-\/matrices to the Jacobian matrix\+:  \[
\sigma L^{T}(LL^{T})^{-1}L
=
\sigma
\left[
\begin{array}{ccccc}
\cal O &\cal O &\cal O &\cal O &\cal O \\
 \cal O&{M_{\rm x}}({M_{\rm x}}^{2}+{M_{\rm y}^{2}})^{-1}{M_{\rm x}}&\cal O &{M_{\rm x}}({M_{\rm x}}^{2}+{M_{\rm y}^{2}})^{-1}{M_{\rm y}}&\cal O \\
 \cal O&\cal O &\cal O &\cal O &\cal O \\
 \cal O&{M_{\rm y}}({M_{\rm x}}^{2}+{M_{\rm y}^{2}})^{-1}{M_{\rm x}}&\cal O &{M_{\rm y}}({M_{\rm x}}^{2}+{M_{\rm y}^{2}})^{-1}{M_{\rm y}}& \cal O\\
 \cal O&\cal O &\cal O &\cal O &\cal O
\end{array}
\right].
\] Numerical experiments show that an efficient implementation can be obtained by replacing $W$ by its diagonal approximation $\widehat{W} =
\mbox{diag}(M_{\rm x}^{2}+M_{\rm y}^{2})$. Then the inversion of $W$ is straight forward and the addition of $L^{T}{\widehat{W}}^{-1}L$ to the Jacobian does not significantly increase the number of non-\/zero entries in the matrix $J_{\rm NS}$. Denote the efficient implementation by  \[
\tilde{P}
=
\left[
\begin{array}{cc}
{ \tilde{J}_{\rm NS}}& \\
 & \widehat{W}
\end{array}
\right],
\ \ \ \ \ \   (10)
\] where $\tilde{J}_{\rm NS} =J_{\rm NS}+ L^{T}{\widehat{W}}^{-1}L$ is the augmented Navier-\/\+Stokes Jacobian matrix. In our implementation of the preconditioner, the linear system involving $\tilde{J}_{\rm NS}$ can either be solved "{}exactly"{}, using {\ttfamily Super\+LU} (in its incarnation as an exact preconditioner; this is the default) or by any other {\ttfamily Preconditioner} (interpreted as an "{}inexact solver"{}) specified via the access function 
\begin{DoxyCode}{0}
\DoxyCodeLine{LagrangeEnforcedFlowPreconditioner::set\_navier\_stokes\_preconditioner(...)}

\end{DoxyCode}
 Numerical experiments show that a nearly optimal preconditioner is obtained by replacing the solution of the linear system involving the augmented Navier-\/\+Stokes Jacobian $ \tilde{J}_{\rm NS} $ by an application of Elman, Silvester and Wathen\textquotesingle{}s \href{../../lsc_navier_stokes/html/index.html}{\texttt{ Least-\/\+Squares Commutator (LSC) preconditioner}}, and by replacing the remaining block-\/solves within these preconditioners by a small number of AMG cycles.

With these approximations, the computational cost of one application of $\tilde P$ is linear in the number of unknowns. The optimality of the preconditioner can therefore be assessed by demonstrating that the number of GMRES iterations remains constant under mesh refinement.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_example}{}\doxysection{\texorpdfstring{Demo driver and use of the preconditioner}{Demo driver and use of the preconditioner}}\label{index_example}
To demonstrate how to use the preconditioner, here are the relevant extracts from the driver code \href{../../../../demo_drivers/navier_stokes/lagrange_enforced_flow_preconditioner/two_d_tilted_square.cc}{\texttt{ two\+\_\+d\+\_\+tilted\+\_\+square.\+cc}} which solves the model problem described above. As explained in the \href{../../../linear_solvers/html/index.html}{\texttt{ Linear Solvers Tutorial}} switching to an iterative linear solver is typically performed in the {\ttfamily Problem} constructor and involves a few straightforward steps\+:


\begin{DoxyEnumerate}
\item {\bfseries{Create an instance of the Iterative\+Linear\+Solver and pass it to the Problem}} ~\newline
~\newline
 In our problem, we choose right preconditioned {\ttfamily GMRES} as the linear solver\+: ~\newline
~\newline
  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Create\ oomph-\/lib\ iterative\ linear\ solver.}}
\DoxyCodeLine{\ \ \ \ IterativeLinearSolver*\ solver\_pt\ =\ \textcolor{keyword}{new}\ GMRES<CRDoubleMatrix>;}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ We\ use\ RHS\ preconditioning.\ Note\ that\ by\ default,}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ left\ hand\ preconditioning\ is\ used.}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{static\_cast<}GMRES<CRDoubleMatrix>*\textcolor{keyword}{>}(solver\_pt)}
\DoxyCodeLine{\ \ \ \ \ \ -\/>set\_preconditioner\_RHS();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Store\ the\ solver\ pointer.}}
\DoxyCodeLine{\ \ \ \ Solver\_pt\ =\ solver\_pt;}

\end{DoxyCodeInclude}
 ~\newline
~\newline

\item {\bfseries{Create an instance of the Preconditioner and give it access to the meshes}} ~\newline
~\newline
 The {\ttfamily Lagrange\+Enforce\+Flow\+Preconditioner} takes a pointer of meshes. It is important that the bulk mesh is in position {\ttfamily 0} \+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Create\ the\ preconditioner}}
\DoxyCodeLine{\ \ LagrangeEnforcedFlowPreconditioner*\ lgr\_prec\_pt}
\DoxyCodeLine{\ \ \ \ =\ \textcolor{keyword}{new}\ LagrangeEnforcedFlowPreconditioner;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Create\ the\ vector\ of\ mesh\ pointers!}}
\DoxyCodeLine{\ \ Vector<Mesh*>\ mesh\_pt;}
\DoxyCodeLine{\ \ mesh\_pt.resize(2,0);}
\DoxyCodeLine{\ \ mesh\_pt[0]\ =\ Bulk\_mesh\_pt;}
\DoxyCodeLine{\ \ mesh\_pt[1]\ =\ Surface\_mesh\_P\_pt;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ lgr\_prec\_pt-\/>set\_meshes(mesh\_pt);}

\end{DoxyCodeInclude}
 By default, {\ttfamily Super\+LUPreconditioner} is used for all subsidiary block solves. To use the LSC preconditioner to approximately solve the sub-\/block system involving the momentum block, we invoke the following\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Create\ the\ NS\ LSC\ preconditioner.}}
\DoxyCodeLine{\ \ \ \ lsc\_prec\_pt\ =\ \textcolor{keyword}{new}\ NavierStokesSchurComplementPreconditioner(\textcolor{keyword}{this});}
\DoxyCodeLine{\ \ \ \ lsc\_prec\_pt-\/>set\_navier\_stokes\_mesh(Bulk\_mesh\_pt);}
\DoxyCodeLine{\ \ \ \ lsc\_prec\_pt-\/>use\_lsc();}
\DoxyCodeLine{\ \ \ \ lgr\_prec\_pt-\/>set\_navier\_stokes\_preconditioner(lsc\_prec\_pt);}

\end{DoxyCodeInclude}
 The LSC preconditioner is discussed in \href{../../lsc_navier_stokes/html/index.html}{\texttt{ another tutorial}}. ~\newline
~\newline

\item {\bfseries{Pass the preconditioner to the solver, and the solver to the problem }} ~\newline
~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Pass\ the\ preconditioner\ to\ the\ solver.}}
\DoxyCodeLine{\ \ Solver\_pt-\/>preconditioner\_pt()\ =\ lgr\_prec\_pt;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Pass\ the\ solver\ to\ the\ problem.}}
\DoxyCodeLine{\ \ this-\/>linear\_solver\_pt()\ =\ Solver\_pt;}

\end{DoxyCodeInclude}
 ~\newline
~\newline

\end{DoxyEnumerate}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{\texorpdfstring{Source files for this tutorial}{Source files for this tutorial}}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/navier_stokes/lagrange_enforced_flow_preconditioner}{\texttt{ demo\+\_\+drivers/navier\+\_\+stokes/lagrange\+\_\+enforced\+\_\+flow\+\_\+preconditioner }} \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/navier_stokes/lagrange_enforced_flow_preconditioner/two_d_tilted_square.cc}{\texttt{ demo\+\_\+drivers/navier\+\_\+stokes/lagrange\+\_\+enforced\+\_\+flow\+\_\+preconditioner/two\+\_\+d\+\_\+tilted\+\_\+square.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{\texorpdfstring{PDF file}{PDF file}}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
